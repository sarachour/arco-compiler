==== Loaded Config File (benchmarks/biology_nojaunt/configs/prod.cfg) ====
bool enable-jaunt false
int multi-num-global-solutions 1
bool eqn-use-map-heuristic true
int slvr-solutions 1
string multi-selector-branch solved-and-ncomps
int multi-num-global-solutions-per-partial 1
int slvr-partial-depth 15
int interactive 0
int eqn-unifications 12
int multi-num-partial-solutions 1
int map-infer-feasible-timeout 60
int slvr-global-depth 30
int debug 2
string eqn-selector-goal trivial
int z3-minimize-depth 4
int uast-depth 5
string uast-selector-branch uniform
bool _force false
string z3-minimize-strategy binary
string eqn-selector-branch goals
=================================
======== Infer Math Vars =============
derive: ES -> [-44.,2992.]
inference hw vars
-> derived [0.,5000.] -> P
-> derived [0.,10.] -> PROD
-> derived [0.,3300.] -> Y
-> derived [0.,10.] -> REP2
-> derived [0.,1.] -> Y
-> derived [0.,80000.] -> REP
-> derived [0.,1000000.] -> STIM
-> derived [0.,10.] -> Y
-> derived {[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } -> OUT
-> derived [0.,10.] -> Y
-> derived [-5.,10.] -> OUT
-> derived [0.,10.] -> GE
==== Units ====
==== Vars =====
> MAKE vgain
input(<vgain,X>)
cover
input(<vgain,Z>)
cover
output(<vgain,P>)
cover
>
>
offset(<vgain,X>)=0
offset(<vgain,Z>)=0
ve(scale(<vgain,P>)=scale(<vgain,X>)*scale(<vgain,Z>))
offset(<vgain,P>)=0
>>> # Partitions vgain=3
> MAKE switch
input(<switch,n>)
cover
input(<switch,SUB>)
cover
input(<switch,Kmod>)
cover
input(<switch,Vmax>)
cover
output(<switch,PROD>)
cover
>
>
offset(<switch,SUB>)=0
offset(<switch,Kmod>)=0
ee(scale(<switch,Kmod>)^-1*scale(<switch,SUB>)=scale(<switch,Kmod>)^-1*scale(<switch,SUB>))
ee(1=scale(<switch,Kmod>)^-1*scale(<switch,SUB>))
ee(scale(<switch,Kmod>)^-1*scale(<switch,SUB>)=1)
ee(1=1)
>
offset(<switch,n>)=0
valid
ec(0+0=0)
valid
ec(scale(<switch,n>)/1=1)
valid
valid
>
offset(<switch,Vmax>)=0
valid
ve(scale(<switch,PROD>)=1/1^(switch.V{n}:/500.)*scale(<switch,Vmax>))
offset(<switch,PROD>)=0
>>> # Partitions switch=4
> MAKE ihill_stim
input(<ihill_stim,n>)
cover
input(<ihill_stim,S>)
cover
input(<ihill_stim,Km>)
cover
input(<ihill_stim,Vmax>)
cover
output(<ihill_stim,STIM>)
cover
>
>
offset(<ihill_stim,S>)=0
offset(<ihill_stim,Km>)=0
>
valid
offset(<ihill_stim,n>)=0
scale(<ihill_stim,n>)=1
>
>
offset(<ihill_stim,S>)=0
offset(<ihill_stim,Km>)=0
>
valid
offset(<ihill_stim,n>)=0
scale(<ihill_stim,n>)=1
ee(scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:=scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:)
ee(1=scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:)
ee(scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:=1)
ee(1=1)
valid
ec(0+0=0)
>
ve(scale(<ihill_stim,STIM>)=scale(<ihill_stim,Vmax>)*scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:/1)
offset(<ihill_stim,STIM>)=0
>>> # Partitions ihill_stim=4
> MAKE ihill_rep
input(<ihill_rep,n>)
cover
input(<ihill_rep,S>)
cover
input(<ihill_rep,Km>)
cover
input(<ihill_rep,Vmax>)
cover
output(<ihill_rep,REP>)
cover
>
>
offset(<ihill_rep,Km>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
>
>
offset(<ihill_rep,S>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
>
>
offset(<ihill_rep,Km>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
ee(scale(<ihill_rep,Km>)^ihill_rep.V{n}:=scale(<ihill_rep,Km>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,S>)^ihill_rep.V{n}:=scale(<ihill_rep,Km>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,Km>)^ihill_rep.V{n}:=scale(<ihill_rep,S>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,S>)^ihill_rep.V{n}:=scale(<ihill_rep,S>)^ihill_rep.V{n}:)
valid
ec(0+0=0)
>
offset(<ihill_rep,Vmax>)=0
valid
ve(scale(<ihill_rep,REP>)=scale(<ihill_rep,Km>)^ihill_rep.V{n}:/scale(<ihill_rep,S>)^ihill_rep.V{n}:*scale(<ihill_rep,Vmax>))
offset(<ihill_rep,REP>)=0
>>> # Partitions ihill_rep=4
> MAKE vdadd
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
valid
offset(<vdadd,D>)=0
offset(<vdadd,OUT>)=0
>
valid
offset(<vdadd,B>)=0
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=2
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
valid
offset(<vdadd,D>)=0
offset(<vdadd,OUT>)=0
>
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=3
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
>
valid
offset(<vdadd,B>)=0
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=3
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
>
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=4
> MAKE ihill_rep2
input(<ihill_rep2,n>)
cover
input(<ihill_rep2,S>)
cover
input(<ihill_rep2,Vmax>)
cover
output(<ihill_rep2,REP2>)
cover
>
>
offset(<ihill_rep2,S>)=0
offset(<ihill_rep2,n>)=0
scale(<ihill_rep2,n>)=1
ee(scale(<ihill_rep2,S>)^ihill_rep2.V{n}:=scale(<ihill_rep2,S>)^ihill_rep2.V{n}:)
ee(1=scale(<ihill_rep2,S>)^ihill_rep2.V{n}:)
ee(scale(<ihill_rep2,S>)^ihill_rep2.V{n}:=1)
ee(1=1)
valid
ec(0+0=0)
>
offset(<ihill_rep2,Vmax>)=0
valid
vv(scale(<ihill_rep2,REP2>)=scale(<ihill_rep2,Vmax>))
offset(<ihill_rep2,REP2>)=0
>>> # Partitions ihill_rep2=2
> MAKE input.I
input(<input.I,X>)
cover
output(<input.I,O>)
cover
>
vv(scale(<input.I,O>)=scale(<input.I,X>))
vv(offset(<input.I,O>)=offset(<input.I,X>))
>>> # Partitions input.I=2
> MAKE output.V
input(<output.V,X>)
cover
output(<output.V,O>)
cover
>
vv(scale(<output.V,O>)=scale(<output.V,X>))
vv(offset(<output.V,O>)=offset(<output.V,X>))
>>> # Partitions output.V=2
> MAKE copy.V
input(<copy.V,X>)
cover
output(<copy.V,Y>)
cover
>
vv(scale(<copy.V,Y>)=scale(<copy.V,X>))
vv(offset(<copy.V,Y>)=offset(<copy.V,X>))
>>> # Partitions copy.V=2
> MAKE vadd
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
valid
offset(<vadd,C>)=0
>
valid
offset(<vadd,B>)=0
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=3
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
valid
offset(<vadd,C>)=0
>
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=4
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
>
valid
offset(<vadd,B>)=0
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=4
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
>
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=5
> MAKE vtoi
input(<vtoi,X>)
cover
input(<vtoi,K>)
cover
output(<vtoi,Y>)
cover
>
>
valid
offset(<vtoi,K>)=0
valid
offset(<vtoi,X>)=0
ve(scale(<vtoi,Y>)=scale(<vtoi,K>)^-1*scale(<vtoi,X>))
offset(<vtoi,Y>)=0
>>> # Partitions vtoi=3
> MAKE igenebind
input(<igenebind,TF>)
cover
input(<igenebind,K>)
cover
input(<igenebind,Vmax>)
cover
output(<igenebind,GE>)
cover
>
>
offset(<igenebind,K>)=0
offset(<igenebind,TF>)=0
ee(1=1)
ee(scale(<igenebind,K>)*scale(<igenebind,TF>)=1)
ee(1=scale(<igenebind,K>)*scale(<igenebind,TF>))
ee(scale(<igenebind,K>)*scale(<igenebind,TF>)=scale(<igenebind,K>)*scale(<igenebind,TF>))
valid
ec(0+0=0)
>
offset(<igenebind,Vmax>)=0
valid
ve(scale(<igenebind,GE>)=scale(<igenebind,K>)^-1*scale(<igenebind,TF>)^-1*scale(<igenebind,Vmax>))
offset(<igenebind,GE>)=0
>>> # Partitions igenebind=4
> MAKE mm
input(<mm,kr>)
cover
input(<mm,XY0>)
cover
input(<mm,Ytot>)
cover
input(<mm,kf>)
cover
input(<mm,Xtot>)
cover
output(<mm,X>)
cover
output(<mm,XY>)
cover
XY
output(<mm,Y>)
cover
>
>
vv(scale(<mm,Xtot>)=scale(<mm,Xtot>))
vv(scale(<mm,XY>)=scale(<mm,Xtot>))
vv(scale(<mm,Xtot>)=scale(<mm,XY>))
vv(scale(<mm,XY>)=scale(<mm,XY>))
vv(scale(<mm,X>)=scale(<mm,Xtot>))
ve(offset(<mm,X>)=offset(<mm,XY>)+offset(<mm,Xtot>))
>
>
offset(<mm,kr>)=0
offset(<mm,XY>)=0
>
>
>
offset(<mm,kf>)=0
offset(<mm,X>)=0
offset(<mm,Y>)=0
ee(scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>)=scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>))
ee(scale(<mm,XY>)*scale(<mm,kr>)=scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>))
ee(scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>)=scale(<mm,XY>)*scale(<mm,kr>))
ee(scale(<mm,XY>)*scale(<mm,kr>)=scale(<mm,XY>)*scale(<mm,kr>))
ve(scale(<mm,XY>)=scale(<mm,XY>)*scale(<mm,kr>))
offset(<mm,XY>)=0
=
priority
offset(<mm,XY>)=0
vv(scale(<mm,XY>)=scale(<mm,XY0>))
vv(offset(<mm,XY>)=offset(<mm,XY0>))
>
>
vv(scale(<mm,Ytot>)=scale(<mm,Ytot>))
vv(scale(<mm,XY>)=scale(<mm,Ytot>))
vv(scale(<mm,Ytot>)=scale(<mm,XY>))
vv(scale(<mm,XY>)=scale(<mm,XY>))
vv(scale(<mm,Y>)=scale(<mm,Ytot>))
ve(offset(<mm,Y>)=offset(<mm,XY>)+offset(<mm,Ytot>))
>>> # Partitions mm=4
> MAKE input.V
input(<input.V,X>)
cover
output(<input.V,O>)
cover
>
vv(scale(<input.V,O>)=scale(<input.V,X>))
vv(offset(<input.V,O>)=offset(<input.V,X>))
>>> # Partitions input.V=2
> MAKE itov
input(<itov,X>)
cover
input(<itov,K>)
cover
output(<itov,Y>)
cover
>
>
offset(<itov,K>)=0
offset(<itov,X>)=0
ve(scale(<itov,Y>)=scale(<itov,K>)*scale(<itov,X>))
offset(<itov,Y>)=0
>>> # Partitions itov=3
> MAKE iadd
input(<iadd,C>)
cover
input(<iadd,A>)
cover
input(<iadd,B>)
cover
output(<iadd,OUT>)
cover
>
>
>
vv(scale(<iadd,A>)=scale(<iadd,A>))
vv(scale(<iadd,B>)=scale(<iadd,A>))
vv(scale(<iadd,A>)=scale(<iadd,B>))
vv(scale(<iadd,B>)=scale(<iadd,B>))
vv(scale(<iadd,A>)=scale(<iadd,A>))
vv(scale(<iadd,C>)=scale(<iadd,A>))
vv(scale(<iadd,A>)=scale(<iadd,C>))
vv(scale(<iadd,C>)=scale(<iadd,C>))
vv(scale(<iadd,OUT>)=scale(<iadd,A>))
ve(offset(<iadd,OUT>)=offset(<iadd,A>)+offset(<iadd,B>)+offset(<iadd,C>))
>>> # Partitions iadd=5
> MAKE output.I
input(<output.I,X>)
cover
output(<output.I,O>)
cover
>
vv(scale(<output.I,O>)=scale(<output.I,X>))
vv(offset(<output.I,O>)=offset(<output.I,X>))
>>> # Partitions output.I=2
> MAKE copy.I
input(<copy.I,X>)
cover
output(<copy.I,Y>)
cover
>
vv(scale(<copy.I,Y>)=scale(<copy.I,X>))
vv(offset(<copy.I,Y>)=offset(<copy.I,X>))
>>> # Partitions copy.I=2
=== mm ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<mm,Ytot>)

v(0) = exprs=v(0)+v(2)=v(0)+v(1)
cstrs==
value=0
mems=offset(<mm,XY0>),offset(<mm,Y>),offset(<mm,kf>),offset(<mm,XY>),offset(<mm,kr>),offset(<mm,X>)

v(3) = exprs=v(3)*v(3)*v(3)=v(3)*v(3)
cstrs=>
value=<none>
mems=scale(<mm,Ytot>),scale(<mm,Y>),scale(<mm,XY>),scale(<mm,XY0>),scale(<mm,kr>),scale(<mm,kf>),scale(<mm,Xtot>),scale(<mm,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<mm,Xtot>)


kr = string_of_map_port: unimpl
XY0 = string_of_map_port: unimpl
Ytot = string_of_map_port: unimpl
Xtot = string_of_map_port: unimpl
kf = string_of_map_port: unimpl

X = string_of_map_port: unimpl
XY = string_of_map_port: unimpl
Y = string_of_map_port: unimpl



=== vgain ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=0
mems=offset(<vgain,P>),offset(<vgain,Z>),offset(<vgain,X>)

v(0) = exprs=v(1)*v(1)
cstrs=
value=<none>
mems=scale(<vgain,P>)

v(1) = exprs=
cstrs=>
value=<none>
mems=scale(<vgain,Z>),scale(<vgain,X>)


X = string_of_map_port: unimpl
Z = string_of_map_port: unimpl

P = string_of_map_port: unimpl



=== vdadd ===
 = 
 = ====== #2 ======
v(2) = exprs=
cstrs==
value=0
mems=offset(<vdadd,D>),offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>)

v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,B>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,B>)

v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(3) = exprs=
cstrs==
value=0
mems=offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,D>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #3 ======
v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs==
value=0
mems=offset(<vdadd,D>),offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>),offset(<vdadd,B>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #1 ======
v(2) = exprs=
cstrs==
value=0
mems=offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>),offset(<vdadd,B>)

v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,D>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== switch ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=>
value=<none>
mems=scale(<switch,n>),scale(<switch,Vmax>),scale(<switch,Kmod>),scale(<switch,SUB>)

v(0) = exprs=v(2)/1=v(2)^-1*v(2)
cstrs=
value=1
mems=

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<switch,SUB>),offset(<switch,n>),offset(<switch,Kmod>),offset(<switch,PROD>),offset(<switch,Vmax>)

v(1) = exprs=1/1^(switch.V{n}:/500.)*v(2)
cstrs=
value=<none>
mems=scale(<switch,PROD>)


SUB = string_of_map_port: unimpl
n = string_of_map_port: unimpl
Kmod = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

PROD = string_of_map_port: unimpl



=== itov ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=0
mems=offset(<itov,K>),offset(<itov,X>),offset(<itov,Y>)

v(0) = exprs=v(1)*v(1)
cstrs=
value=<none>
mems=scale(<itov,Y>)

v(1) = exprs=
cstrs=>
value=<none>
mems=scale(<itov,K>),scale(<itov,X>)


X = string_of_map_port: unimpl
K = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== output.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<output.I,O>),scale(<output.I,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<output.I,X>),offset(<output.I,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== input.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<input.V,X>),scale(<input.V,O>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<input.V,X>),offset(<input.V,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== output.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<output.V,X>),scale(<output.V,O>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<output.V,O>),offset(<output.V,X>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== ihill_rep2 ===
 = 
 = ====== #0 ======
v(0) = exprs=v(0)^ihill_rep2.V{n}:=1
cstrs=>
value=<none>
mems=scale(<ihill_rep2,n>),scale(<ihill_rep2,REP2>),scale(<ihill_rep2,Vmax>),scale(<ihill_rep2,S>)

v(1) = exprs=0+0
cstrs=
value=0
mems=offset(<ihill_rep2,Vmax>),offset(<ihill_rep2,S>),offset(<ihill_rep2,REP2>),offset(<ihill_rep2,n>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

REP2 = string_of_map_port: unimpl



=== copy.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<copy.V,Y>),scale(<copy.V,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<copy.V,X>),offset(<copy.V,Y>)


X = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== ihill_rep ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=>
value=1
mems=scale(<ihill_rep,Km>),scale(<ihill_rep,S>),scale(<ihill_rep,n>),scale(<ihill_rep,Vmax>)

v(0) = exprs=v(2)^ihill_rep.V{n}:=v(2)^ihill_rep.V{n}:
cstrs=
value=<none>
mems=

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<ihill_rep,n>),offset(<ihill_rep,REP>),offset(<ihill_rep,Km>),offset(<ihill_rep,S>),offset(<ihill_rep,Vmax>)

v(1) = exprs=v(2)^ihill_rep.V{n}:/v(2)^ihill_rep.V{n}:*v(2)
cstrs=
value=<none>
mems=scale(<ihill_rep,REP>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Km = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

REP = string_of_map_port: unimpl



=== ihill_stim ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<ihill_stim,Vmax>)

v(0) = exprs=v(0)/v(0)^ihill_stim.V{n}:=1
cstrs=>
value=<none>
mems=scale(<ihill_stim,S>),scale(<ihill_stim,n>),scale(<ihill_stim,Vmax>),scale(<ihill_stim,Km>)

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<ihill_stim,STIM>),offset(<ihill_stim,n>),offset(<ihill_stim,S>),offset(<ihill_stim,Km>)

v(1) = exprs=v(0)*v(0)/v(0)^ihill_stim.V{n}:/1
cstrs=
value=<none>
mems=scale(<ihill_stim,STIM>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Km = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

STIM = string_of_map_port: unimpl



=== vtoi ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=0
mems=offset(<vtoi,X>),offset(<vtoi,Y>),offset(<vtoi,K>)

v(0) = exprs=v(1)^-1*v(1)
cstrs=
value=<none>
mems=scale(<vtoi,Y>)

v(1) = exprs=
cstrs=>
value=<none>
mems=scale(<vtoi,X>),scale(<vtoi,K>)


X = string_of_map_port: unimpl
K = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== vadd ===
 = 
 = ====== #2 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,B>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(3) = exprs=
cstrs=
value=0
mems=offset(<vadd,C>),offset(<vadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(3) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,B>)

v(4) = exprs=v(2)+0+0
cstrs=
value=0
mems=offset(<vadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,C>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #3 ======
v(2) = exprs=v(1)+0+0
cstrs=
value=0
mems=offset(<vadd,B>),offset(<vadd,C>),offset(<vadd,OUT>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #1 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(3) = exprs=v(2)+0+0
cstrs=
value=0
mems=offset(<vadd,B>),offset(<vadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,C>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== copy.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<copy.I,Y>),scale(<copy.I,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<copy.I,X>),offset(<copy.I,Y>)


X = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== iadd ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<iadd,A>)

v(0) = exprs=v(2)+v(1)+v(3)
cstrs=
value=<none>
mems=offset(<iadd,OUT>)

v(3) = exprs=
cstrs=
value=<none>
mems=offset(<iadd,C>)

v(4) = exprs=
cstrs=>
value=<none>
mems=scale(<iadd,OUT>),scale(<iadd,A>),scale(<iadd,B>),scale(<iadd,C>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<iadd,B>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== input.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<input.I,O>),scale(<input.I,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<input.I,X>),offset(<input.I,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== igenebind ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=>
value=<none>
mems=scale(<igenebind,TF>),scale(<igenebind,Vmax>),scale(<igenebind,K>)

v(0) = exprs=1=v(2)*v(2)
cstrs=
value=<none>
mems=

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<igenebind,GE>),offset(<igenebind,K>),offset(<igenebind,Vmax>),offset(<igenebind,TF>)

v(1) = exprs=v(2)^-1*v(2)^-1*v(2)
cstrs=
value=<none>
mems=scale(<igenebind,GE>)


TF = string_of_map_port: unimpl
K = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

GE = string_of_map_port: unimpl



[multi] # Found 0, Required: 1
[multi] solving target: ES
[multi] search tree is not exhausted. adding existing:ES
[multi] finding new partial solution
[multi] made a partial tree with 3 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
[1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
[1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}

============
>> Current Goal: [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
vdadd.OUT -> true
mm.XY -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  2 <<<
[eqn] new: [0] <vdadd> output OUT.V
<analog-st> ((vdadd.V{A}:+(vdadd.BSW*vdadd.V{B}:))-(vdadd.DSW*vdadd.I{D}:*vdadd.V{OUT}:)) ic=OUT_0.V / std=none 0
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,12000.] {v}->[v]=@ {v}->*[v]=@


checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <mm> output XY.V
<analog-st> ((mm.I{kf}:*mm.V{X}:*mm.V{Y}:)-(mm.I{kr}:*mm.V{XY}:)) ic=XY0.V / std=gauss ((0.001*mm.V{XY}:)+0.1)
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,3200.] {v}->[v]=@ {v}->*[v]=@


checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
[eqn] [FOUND-SOLS] ===> Found <31> solutions
[slvrsearch] > weight--: <mvar-goal>ES
[eqn] -> [valid?] testing node 63
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=0

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 62
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=1

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 61
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=2

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 60
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=3

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 59
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=4

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 58
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=5

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 57
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=6

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 56
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=7

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 55
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=8

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 54
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=9

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 53
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=10

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 52
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=11

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 51
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=12

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 50
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=13

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 49
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=14

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 48
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=15

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 47
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=16

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 46
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=17

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 45
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=18

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 44
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=19

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 43
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=20

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 42
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=21

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 41
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=22

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 40
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=23

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 34
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 54 ==
[multi] == Adding Local Solution : 45 ==
[multi] == Adding Local Solution : 50 ==
[multi] == Adding Local Solution : 53 ==
[multi] == Adding Local Solution : 47 ==
[multi] == Adding Local Solution : 40 ==
[multi] == Adding Local Solution : 52 ==
[multi] == Adding Local Solution : 49 ==
[multi] == Adding Local Solution : 44 ==
[multi] == Adding Local Solution : 55 ==
[multi] == Adding Local Solution : 62 ==
[multi] == Adding Local Solution : 60 ==
[multi] == Adding Local Solution : 59 ==
[multi] == Adding Local Solution : 57 ==
[multi] == Adding Local Solution : 41 ==
[multi] == Adding Local Solution : 61 ==
[multi] == Adding Local Solution : 56 ==
[multi] == Adding Local Solution : 42 ==
[multi] == Adding Local Solution : 58 ==
[multi] == Adding Local Solution : 46 ==
[multi] == Adding Local Solution : 63 ==
[multi] == Adding Local Solution : 51 ==
[multi] == Adding Local Solution : 48 ==
[multi] == Adding Local Solution : 43 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Xtot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Ytot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].X = S
[multi]    - making an output block.
[multi] > mm[0].Y = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Xtot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Ytot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [59] [CONN] input.V[0].O => mm[0].Xtot (4400)
     add-goal [60] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [61] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [62] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [63] [CONN] input.V[2].O => mm[0].Ytot (6800)
     add-goal [64] [CONN] mm[0].X => output.V[0].X (S)
     add-goal [65] [CONN] mm[0].Y => output.V[1].X (E)
     add-goal [66] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[63] [CONN] input.V[2].O => mm[0].Ytot (6800)
[66] [CONN] mm[0].XY => output.V[2].X (ES)
[61] [CONN] input.I[0].O => mm[0].kf (0.0001)
[59] [CONN] input.V[0].O => mm[0].Xtot (4400)
[64] [CONN] mm[0].X => output.V[0].X (S)
[60] [CONN] input.V[1].O => mm[0].XY0 (0)
[62] [CONN] input.I[1].O => mm[0].kr (0.01)
[65] [CONN] mm[0].Y => output.V[1].X (E)

============
>> Current Goal: [65] [CONN] mm[0].Y => output.V[1].X (E)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=24

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~54 :: 3
[multi] Number of Solutions: 0
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: ES~54 :: 3
[[Z3]] ---> Executing SMT Solver prob=25

[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: mm[0].X
[rslvr] z32cstr.wire: mm[0].XY0
[rslvr] z32cstr.wire: mm[0].Xtot
[rslvr] z32cstr.wire: mm[0].XY
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: mm[0].kr
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: mm[0].Y
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: mm[0].kf
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: mm[0].Ytot
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: output.V[2].X
[dbg] === Emitting Library ===
===> Emitting Simulation to ckt_smmrxnbig_0_sdeIdeal.m
[dbg] === Emitting Library ===
===> Emitting Simulation to ckt_smmrxnbig_0_odeIdeal.m
[dbg] === Emitting Library ===
===> Emitting Simulation to ckt_smmrxnbig_0_sdeCirc.m
[dbg] === Emitting Library ===
===> Emitting Simulation to ckt_smmrxnbig_0_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=26

[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: mm[0].X
[rslvr] z32cstr.wire: mm[0].XY0
[rslvr] z32cstr.wire: mm[0].Xtot
[rslvr] z32cstr.wire: mm[0].XY
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: mm[0].kr
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: mm[0].Y
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: mm[0].kf
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: mm[0].Ytot
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: output.V[2].X
->input.I[1]
->mm[0]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->input.I[0]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (20) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 4
[[Z3]] ---> Executing SMT Solver prob=27

[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [67] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [68] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [69] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [70] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [71] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [72] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [73] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [74] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[71] [CONN] input.V[2].O => mm[0].Xtot (6800)
[69] [CONN] input.I[0].O => mm[0].kf (0.0001)
[74] [CONN] mm[0].XY => output.V[2].X (ES)
[68] [CONN] input.V[1].O => mm[0].XY0 (0)
[72] [CONN] mm[0].Y => output.V[0].X (S)
[70] [CONN] input.I[1].O => mm[0].kr (0.01)
[67] [CONN] input.V[0].O => mm[0].Ytot (4400)
[73] [CONN] mm[0].X => output.V[1].X (E)

============
>> Current Goal: [73] [CONN] mm[0].X => output.V[1].X (E)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=28

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~45 :: 3
[multi] Number of Solutions: 1
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: ES~45 :: 3
[[Z3]] ---> Executing SMT Solver prob=29

[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: mm[0].Y
[rslvr] z32cstr.wire: mm[0].XY0
[rslvr] z32cstr.wire: mm[0].Ytot
[rslvr] z32cstr.wire: mm[0].XY
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: mm[0].kr
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: mm[0].X
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: mm[0].kf
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: mm[0].Xtot
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: output.V[2].X
[dbg] === Emitting Library ===
===> Emitting Simulation to ckt_smmrxnbig_1_sdeIdeal.m
[dbg] === Emitting Library ===
===> Emitting Simulation to ckt_smmrxnbig_1_odeIdeal.m
[dbg] === Emitting Library ===
===> Emitting Simulation to ckt_smmrxnbig_1_sdeCirc.m
[dbg] === Emitting Library ===
===> Emitting Simulation to ckt_smmrxnbig_1_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=30

[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: mm[0].Y
[rslvr] z32cstr.wire: mm[0].XY0
[rslvr] z32cstr.wire: mm[0].Ytot
[rslvr] z32cstr.wire: mm[0].XY
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: mm[0].kr
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: mm[0].X
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: mm[0].kf
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: mm[0].Xtot
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: output.V[2].X
->input.I[1]
->mm[0]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->input.I[0]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (20) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 4
[[Z3]] ---> Executing SMT Solver prob=31

[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [75] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [76] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [77] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [78] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [79] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [80] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [81] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [82] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[75] [CONN] input.V[0].O => mm[0].Ytot (4400)
[79] [CONN] input.V[2].O => mm[0].Xtot (6800)
[82] [CONN] mm[0].XY => output.V[2].X (ES)
[76] [CONN] input.V[1].O => mm[0].XY0 (0)
[77] [CONN] input.I[0].O => mm[0].kf (0.0001)
[81] [CONN] mm[0].X => output.V[1].X (E)
[80] [CONN] mm[0].Y => output.V[0].X (S)
[78] [CONN] input.I[1].O => mm[0].kr (0.01)

============
>> Current Goal: [78] [CONN] input.I[1].O => mm[0].kr (0.01)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=32

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~50 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].X = S
   [sln] generate mm[0].Y = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Xtot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Ytot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].X = S
[multi]    - making an output block.
[multi] > mm[0].Y = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].X = S
   [sln] generate mm[0].Y = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Xtot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Ytot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [83] [CONN] input.V[0].O => mm[0].Xtot (4400)
     add-goal [84] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [85] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [86] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [87] [CONN] input.V[2].O => mm[0].Ytot (6800)
     add-goal [88] [CONN] mm[0].X => output.V[0].X (S)
     add-goal [89] [CONN] mm[0].Y => output.V[1].X (E)
     add-goal [90] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[86] [CONN] input.I[1].O => mm[0].kr (0.01)
[88] [CONN] mm[0].X => output.V[0].X (S)
[83] [CONN] input.V[0].O => mm[0].Xtot (4400)
[84] [CONN] input.V[1].O => mm[0].XY0 (0)
[87] [CONN] input.V[2].O => mm[0].Ytot (6800)
[85] [CONN] input.I[0].O => mm[0].kf (0.0001)
[89] [CONN] mm[0].Y => output.V[1].X (E)
[90] [CONN] mm[0].XY => output.V[2].X (ES)

============
>> Current Goal: [90] [CONN] mm[0].XY => output.V[2].X (ES)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=33

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~53 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [91] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [92] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [93] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [94] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [95] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [96] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [97] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [98] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[96] [CONN] mm[0].Y => output.V[0].X (S)
[98] [CONN] mm[0].XY => output.V[2].X (ES)
[92] [CONN] input.V[1].O => mm[0].XY0 (0)
[95] [CONN] input.V[2].O => mm[0].Xtot (6800)
[93] [CONN] input.I[0].O => mm[0].kf (0.0001)
[94] [CONN] input.I[1].O => mm[0].kr (0.01)
[97] [CONN] mm[0].X => output.V[1].X (E)
[91] [CONN] input.V[0].O => mm[0].Ytot (4400)

============
>> Current Goal: [91] [CONN] input.V[0].O => mm[0].Ytot (4400)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=34

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~47 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Xtot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Ytot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].X = S
[multi]    - making an output block.
[multi] > mm[0].Y = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Xtot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Ytot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [99] [CONN] input.V[0].O => mm[0].Xtot (4400)
     add-goal [100] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [101] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [102] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [103] [CONN] input.V[2].O => mm[0].Ytot (6800)
     add-goal [104] [CONN] mm[0].X => output.V[0].X (S)
     add-goal [105] [CONN] mm[0].Y => output.V[1].X (E)
     add-goal [106] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[101] [CONN] input.I[0].O => mm[0].kf (0.0001)
[105] [CONN] mm[0].Y => output.V[1].X (E)
[100] [CONN] input.V[1].O => mm[0].XY0 (0)
[99] [CONN] input.V[0].O => mm[0].Xtot (4400)
[102] [CONN] input.I[1].O => mm[0].kr (0.01)
[106] [CONN] mm[0].XY => output.V[2].X (ES)
[103] [CONN] input.V[2].O => mm[0].Ytot (6800)
[104] [CONN] mm[0].X => output.V[0].X (S)

============
>> Current Goal: [104] [CONN] mm[0].X => output.V[0].X (S)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=35

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~40 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Xtot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Ytot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].X = S
[multi]    - making an output block.
[multi] > mm[0].Y = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Xtot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Ytot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [107] [CONN] input.V[0].O => mm[0].Xtot (4400)
     add-goal [108] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [109] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [110] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [111] [CONN] input.V[2].O => mm[0].Ytot (6800)
     add-goal [112] [CONN] mm[0].X => output.V[0].X (S)
     add-goal [113] [CONN] mm[0].Y => output.V[1].X (E)
     add-goal [114] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[107] [CONN] input.V[0].O => mm[0].Xtot (4400)
[112] [CONN] mm[0].X => output.V[0].X (S)
[113] [CONN] mm[0].Y => output.V[1].X (E)
[109] [CONN] input.I[0].O => mm[0].kf (0.0001)
[111] [CONN] input.V[2].O => mm[0].Ytot (6800)
[114] [CONN] mm[0].XY => output.V[2].X (ES)
[110] [CONN] input.I[1].O => mm[0].kr (0.01)
[108] [CONN] input.V[1].O => mm[0].XY0 (0)

============
>> Current Goal: [108] [CONN] input.V[1].O => mm[0].XY0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=36

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~52 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Xtot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Ytot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].X = S
[multi]    - making an output block.
[multi] > mm[0].Y = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Xtot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Ytot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [115] [CONN] input.V[0].O => mm[0].Xtot (4400)
     add-goal [116] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [117] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [118] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [119] [CONN] input.V[2].O => mm[0].Ytot (6800)
     add-goal [120] [CONN] mm[0].X => output.V[0].X (S)
     add-goal [121] [CONN] mm[0].Y => output.V[1].X (E)
     add-goal [122] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[121] [CONN] mm[0].Y => output.V[1].X (E)
[115] [CONN] input.V[0].O => mm[0].Xtot (4400)
[116] [CONN] input.V[1].O => mm[0].XY0 (0)
[122] [CONN] mm[0].XY => output.V[2].X (ES)
[119] [CONN] input.V[2].O => mm[0].Ytot (6800)
[117] [CONN] input.I[0].O => mm[0].kf (0.0001)
[120] [CONN] mm[0].X => output.V[0].X (S)
[118] [CONN] input.I[1].O => mm[0].kr (0.01)

============
>> Current Goal: [118] [CONN] input.I[1].O => mm[0].kr (0.01)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=37

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~49 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [123] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [124] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [125] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [126] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [127] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [128] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [129] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [130] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[125] [CONN] input.I[0].O => mm[0].kf (0.0001)
[127] [CONN] input.V[2].O => mm[0].Xtot (6800)
[126] [CONN] input.I[1].O => mm[0].kr (0.01)
[123] [CONN] input.V[0].O => mm[0].Ytot (4400)
[128] [CONN] mm[0].Y => output.V[0].X (S)
[130] [CONN] mm[0].XY => output.V[2].X (ES)
[124] [CONN] input.V[1].O => mm[0].XY0 (0)
[129] [CONN] mm[0].X => output.V[1].X (E)

============
>> Current Goal: [129] [CONN] mm[0].X => output.V[1].X (E)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=38

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~44 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [131] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [132] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [133] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [134] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [135] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [136] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [137] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [138] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[135] [CONN] input.V[2].O => mm[0].Xtot (6800)
[136] [CONN] mm[0].Y => output.V[0].X (S)
[138] [CONN] mm[0].XY => output.V[2].X (ES)
[133] [CONN] input.I[0].O => mm[0].kf (0.0001)
[137] [CONN] mm[0].X => output.V[1].X (E)
[131] [CONN] input.V[0].O => mm[0].Ytot (4400)
[134] [CONN] input.I[1].O => mm[0].kr (0.01)
[132] [CONN] input.V[1].O => mm[0].XY0 (0)

============
>> Current Goal: [132] [CONN] input.V[1].O => mm[0].XY0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=39

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~55 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [139] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [140] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [141] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [142] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [143] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [144] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [145] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [146] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[139] [CONN] input.V[0].O => mm[0].Ytot (4400)
[146] [CONN] mm[0].XY => output.V[2].X (ES)
[141] [CONN] input.I[0].O => mm[0].kf (0.0001)
[142] [CONN] input.I[1].O => mm[0].kr (0.01)
[144] [CONN] mm[0].Y => output.V[0].X (S)
[145] [CONN] mm[0].X => output.V[1].X (E)
[140] [CONN] input.V[1].O => mm[0].XY0 (0)
[143] [CONN] input.V[2].O => mm[0].Xtot (6800)

============
>> Current Goal: [143] [CONN] input.V[2].O => mm[0].Xtot (6800)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=40

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~62 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in kr=0.01
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kr = 0.01
   [sln] route mm[0].kf = 0.0001
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Xtot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Ytot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].X = S
[multi]    - making an output block.
[multi] > mm[0].Y = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in kr=0.01
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kr = 0.01
   [sln] route mm[0].kf = 0.0001
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Xtot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Ytot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [147] [CONN] input.V[0].O => mm[0].Xtot (4400)
     add-goal [148] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [149] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [150] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [151] [CONN] input.V[2].O => mm[0].Ytot (6800)
     add-goal [152] [CONN] mm[0].X => output.V[0].X (S)
     add-goal [153] [CONN] mm[0].Y => output.V[1].X (E)
     add-goal [154] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[147] [CONN] input.V[0].O => mm[0].Xtot (4400)
[152] [CONN] mm[0].X => output.V[0].X (S)
[153] [CONN] mm[0].Y => output.V[1].X (E)
[151] [CONN] input.V[2].O => mm[0].Ytot (6800)
[149] [CONN] input.I[0].O => mm[0].kf (0.0001)
[154] [CONN] mm[0].XY => output.V[2].X (ES)
[150] [CONN] input.I[1].O => mm[0].kr (0.01)
[148] [CONN] input.V[1].O => mm[0].XY0 (0)

============
>> Current Goal: [148] [CONN] input.V[1].O => mm[0].XY0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=41

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~60 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [155] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [156] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [157] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [158] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [159] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [160] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [161] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [162] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[160] [CONN] mm[0].Y => output.V[0].X (S)
[158] [CONN] input.I[1].O => mm[0].kr (0.01)
[157] [CONN] input.I[0].O => mm[0].kf (0.0001)
[156] [CONN] input.V[1].O => mm[0].XY0 (0)
[155] [CONN] input.V[0].O => mm[0].Ytot (4400)
[161] [CONN] mm[0].X => output.V[1].X (E)
[162] [CONN] mm[0].XY => output.V[2].X (ES)
[159] [CONN] input.V[2].O => mm[0].Xtot (6800)

============
>> Current Goal: [159] [CONN] input.V[2].O => mm[0].Xtot (6800)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=42

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~59 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [163] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [164] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [165] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [166] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [167] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [168] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [169] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [170] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[169] [CONN] mm[0].X => output.V[1].X (E)
[168] [CONN] mm[0].Y => output.V[0].X (S)
[170] [CONN] mm[0].XY => output.V[2].X (ES)
[164] [CONN] input.V[1].O => mm[0].XY0 (0)
[167] [CONN] input.V[2].O => mm[0].Xtot (6800)
[165] [CONN] input.I[0].O => mm[0].kf (0.0001)
[163] [CONN] input.V[0].O => mm[0].Ytot (4400)
[166] [CONN] input.I[1].O => mm[0].kr (0.01)

============
>> Current Goal: [166] [CONN] input.I[1].O => mm[0].kr (0.01)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=43

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~57 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].X = S
   [sln] generate mm[0].Y = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Xtot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Ytot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].X = S
[multi]    - making an output block.
[multi] > mm[0].Y = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].X = S
   [sln] generate mm[0].Y = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Xtot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Ytot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [171] [CONN] input.V[0].O => mm[0].Xtot (4400)
     add-goal [172] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [173] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [174] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [175] [CONN] input.V[2].O => mm[0].Ytot (6800)
     add-goal [176] [CONN] mm[0].X => output.V[0].X (S)
     add-goal [177] [CONN] mm[0].Y => output.V[1].X (E)
     add-goal [178] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[174] [CONN] input.I[1].O => mm[0].kr (0.01)
[176] [CONN] mm[0].X => output.V[0].X (S)
[178] [CONN] mm[0].XY => output.V[2].X (ES)
[171] [CONN] input.V[0].O => mm[0].Xtot (4400)
[177] [CONN] mm[0].Y => output.V[1].X (E)
[175] [CONN] input.V[2].O => mm[0].Ytot (6800)
[172] [CONN] input.V[1].O => mm[0].XY0 (0)
[173] [CONN] input.I[0].O => mm[0].kf (0.0001)

============
>> Current Goal: [173] [CONN] input.I[0].O => mm[0].kf (0.0001)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=44

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~41 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Xtot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Ytot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].X = S
[multi]    - making an output block.
[multi] > mm[0].Y = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Xtot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Ytot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [179] [CONN] input.V[0].O => mm[0].Xtot (4400)
     add-goal [180] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [181] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [182] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [183] [CONN] input.V[2].O => mm[0].Ytot (6800)
     add-goal [184] [CONN] mm[0].X => output.V[0].X (S)
     add-goal [185] [CONN] mm[0].Y => output.V[1].X (E)
     add-goal [186] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[179] [CONN] input.V[0].O => mm[0].Xtot (4400)
[186] [CONN] mm[0].XY => output.V[2].X (ES)
[183] [CONN] input.V[2].O => mm[0].Ytot (6800)
[180] [CONN] input.V[1].O => mm[0].XY0 (0)
[181] [CONN] input.I[0].O => mm[0].kf (0.0001)
[185] [CONN] mm[0].Y => output.V[1].X (E)
[184] [CONN] mm[0].X => output.V[0].X (S)
[182] [CONN] input.I[1].O => mm[0].kr (0.01)

============
>> Current Goal: [182] [CONN] input.I[1].O => mm[0].kr (0.01)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=45

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~61 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [187] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [188] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [189] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [190] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [191] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [192] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [193] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [194] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[192] [CONN] mm[0].Y => output.V[0].X (S)
[194] [CONN] mm[0].XY => output.V[2].X (ES)
[187] [CONN] input.V[0].O => mm[0].Ytot (4400)
[190] [CONN] input.I[1].O => mm[0].kr (0.01)
[189] [CONN] input.I[0].O => mm[0].kf (0.0001)
[193] [CONN] mm[0].X => output.V[1].X (E)
[188] [CONN] input.V[1].O => mm[0].XY0 (0)
[191] [CONN] input.V[2].O => mm[0].Xtot (6800)

============
>> Current Goal: [191] [CONN] input.V[2].O => mm[0].Xtot (6800)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=46

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~56 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Xtot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Ytot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].X = S
[multi]    - making an output block.
[multi] > mm[0].Y = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Xtot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Ytot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [195] [CONN] input.V[0].O => mm[0].Xtot (4400)
     add-goal [196] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [197] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [198] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [199] [CONN] input.V[2].O => mm[0].Ytot (6800)
     add-goal [200] [CONN] mm[0].X => output.V[0].X (S)
     add-goal [201] [CONN] mm[0].Y => output.V[1].X (E)
     add-goal [202] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[195] [CONN] input.V[0].O => mm[0].Xtot (4400)
[201] [CONN] mm[0].Y => output.V[1].X (E)
[202] [CONN] mm[0].XY => output.V[2].X (ES)
[198] [CONN] input.I[1].O => mm[0].kr (0.01)
[197] [CONN] input.I[0].O => mm[0].kf (0.0001)
[196] [CONN] input.V[1].O => mm[0].XY0 (0)
[200] [CONN] mm[0].X => output.V[0].X (S)
[199] [CONN] input.V[2].O => mm[0].Ytot (6800)

============
>> Current Goal: [199] [CONN] input.V[2].O => mm[0].Ytot (6800)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=47

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~42 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].X = E
   [sln] generate mm[0].Y = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].X = E
   [sln] generate mm[0].Y = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [203] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [204] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [205] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [206] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [207] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [208] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [209] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [210] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[203] [CONN] input.V[0].O => mm[0].Ytot (4400)
[204] [CONN] input.V[1].O => mm[0].XY0 (0)
[205] [CONN] input.I[0].O => mm[0].kf (0.0001)
[207] [CONN] input.V[2].O => mm[0].Xtot (6800)
[209] [CONN] mm[0].X => output.V[1].X (E)
[206] [CONN] input.I[1].O => mm[0].kr (0.01)
[208] [CONN] mm[0].Y => output.V[0].X (S)
[210] [CONN] mm[0].XY => output.V[2].X (ES)

============
>> Current Goal: [210] [CONN] mm[0].XY => output.V[2].X (ES)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=48

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~58 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].X = E
   [sln] generate mm[0].Y = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].X = E
   [sln] generate mm[0].Y = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [211] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [212] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [213] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [214] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [215] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [216] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [217] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [218] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[211] [CONN] input.V[0].O => mm[0].Ytot (4400)
[216] [CONN] mm[0].Y => output.V[0].X (S)
[212] [CONN] input.V[1].O => mm[0].XY0 (0)
[214] [CONN] input.I[1].O => mm[0].kr (0.01)
[217] [CONN] mm[0].X => output.V[1].X (E)
[213] [CONN] input.I[0].O => mm[0].kf (0.0001)
[218] [CONN] mm[0].XY => output.V[2].X (ES)
[215] [CONN] input.V[2].O => mm[0].Xtot (6800)

============
>> Current Goal: [215] [CONN] input.V[2].O => mm[0].Xtot (6800)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=49

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~46 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [219] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [220] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [221] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [222] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [223] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [224] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [225] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [226] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[220] [CONN] input.V[1].O => mm[0].XY0 (0)
[225] [CONN] mm[0].X => output.V[1].X (E)
[224] [CONN] mm[0].Y => output.V[0].X (S)
[221] [CONN] input.I[0].O => mm[0].kf (0.0001)
[223] [CONN] input.V[2].O => mm[0].Xtot (6800)
[219] [CONN] input.V[0].O => mm[0].Ytot (4400)
[226] [CONN] mm[0].XY => output.V[2].X (ES)
[222] [CONN] input.I[1].O => mm[0].kr (0.01)

============
>> Current Goal: [222] [CONN] input.I[1].O => mm[0].kr (0.01)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=50

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~63 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [227] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [228] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [229] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [230] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [231] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [232] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [233] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [234] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[229] [CONN] input.I[0].O => mm[0].kf (0.0001)
[232] [CONN] mm[0].Y => output.V[0].X (S)
[233] [CONN] mm[0].X => output.V[1].X (E)
[231] [CONN] input.V[2].O => mm[0].Xtot (6800)
[230] [CONN] input.I[1].O => mm[0].kr (0.01)
[228] [CONN] input.V[1].O => mm[0].XY0 (0)
[227] [CONN] input.V[0].O => mm[0].Ytot (4400)
[234] [CONN] mm[0].XY => output.V[2].X (ES)

============
>> Current Goal: [234] [CONN] mm[0].XY => output.V[2].X (ES)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=51

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~51 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in kr=0.01
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kr = 0.01
   [sln] route mm[0].kf = 0.0001
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Xtot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Ytot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].X = S
[multi]    - making an output block.
[multi] > mm[0].Y = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=4400
   [comp] mm[0] cfg-in Ytot=6800
   [comp] mm[0] cfg-in kr=0.01
   [comp] mm[0] cfg-in Y=E
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in X=S
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = E
   [sln] generate mm[0].X = S
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 4400
   [sln] route mm[0].Ytot = 6800
   [sln] route mm[0].kr = 0.01
   [sln] route mm[0].kf = 0.0001
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Xtot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Ytot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [235] [CONN] input.V[0].O => mm[0].Xtot (4400)
     add-goal [236] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [237] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [238] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [239] [CONN] input.V[2].O => mm[0].Ytot (6800)
     add-goal [240] [CONN] mm[0].X => output.V[0].X (S)
     add-goal [241] [CONN] mm[0].Y => output.V[1].X (E)
     add-goal [242] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[235] [CONN] input.V[0].O => mm[0].Xtot (4400)
[238] [CONN] input.I[1].O => mm[0].kr (0.01)
[241] [CONN] mm[0].Y => output.V[1].X (E)
[237] [CONN] input.I[0].O => mm[0].kf (0.0001)
[242] [CONN] mm[0].XY => output.V[2].X (ES)
[236] [CONN] input.V[1].O => mm[0].XY0 (0)
[240] [CONN] mm[0].X => output.V[0].X (S)
[239] [CONN] input.V[2].O => mm[0].Ytot (6800)

============
>> Current Goal: [239] [CONN] input.V[2].O => mm[0].Ytot (6800)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=52

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~48 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ==== ROUTES =====
[multi] > mm[0].Ytot = 4400
[multi]    - making an input block.
[multi] > mm[0].XY0 = 0
[multi]    - making an input block.
[multi] > mm[0].kf = 0.0001
[multi]    - making an input block.
[multi] > mm[0].kr = 0.01
[multi]    - making an input block.
[multi] > mm[0].Xtot = 6800
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[0].Y = S
[multi]    - making an output block.
[multi] > mm[0].X = E
[multi]    - making an output block.
[multi] > mm[0].XY = ES
[multi]    - making an output block.
[multi] --> Number of options 8
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   remove-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   [comp] mm[0] cfg-in XY0=0
   [comp] mm[0] cfg-in XY=ES
   [comp] mm[0] cfg-in Xtot=6800
   [comp] mm[0] cfg-in Ytot=4400
   [comp] mm[0] cfg-in kf=0.0001
   [comp] mm[0] cfg-in Y=S
   [comp] mm[0] cfg-in X=E
   [comp] mm[0] cfg-in kr=0.01
   [sln] generate mm[0].XY = ES
   [sln] generate mm[0].Y = S
   [sln] generate mm[0].X = E
   [sln] add-comp mm[0]
   [sln] route mm[0].XY0 = 0
   [sln] route mm[0].Xtot = 6800
   [sln] route mm[0].Ytot = 4400
   [sln] route mm[0].kf = 0.0001
   [sln] route mm[0].kr = 0.01
   [comp] make-comp mm0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   add-goal [0] [MATH]output S :> S=(STOT-ES) / std(S) = none 0 {[S]=[0.,4400.]}
   add-goal [1] [MATH]output E :> E=(ETOT-ES) / std(E) = none 0 {[E]=[0.,6800.]}
   add-goal [2] [MATH]output ES :> ddt ES=((kf*E*S)-(kr*ES)) ic=0 / std(ddt ES) = gauss (ES*0.01) {[ddt ES]=[-44.,2992.] / [ES]=[0.,4400.] / max-sample = <none>min-speed = <none>}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=4400
     [comp] input.V[0] cfg-out O=4400
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=0.0001
     [comp] input.I[0] cfg-out O=0.0001
     [comp] input.I[1] cfg-in X=0.01
     [comp] input.I[1] cfg-out O=0.01
     [comp] input.V[2] cfg-in X=6800
     [comp] input.V[2] cfg-out O=6800
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route mm[0].Ytot = 4400
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 4400
     [sln] rm-route mm[0].XY0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route mm[0].kf = 0.0001
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 0.0001
     [sln] rm-route mm[0].kr = 0.01
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0.01
     [sln] rm-route mm[0].Xtot = 6800
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 6800
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.V[0].X = 4400
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 0.0001
     [sln] route input.I[1].X = 0.01
     [sln] route input.V[2].X = 6800
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [243] [CONN] input.V[0].O => mm[0].Ytot (4400)
     add-goal [244] [CONN] input.V[1].O => mm[0].XY0 (0)
     add-goal [245] [CONN] input.I[0].O => mm[0].kf (0.0001)
     add-goal [246] [CONN] input.I[1].O => mm[0].kr (0.01)
     add-goal [247] [CONN] input.V[2].O => mm[0].Xtot (6800)
     add-goal [248] [CONN] mm[0].Y => output.V[0].X (S)
     add-goal [249] [CONN] mm[0].X => output.V[1].X (E)
     add-goal [250] [CONN] mm[0].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[246] [CONN] input.I[1].O => mm[0].kr (0.01)
[247] [CONN] input.V[2].O => mm[0].Xtot (6800)
[243] [CONN] input.V[0].O => mm[0].Ytot (4400)
[245] [CONN] input.I[0].O => mm[0].kf (0.0001)
[248] [CONN] mm[0].Y => output.V[0].X (S)
[244] [CONN] input.V[1].O => mm[0].XY0 (0)
[250] [CONN] mm[0].XY => output.V[2].X (ES)
[249] [CONN] mm[0].X => output.V[1].X (E)

============
>> Current Goal: [249] [CONN] mm[0].X => output.V[1].X (E)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Ytot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.Xtot
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=53

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~43 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi] [search_tree] is exhausted
[multi] # Found 2, Required: 1
[multi] [DONE] found enough solutions
[multi] ===== Getting Solutions =====
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~45 :: 3
[multi] => Global Solution: ES~54 :: 3
