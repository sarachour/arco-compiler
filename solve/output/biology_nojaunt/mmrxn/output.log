==== Loaded Config File (benchmarks/biology_nojaunt/configs/prod.cfg) ====
bool enable-jaunt false
int multi-num-global-solutions 1
bool eqn-use-map-heuristic true
int slvr-solutions 1
string multi-selector-branch solved-and-ncomps
int multi-num-global-solutions-per-partial 1
int slvr-partial-depth 15
int interactive 0
int eqn-unifications 12
int multi-num-partial-solutions 1
int map-infer-feasible-timeout 60
int slvr-global-depth 30
int debug 2
string eqn-selector-goal trivial
int z3-minimize-depth 4
int uast-depth 5
string uast-selector-branch uniform
bool _force false
string z3-minimize-strategy binary
string eqn-selector-branch goals
=================================
======== Infer Math Vars =============
derive: P -> [0.,0.0294]
derive: ES -> [-0.3535,0.132468]
inference hw vars
-> derived [0.,5000.] -> P
-> derived [0.,10.] -> PROD
-> derived [0.,3300.] -> Y
-> derived [0.,10.] -> REP2
-> derived [0.,1.] -> Y
-> derived [0.,80000.] -> REP
-> derived [0.,1000000.] -> STIM
-> derived [0.,10.] -> Y
-> derived {[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } -> OUT
-> derived [0.,10.] -> Y
-> derived [-5.,10.] -> OUT
-> derived [0.,10.] -> GE
==== Units ====
==== Vars =====
> MAKE vgain
input(<vgain,X>)
cover
input(<vgain,Z>)
cover
output(<vgain,P>)
cover
>
>
offset(<vgain,X>)=0
offset(<vgain,Z>)=0
ve(scale(<vgain,P>)=scale(<vgain,X>)*scale(<vgain,Z>))
offset(<vgain,P>)=0
>>> # Partitions vgain=3
> MAKE switch
input(<switch,n>)
cover
input(<switch,SUB>)
cover
input(<switch,Kmod>)
cover
input(<switch,Vmax>)
cover
output(<switch,PROD>)
cover
>
>
offset(<switch,SUB>)=0
offset(<switch,Kmod>)=0
ee(scale(<switch,Kmod>)^-1*scale(<switch,SUB>)=scale(<switch,Kmod>)^-1*scale(<switch,SUB>))
ee(1=scale(<switch,Kmod>)^-1*scale(<switch,SUB>))
ee(scale(<switch,Kmod>)^-1*scale(<switch,SUB>)=1)
ee(1=1)
>
offset(<switch,n>)=0
valid
ec(0+0=0)
valid
ec(scale(<switch,n>)/1=1)
valid
valid
>
offset(<switch,Vmax>)=0
valid
ve(scale(<switch,PROD>)=1/1^(switch.V{n}:/500.)*scale(<switch,Vmax>))
offset(<switch,PROD>)=0
>>> # Partitions switch=4
> MAKE ihill_stim
input(<ihill_stim,n>)
cover
input(<ihill_stim,S>)
cover
input(<ihill_stim,Km>)
cover
input(<ihill_stim,Vmax>)
cover
output(<ihill_stim,STIM>)
cover
>
>
offset(<ihill_stim,S>)=0
offset(<ihill_stim,Km>)=0
>
valid
offset(<ihill_stim,n>)=0
scale(<ihill_stim,n>)=1
>
>
offset(<ihill_stim,S>)=0
offset(<ihill_stim,Km>)=0
>
valid
offset(<ihill_stim,n>)=0
scale(<ihill_stim,n>)=1
ee(scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:=scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:)
ee(1=scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:)
ee(scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:=1)
ee(1=1)
valid
ec(0+0=0)
>
ve(scale(<ihill_stim,STIM>)=scale(<ihill_stim,Vmax>)*scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:/1)
offset(<ihill_stim,STIM>)=0
>>> # Partitions ihill_stim=4
> MAKE ihill_rep
input(<ihill_rep,n>)
cover
input(<ihill_rep,S>)
cover
input(<ihill_rep,Km>)
cover
input(<ihill_rep,Vmax>)
cover
output(<ihill_rep,REP>)
cover
>
>
offset(<ihill_rep,Km>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
>
>
offset(<ihill_rep,S>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
>
>
offset(<ihill_rep,Km>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
ee(scale(<ihill_rep,Km>)^ihill_rep.V{n}:=scale(<ihill_rep,Km>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,S>)^ihill_rep.V{n}:=scale(<ihill_rep,Km>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,Km>)^ihill_rep.V{n}:=scale(<ihill_rep,S>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,S>)^ihill_rep.V{n}:=scale(<ihill_rep,S>)^ihill_rep.V{n}:)
valid
ec(0+0=0)
>
offset(<ihill_rep,Vmax>)=0
valid
ve(scale(<ihill_rep,REP>)=scale(<ihill_rep,Km>)^ihill_rep.V{n}:/scale(<ihill_rep,S>)^ihill_rep.V{n}:*scale(<ihill_rep,Vmax>))
offset(<ihill_rep,REP>)=0
>>> # Partitions ihill_rep=4
> MAKE vdadd
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
valid
offset(<vdadd,D>)=0
offset(<vdadd,OUT>)=0
>
valid
offset(<vdadd,B>)=0
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=2
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
valid
offset(<vdadd,D>)=0
offset(<vdadd,OUT>)=0
>
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=3
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
>
valid
offset(<vdadd,B>)=0
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=3
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
>
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=4
> MAKE ihill_rep2
input(<ihill_rep2,n>)
cover
input(<ihill_rep2,S>)
cover
input(<ihill_rep2,Vmax>)
cover
output(<ihill_rep2,REP2>)
cover
>
>
offset(<ihill_rep2,S>)=0
offset(<ihill_rep2,n>)=0
scale(<ihill_rep2,n>)=1
ee(scale(<ihill_rep2,S>)^ihill_rep2.V{n}:=scale(<ihill_rep2,S>)^ihill_rep2.V{n}:)
ee(1=scale(<ihill_rep2,S>)^ihill_rep2.V{n}:)
ee(scale(<ihill_rep2,S>)^ihill_rep2.V{n}:=1)
ee(1=1)
valid
ec(0+0=0)
>
offset(<ihill_rep2,Vmax>)=0
valid
vv(scale(<ihill_rep2,REP2>)=scale(<ihill_rep2,Vmax>))
offset(<ihill_rep2,REP2>)=0
>>> # Partitions ihill_rep2=2
> MAKE input.I
input(<input.I,X>)
cover
output(<input.I,O>)
cover
>
vv(scale(<input.I,O>)=scale(<input.I,X>))
vv(offset(<input.I,O>)=offset(<input.I,X>))
>>> # Partitions input.I=2
> MAKE output.V
input(<output.V,X>)
cover
output(<output.V,O>)
cover
>
vv(scale(<output.V,O>)=scale(<output.V,X>))
vv(offset(<output.V,O>)=offset(<output.V,X>))
>>> # Partitions output.V=2
> MAKE copy.V
input(<copy.V,X>)
cover
output(<copy.V,Y>)
cover
>
vv(scale(<copy.V,Y>)=scale(<copy.V,X>))
vv(offset(<copy.V,Y>)=offset(<copy.V,X>))
>>> # Partitions copy.V=2
> MAKE vadd
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
valid
offset(<vadd,C>)=0
>
valid
offset(<vadd,B>)=0
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=3
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
valid
offset(<vadd,C>)=0
>
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=4
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
>
valid
offset(<vadd,B>)=0
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=4
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
>
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=5
> MAKE vtoi
input(<vtoi,X>)
cover
input(<vtoi,K>)
cover
output(<vtoi,Y>)
cover
>
>
valid
offset(<vtoi,K>)=0
valid
offset(<vtoi,X>)=0
ve(scale(<vtoi,Y>)=scale(<vtoi,K>)^-1*scale(<vtoi,X>))
offset(<vtoi,Y>)=0
>>> # Partitions vtoi=3
> MAKE igenebind
input(<igenebind,TF>)
cover
input(<igenebind,K>)
cover
input(<igenebind,Vmax>)
cover
output(<igenebind,GE>)
cover
>
>
offset(<igenebind,K>)=0
offset(<igenebind,TF>)=0
ee(1=1)
ee(scale(<igenebind,K>)*scale(<igenebind,TF>)=1)
ee(1=scale(<igenebind,K>)*scale(<igenebind,TF>))
ee(scale(<igenebind,K>)*scale(<igenebind,TF>)=scale(<igenebind,K>)*scale(<igenebind,TF>))
valid
ec(0+0=0)
>
offset(<igenebind,Vmax>)=0
valid
ve(scale(<igenebind,GE>)=scale(<igenebind,K>)^-1*scale(<igenebind,TF>)^-1*scale(<igenebind,Vmax>))
offset(<igenebind,GE>)=0
>>> # Partitions igenebind=4
> MAKE mm
input(<mm,kr>)
cover
input(<mm,XY0>)
cover
input(<mm,Ytot>)
cover
input(<mm,kf>)
cover
input(<mm,Xtot>)
cover
output(<mm,X>)
cover
output(<mm,XY>)
cover
XY
output(<mm,Y>)
cover
>
>
vv(scale(<mm,Xtot>)=scale(<mm,Xtot>))
vv(scale(<mm,XY>)=scale(<mm,Xtot>))
vv(scale(<mm,Xtot>)=scale(<mm,XY>))
vv(scale(<mm,XY>)=scale(<mm,XY>))
vv(scale(<mm,X>)=scale(<mm,Xtot>))
ve(offset(<mm,X>)=offset(<mm,XY>)+offset(<mm,Xtot>))
>
>
offset(<mm,kr>)=0
offset(<mm,XY>)=0
>
>
>
offset(<mm,kf>)=0
offset(<mm,X>)=0
offset(<mm,Y>)=0
ee(scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>)=scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>))
ee(scale(<mm,XY>)*scale(<mm,kr>)=scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>))
ee(scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>)=scale(<mm,XY>)*scale(<mm,kr>))
ee(scale(<mm,XY>)*scale(<mm,kr>)=scale(<mm,XY>)*scale(<mm,kr>))
ve(scale(<mm,XY>)=scale(<mm,XY>)*scale(<mm,kr>))
offset(<mm,XY>)=0
=
priority
offset(<mm,XY>)=0
vv(scale(<mm,XY>)=scale(<mm,XY0>))
vv(offset(<mm,XY>)=offset(<mm,XY0>))
>
>
vv(scale(<mm,Ytot>)=scale(<mm,Ytot>))
vv(scale(<mm,XY>)=scale(<mm,Ytot>))
vv(scale(<mm,Ytot>)=scale(<mm,XY>))
vv(scale(<mm,XY>)=scale(<mm,XY>))
vv(scale(<mm,Y>)=scale(<mm,Ytot>))
ve(offset(<mm,Y>)=offset(<mm,XY>)+offset(<mm,Ytot>))
>>> # Partitions mm=4
> MAKE input.V
input(<input.V,X>)
cover
output(<input.V,O>)
cover
>
vv(scale(<input.V,O>)=scale(<input.V,X>))
vv(offset(<input.V,O>)=offset(<input.V,X>))
>>> # Partitions input.V=2
> MAKE itov
input(<itov,X>)
cover
input(<itov,K>)
cover
output(<itov,Y>)
cover
>
>
offset(<itov,K>)=0
offset(<itov,X>)=0
ve(scale(<itov,Y>)=scale(<itov,K>)*scale(<itov,X>))
offset(<itov,Y>)=0
>>> # Partitions itov=3
> MAKE iadd
input(<iadd,C>)
cover
input(<iadd,A>)
cover
input(<iadd,B>)
cover
output(<iadd,OUT>)
cover
>
>
>
vv(scale(<iadd,A>)=scale(<iadd,A>))
vv(scale(<iadd,B>)=scale(<iadd,A>))
vv(scale(<iadd,A>)=scale(<iadd,B>))
vv(scale(<iadd,B>)=scale(<iadd,B>))
vv(scale(<iadd,A>)=scale(<iadd,A>))
vv(scale(<iadd,C>)=scale(<iadd,A>))
vv(scale(<iadd,A>)=scale(<iadd,C>))
vv(scale(<iadd,C>)=scale(<iadd,C>))
vv(scale(<iadd,OUT>)=scale(<iadd,A>))
ve(offset(<iadd,OUT>)=offset(<iadd,A>)+offset(<iadd,B>)+offset(<iadd,C>))
>>> # Partitions iadd=5
> MAKE output.I
input(<output.I,X>)
cover
output(<output.I,O>)
cover
>
vv(scale(<output.I,O>)=scale(<output.I,X>))
vv(offset(<output.I,O>)=offset(<output.I,X>))
>>> # Partitions output.I=2
> MAKE copy.I
input(<copy.I,X>)
cover
output(<copy.I,Y>)
cover
>
vv(scale(<copy.I,Y>)=scale(<copy.I,X>))
vv(offset(<copy.I,Y>)=offset(<copy.I,X>))
>>> # Partitions copy.I=2
=== mm ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<mm,Ytot>)

v(0) = exprs=v(0)+v(2)=v(0)+v(1)
cstrs==
value=0
mems=offset(<mm,XY0>),offset(<mm,Y>),offset(<mm,kf>),offset(<mm,XY>),offset(<mm,kr>),offset(<mm,X>)

v(3) = exprs=v(3)*v(3)*v(3)=v(3)*v(3)
cstrs=>
value=<none>
mems=scale(<mm,Ytot>),scale(<mm,Y>),scale(<mm,XY>),scale(<mm,XY0>),scale(<mm,kr>),scale(<mm,kf>),scale(<mm,Xtot>),scale(<mm,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<mm,Xtot>)


kr = string_of_map_port: unimpl
XY0 = string_of_map_port: unimpl
Ytot = string_of_map_port: unimpl
Xtot = string_of_map_port: unimpl
kf = string_of_map_port: unimpl

X = string_of_map_port: unimpl
XY = string_of_map_port: unimpl
Y = string_of_map_port: unimpl



=== vgain ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=0
mems=offset(<vgain,P>),offset(<vgain,Z>),offset(<vgain,X>)

v(0) = exprs=v(1)*v(1)
cstrs=
value=<none>
mems=scale(<vgain,P>)

v(1) = exprs=
cstrs=>
value=<none>
mems=scale(<vgain,Z>),scale(<vgain,X>)


X = string_of_map_port: unimpl
Z = string_of_map_port: unimpl

P = string_of_map_port: unimpl



=== vdadd ===
 = 
 = ====== #2 ======
v(2) = exprs=
cstrs==
value=0
mems=offset(<vdadd,D>),offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>)

v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,B>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,B>)

v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(3) = exprs=
cstrs==
value=0
mems=offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,D>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #3 ======
v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs==
value=0
mems=offset(<vdadd,D>),offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>),offset(<vdadd,B>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #1 ======
v(2) = exprs=
cstrs==
value=0
mems=offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>),offset(<vdadd,B>)

v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,D>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== switch ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=>
value=<none>
mems=scale(<switch,n>),scale(<switch,Vmax>),scale(<switch,Kmod>),scale(<switch,SUB>)

v(0) = exprs=v(2)/1=v(2)^-1*v(2)
cstrs=
value=1
mems=

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<switch,SUB>),offset(<switch,n>),offset(<switch,Kmod>),offset(<switch,PROD>),offset(<switch,Vmax>)

v(1) = exprs=1/1^(switch.V{n}:/500.)*v(2)
cstrs=
value=<none>
mems=scale(<switch,PROD>)


SUB = string_of_map_port: unimpl
n = string_of_map_port: unimpl
Kmod = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

PROD = string_of_map_port: unimpl



=== itov ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=0
mems=offset(<itov,K>),offset(<itov,X>),offset(<itov,Y>)

v(0) = exprs=v(1)*v(1)
cstrs=
value=<none>
mems=scale(<itov,Y>)

v(1) = exprs=
cstrs=>
value=<none>
mems=scale(<itov,K>),scale(<itov,X>)


X = string_of_map_port: unimpl
K = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== output.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<output.I,O>),scale(<output.I,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<output.I,X>),offset(<output.I,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== input.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<input.V,X>),scale(<input.V,O>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<input.V,X>),offset(<input.V,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== output.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<output.V,X>),scale(<output.V,O>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<output.V,O>),offset(<output.V,X>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== ihill_rep2 ===
 = 
 = ====== #0 ======
v(0) = exprs=v(0)^ihill_rep2.V{n}:=1
cstrs=>
value=<none>
mems=scale(<ihill_rep2,n>),scale(<ihill_rep2,REP2>),scale(<ihill_rep2,Vmax>),scale(<ihill_rep2,S>)

v(1) = exprs=0+0
cstrs=
value=0
mems=offset(<ihill_rep2,Vmax>),offset(<ihill_rep2,S>),offset(<ihill_rep2,REP2>),offset(<ihill_rep2,n>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

REP2 = string_of_map_port: unimpl



=== copy.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<copy.V,Y>),scale(<copy.V,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<copy.V,X>),offset(<copy.V,Y>)


X = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== ihill_rep ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=>
value=1
mems=scale(<ihill_rep,Km>),scale(<ihill_rep,S>),scale(<ihill_rep,n>),scale(<ihill_rep,Vmax>)

v(0) = exprs=v(2)^ihill_rep.V{n}:=v(2)^ihill_rep.V{n}:
cstrs=
value=<none>
mems=

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<ihill_rep,n>),offset(<ihill_rep,REP>),offset(<ihill_rep,Km>),offset(<ihill_rep,S>),offset(<ihill_rep,Vmax>)

v(1) = exprs=v(2)^ihill_rep.V{n}:/v(2)^ihill_rep.V{n}:*v(2)
cstrs=
value=<none>
mems=scale(<ihill_rep,REP>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Km = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

REP = string_of_map_port: unimpl



=== ihill_stim ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<ihill_stim,Vmax>)

v(0) = exprs=v(0)/v(0)^ihill_stim.V{n}:=1
cstrs=>
value=<none>
mems=scale(<ihill_stim,S>),scale(<ihill_stim,n>),scale(<ihill_stim,Vmax>),scale(<ihill_stim,Km>)

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<ihill_stim,STIM>),offset(<ihill_stim,n>),offset(<ihill_stim,S>),offset(<ihill_stim,Km>)

v(1) = exprs=v(0)*v(0)/v(0)^ihill_stim.V{n}:/1
cstrs=
value=<none>
mems=scale(<ihill_stim,STIM>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Km = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

STIM = string_of_map_port: unimpl



=== vtoi ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=0
mems=offset(<vtoi,X>),offset(<vtoi,Y>),offset(<vtoi,K>)

v(0) = exprs=v(1)^-1*v(1)
cstrs=
value=<none>
mems=scale(<vtoi,Y>)

v(1) = exprs=
cstrs=>
value=<none>
mems=scale(<vtoi,X>),scale(<vtoi,K>)


X = string_of_map_port: unimpl
K = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== vadd ===
 = 
 = ====== #2 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,B>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(3) = exprs=
cstrs=
value=0
mems=offset(<vadd,C>),offset(<vadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(3) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,B>)

v(4) = exprs=v(2)+0+0
cstrs=
value=0
mems=offset(<vadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,C>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #3 ======
v(2) = exprs=v(1)+0+0
cstrs=
value=0
mems=offset(<vadd,B>),offset(<vadd,C>),offset(<vadd,OUT>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #1 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(3) = exprs=v(2)+0+0
cstrs=
value=0
mems=offset(<vadd,B>),offset(<vadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,C>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== copy.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<copy.I,Y>),scale(<copy.I,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<copy.I,X>),offset(<copy.I,Y>)


X = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== iadd ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<iadd,A>)

v(0) = exprs=v(2)+v(1)+v(3)
cstrs=
value=<none>
mems=offset(<iadd,OUT>)

v(3) = exprs=
cstrs=
value=<none>
mems=offset(<iadd,C>)

v(4) = exprs=
cstrs=>
value=<none>
mems=scale(<iadd,OUT>),scale(<iadd,A>),scale(<iadd,B>),scale(<iadd,C>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<iadd,B>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== input.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<input.I,O>),scale(<input.I,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<input.I,X>),offset(<input.I,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== igenebind ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=>
value=<none>
mems=scale(<igenebind,TF>),scale(<igenebind,Vmax>),scale(<igenebind,K>)

v(0) = exprs=1=v(2)*v(2)
cstrs=
value=<none>
mems=

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<igenebind,GE>),offset(<igenebind,K>),offset(<igenebind,Vmax>),offset(<igenebind,TF>)

v(1) = exprs=v(2)^-1*v(2)^-1*v(2)
cstrs=
value=<none>
mems=scale(<igenebind,GE>)


TF = string_of_map_port: unimpl
K = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

GE = string_of_map_port: unimpl



[multi] # Found 0, Required: 1
[multi] solving target: ES
[multi] search tree is not exhausted. adding existing:ES
[multi] finding new partial solution
[multi] made a partial tree with 6 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
[5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
[5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}

============
>> Current Goal: [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
vdadd.OUT -> true
mm.XY -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  2 <<<
[eqn] new: [0] <vdadd> output OUT.V
<analog-st> ((vdadd.V{A}:+(vdadd.BSW*vdadd.V{B}:))-(vdadd.DSW*vdadd.I{D}:*vdadd.V{OUT}:)) ic=OUT_0.V / std=none 0
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,12000.] {v}->[v]=@ {v}->*[v]=@


checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
[eqn] new: [0] <mm> output XY.V
<analog-st> ((mm.I{kf}:*mm.V{X}:*mm.V{Y}:)-(mm.I{kr}:*mm.V{XY}:)) ic=XY0.V / std=gauss ((0.001*mm.V{XY}:)+0.1)
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,3200.] {v}->[v]=@ {v}->*[v]=@


checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[0].X to output block.
number reachable output blocks 1/15
checking reachability of mm[0].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[0].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
checking reachability of mm[1].X to output block.
number reachable output blocks 1/15
checking reachability of mm[1].Y to output block.
number reachable output blocks 1/15
checking reachability of mm[1].XY to output block.
number reachable output blocks 1/15
[eqn]     -> converted to 21 ssteps
[eqn] [FOUND-SOLS] ===> Found <33> solutions
[slvrsearch] > weight--: <mvar-goal>ES
[eqn] -> [valid?] testing node 67
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[121] [EXPR]mm[1].Xtot<V>=(Etot+(-1*P))
[120] [EXPR]mm[1].Ytot<V>=((-1*P)+Stot)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}

============
>> Current Goal: [120] [EXPR]mm[1].Ytot<V>=((-1*P)+Stot)
vgain.P -> true
mm.X -> true
mm.Y -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  3 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <mm> output Y.V
<analog>:(mm.V{Ytot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <mm> output X.V
<analog>:(mm.V{Xtot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: ((-1*P)+Stot)
[eqn] -> [valid?] testing node 73
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[127] [EXPR]vgain[1].Z<I>=((-1*P)+Stot)
[121] [EXPR]mm[1].Xtot<V>=(Etot+(-1*P))
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}

============
>> Current Goal: [121] [EXPR]mm[1].Xtot<V>=(Etot+(-1*P))
vgain.P -> true
mm.X -> true
mm.Y -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  3 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <mm> output Y.V
<analog>:(mm.V{Ytot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <mm> output X.V
<analog>:(mm.V{Xtot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: (Etot+(-1*P))
[eqn] -> [valid?] testing node 79
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[127] [EXPR]vgain[1].Z<I>=((-1*P)+Stot)
[133] [EXPR]vgain[3].Z<I>=(Etot+(-1*P))
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}

============
>> Current Goal: [133] [EXPR]vgain[3].Z<I>=(Etot+(-1*P))
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


checking reachability of iadd[0].A to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[0].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[0].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[0].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[0].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[0].A to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[0].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[1].A to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[1].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[1].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[1].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[1].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[1].A to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[1].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
[eqn] [FOUND-SOLS] ===> Found <12> solutions
[slvrsearch] > weight--: (Etot+(-1*P))
[eqn] -> [valid?] testing node 103
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[127] [EXPR]vgain[1].Z<I>=((-1*P)+Stot)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}

============
>> Current Goal: [127] [EXPR]vgain[1].Z<I>=((-1*P)+Stot)
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


checking reachability of iadd[2].A to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[2].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[2].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[2].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[2].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[2].A to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[2].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[3].A to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[3].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[3].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[3].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[3].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[3].A to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
checking reachability of iadd[3].B to an input block.
9number reachable input blocks 1/9
[eqn]     -> converted to 13 ssteps
[eqn] [FOUND-SOLS] ===> Found <12> solutions
[slvrsearch] > weight--: ((-1*P)+Stot)
[eqn] -> [valid?] testing node 127
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=0

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 115
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 127 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 80
[multi] # partial ids = 1
[multi]    remove-goal [127] [EXPR]vgain[2].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[1].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[1].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[3].Z<I>=(Etot+(-1*P))
   [comp] iadd[0] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[0] cfg-in A=0
   [comp] iadd[0] cfg-in B=Stot
   [comp] iadd[0] cfg-in C=P
   [comp] mm[1] cfg-in XY0=0
   [comp] mm[1] cfg-in XY=ES
   [comp] mm[1] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[1] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[1] cfg-in Y=S
   [comp] mm[1] cfg-in X=E
   [comp] mm[1] cfg-in kf=3.154
   [comp] mm[1] cfg-in kr=2.525
   [comp] vgain[2] cfg-in P=((-1*P)+Stot)
   [comp] vgain[2] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[2] cfg-in X=1
   [comp] vgain[3] cfg-in P=(Etot+(-1*P))
   [comp] vgain[3] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[3] cfg-in X=1
   [comp] iadd[4] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[4] cfg-in A=0
   [comp] iadd[4] cfg-in B=Etot
   [comp] iadd[4] cfg-in C=P
   [sln] generate iadd[0].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[0]
   [sln] generate iadd[0].OUT = ((-1*P)+Stot)
   [sln] conn iadd[0].OUT->vgain[2].Z
   [sln] generate mm[1].XY = ES
   [sln] generate mm[1].Y = S
   [sln] generate mm[1].X = E
   [sln] add-comp mm[1]
   [sln] generate vgain[2].P = ((-1*P)+Stot)
   [sln] add-comp vgain[2]
   [sln] generate vgain[2].P = ((-1*P)+Stot)
   [sln] conn vgain[2].P->mm[1].Ytot
   [sln] generate vgain[3].P = (Etot+(-1*P))
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (Etot+(-1*P))
   [sln] conn vgain[3].P->mm[1].Xtot
   [sln] generate iadd[4].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[4]
   [sln] generate iadd[4].OUT = (Etot+(-1*P))
   [sln] conn iadd[4].OUT->vgain[3].Z
   [sln] route iadd[0].A = 0
   [sln] route iadd[0].B = Stot
   [sln] route iadd[0].C = P
   [sln] route mm[1].XY0 = 0
   [sln] route mm[1].kf = 3.154
   [sln] route mm[1].kr = 2.525
   [sln] route vgain[2].X = 1
   [sln] route vgain[3].X = 1
   [sln] route iadd[4].A = 0
   [sln] route iadd[4].B = Etot
   [sln] route iadd[4].C = P
   [comp] make-comp iadd0
   [comp] make-comp mm1
   [comp] make-comp vgain2
   [comp] make-comp vgain3
   [comp] make-comp iadd4
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[1].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[1].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[2].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[3].Z<I>=(Etot+(-1*P))

[multi] ==== ROUTES =====
[multi] > iadd[4].B = Etot
[multi]    - making an input block.
[multi] > iadd[0].B = Stot
[multi]    - making an input block.
[multi] > iadd[4].C = P
[multi]    - connecting generates to routes.
[multi] > iadd[0].C = P
[multi]    - connecting generates to routes.
[multi] > mm[1].kf = 3.154
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > iadd[4].A = 0
[multi]    - making an input block.
[multi] > mm[1].XY0 = 0
[multi]    - making an input block.
[multi] > mm[1].kr = 2.525
[multi]    - making an input block.
[multi] > vgain[3].X = 1
[multi]    - making an input block.
[multi] > vgain[2].X = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[1].Y = S
[multi]    - making an output block.
[multi] > mm[1].X = E
[multi]    - making an output block.
[multi] > mm[1].XY = ES
[multi]    - making an output block.
[multi] > vgain[3].P = (Etot+(-1*P))
[multi] > iadd[4].OUT = (Etot+(-1*P))
[multi] > iadd[4].OUT = (Etot+(-1*P))
[multi] > iadd[0].OUT = ((-1*P)+Stot)
[multi] > vgain[2].P = ((-1*P)+Stot)
[multi] > vgain[2].P = ((-1*P)+Stot)
[multi] --> Number of options 12
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 80 =======
[multi]    remove-goal [127] [EXPR]vgain[2].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[1].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[1].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[3].Z<I>=(Etot+(-1*P))
   [comp] iadd[0] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[0] cfg-in A=0
   [comp] iadd[0] cfg-in B=Stot
   [comp] iadd[0] cfg-in C=P
   [comp] mm[1] cfg-in XY0=0
   [comp] mm[1] cfg-in XY=ES
   [comp] mm[1] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[1] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[1] cfg-in Y=S
   [comp] mm[1] cfg-in X=E
   [comp] mm[1] cfg-in kf=3.154
   [comp] mm[1] cfg-in kr=2.525
   [comp] vgain[2] cfg-in P=((-1*P)+Stot)
   [comp] vgain[2] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[2] cfg-in X=1
   [comp] vgain[3] cfg-in P=(Etot+(-1*P))
   [comp] vgain[3] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[3] cfg-in X=1
   [comp] iadd[4] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[4] cfg-in A=0
   [comp] iadd[4] cfg-in B=Etot
   [comp] iadd[4] cfg-in C=P
   [sln] generate iadd[0].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[0]
   [sln] generate iadd[0].OUT = ((-1*P)+Stot)
   [sln] conn iadd[0].OUT->vgain[2].Z
   [sln] generate mm[1].XY = ES
   [sln] generate mm[1].Y = S
   [sln] generate mm[1].X = E
   [sln] add-comp mm[1]
   [sln] generate vgain[2].P = ((-1*P)+Stot)
   [sln] add-comp vgain[2]
   [sln] generate vgain[2].P = ((-1*P)+Stot)
   [sln] conn vgain[2].P->mm[1].Ytot
   [sln] generate vgain[3].P = (Etot+(-1*P))
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (Etot+(-1*P))
   [sln] conn vgain[3].P->mm[1].Xtot
   [sln] generate iadd[4].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[4]
   [sln] generate iadd[4].OUT = (Etot+(-1*P))
   [sln] conn iadd[4].OUT->vgain[3].Z
   [sln] route iadd[0].A = 0
   [sln] route iadd[0].B = Stot
   [sln] route iadd[0].C = P
   [sln] route mm[1].XY0 = 0
   [sln] route mm[1].kf = 3.154
   [sln] route mm[1].kr = 2.525
   [sln] route vgain[2].X = 1
   [sln] route vgain[3].X = 1
   [sln] route iadd[4].A = 0
   [sln] route iadd[4].B = Etot
   [sln] route iadd[4].C = P
   [comp] make-comp iadd0
   [comp] make-comp mm1
   [comp] make-comp vgain2
   [comp] make-comp vgain3
   [comp] make-comp iadd4
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[1].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[1].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[2].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[3].Z<I>=(Etot+(-1*P))

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=Etot
     [comp] input.I[0] cfg-out O=Etot
     [comp] input.I[1] cfg-in X=Stot
     [comp] input.I[1] cfg-out O=Stot
     [comp] input.I[2] cfg-in X=3.154
     [comp] input.I[2] cfg-out O=3.154
     [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.V[0] cfg-in X=0
     [comp] input.V[0] cfg-out O=0
     [comp] input.I[5] cfg-in X=2.525
     [comp] input.I[5] cfg-out O=2.525
     [comp] input.V[1] cfg-in X=1
     [comp] input.V[1] cfg-out O=1
     [comp] input.V[2] cfg-in X=1
     [comp] input.V[2] cfg-out O=1
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route iadd[4].B = Etot
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = Etot
     [sln] rm-route iadd[0].B = Stot
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = Stot
     [sln] rm-route mm[1].kf = 3.154
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 3.154
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] rm-route iadd[4].A = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route mm[1].XY0 = 0
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0
     [sln] rm-route mm[1].kr = 2.525
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 2.525
     [sln] rm-route vgain[3].X = 1
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 1
     [sln] rm-route vgain[2].X = 1
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.I[0].X = Etot
     [sln] route input.I[1].X = Stot
     [sln] route input.I[2].X = 3.154
     [sln] route input.I[3].X = 0
     [sln] route input.I[4].X = 0
     [sln] route input.V[0].X = 0
     [sln] route input.I[5].X = 2.525
     [sln] route input.V[1].X = 1
     [sln] route input.V[2].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.V0
     [comp] make-comp input.I5
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [200] [CONN] input.I[0].O => iadd[4].B (Etot)
     add-goal [201] [CONN] input.I[1].O => iadd[0].B (Stot)
     add-goal [202] [CONN] input.I[2].O => mm[1].kf (3.154)
     add-goal [203] [CONN] input.I[3].O => iadd[0].A (0)
     add-goal [204] [CONN] input.I[4].O => iadd[4].A (0)
     add-goal [205] [CONN] input.V[0].O => mm[1].XY0 (0)
     add-goal [206] [CONN] input.I[5].O => mm[1].kr (2.525)
     add-goal [207] [CONN] input.V[1].O => vgain[3].X (1)
     add-goal [208] [CONN] input.V[2].O => vgain[2].X (1)
     add-goal [209] [CONN] mm[1].Y => output.V[0].X (S)
     add-goal [210] [CONN] mm[1].X => output.V[1].X (E)
     add-goal [211] [CONN] mm[1].XY => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[203] [CONN] input.I[3].O => iadd[0].A (0)
[211] [CONN] mm[1].XY => output.V[2].X (ES)
[201] [CONN] input.I[1].O => iadd[0].B (Stot)
[204] [CONN] input.I[4].O => iadd[4].A (0)
[205] [CONN] input.V[0].O => mm[1].XY0 (0)
[207] [CONN] input.V[1].O => vgain[3].X (1)
[209] [CONN] mm[1].Y => output.V[0].X (S)
[202] [CONN] input.I[2].O => mm[1].kf (3.154)
[206] [CONN] input.I[5].O => mm[1].kr (2.525)
[208] [CONN] input.V[2].O => vgain[2].X (1)
[200] [CONN] input.I[0].O => iadd[4].B (Etot)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[210] [CONN] mm[1].X => output.V[1].X (E)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}

============
>> Current Goal: [210] [CONN] mm[1].X => output.V[1].X (E)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=1

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi] # Found 0, Required: 1
[multi] solving target: P
[multi] search tree is not exhausted. adding existing:P
[multi] finding new partial solution
[multi] made a partial tree with 6 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
vdadd.OUT -> true
mm.XY -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  2 <<<
[eqn] new: [0] <vdadd> output OUT.V
<analog-st> ((vdadd.V{A}:+(vdadd.BSW*vdadd.V{B}:))-(vdadd.DSW*vdadd.I{D}:*vdadd.V{OUT}:)) ic=OUT_0.V / std=none 0
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,12000.] {v}->[v]=@ {v}->*[v]=@


checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
[eqn] new: [0] <mm> output XY.V
<analog-st> ((mm.I{kf}:*mm.V{X}:*mm.V{Y}:)-(mm.I{kr}:*mm.V{XY}:)) ic=XY0.V / std=gauss ((0.001*mm.V{XY}:)+0.1)
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,3200.] {v}->[v]=@ {v}->*[v]=@


[eqn] [FOUND-SOLS] ===> Found <8> solutions
[slvrsearch] > weight--: <mvar-goal>P
[eqn] -> [valid?] testing node 17
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[233] [EXPR]vdadd[1].A<V>=(0.21*ES)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
vgain.P -> true
vadd.OUT -> true
mm.X -> true
mm.Y -> true
itov.Y -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  5 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <vadd> output OUT.V
<analog>:(((vadd.V{A}:+(vadd.BSW*vadd.V{B}:))-(vadd.CSW*vadd.V{C}:))*0.25) / std=gauss ((0.001*vadd.V{OUT}:)+0.1)
<analog> [v]={[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } {v}->[v]=@


[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <mm> output Y.V
<analog>:(mm.V{Ytot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <mm> output X.V
<analog>:(mm.V{Xtot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <itov> output Y.V
<analog>:(itov.V{K}:*itov.I{X}:) / std=gauss 0.1
<analog> [v]=[0.,3300.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] [FOUND-SOLS] ===> Found <23> solutions
[slvrsearch] > weight--: (0.21*ES)
[eqn] -> [valid?] testing node 63
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=2

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 61
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=3

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 59
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=4

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 27
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=5

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 25
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=6

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 23
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=7

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 58
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 25 ==
[multi] == Adding Local Solution : 23 ==
[multi] == Adding Local Solution : 59 ==
[multi] == Adding Local Solution : 27 ==
[multi] == Adding Local Solution : 61 ==
[multi] == Adding Local Solution : 63 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 80
[multi] # partial ids = 2
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] vgain[0] cfg-in P=(0.21*ES)
   [comp] vgain[0] cfg-in X=ES
   [comp] vgain[0] cfg-in Z=0.21
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route vgain[0].X = ES
   [sln] route vgain[0].Z = 0.21
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ==== ROUTES =====
[multi] > iadd[6].B = Etot
[multi]    - making an input block.
[multi] > iadd[2].B = Stot
[multi]    - making an input block.
[multi] > iadd[6].C = P
[multi]    - connecting generates to routes.
[multi] > iadd[2].C = P
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = ES
[multi]    - connecting generates to routes.
[multi] > mm[3].kf = 3.154
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].B = 0
[multi]    - making an input block.
[multi] > vdadd[1].D = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[6].A = 0
[multi]    - making an input block.
[multi] > mm[3].XY0 = 0
[multi]    - making an input block.
[multi] > vgain[0].Z = 0.21
[multi]    - making an input block.
[multi] > mm[3].kr = 2.525
[multi]    - making an input block.
[multi] > vgain[5].X = 1
[multi]    - making an input block.
[multi] > vgain[4].X = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[3].Y = S
[multi]    - making an output block.
[multi] > vdadd[1].OUT = P
[multi]    - making an output block.
[multi] > mm[3].X = E
[multi]    - making an output block.
[multi] > mm[3].XY = ES
[multi]    - making an output block.
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 20
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] vgain[0] cfg-in P=(0.21*ES)
   [comp] vgain[0] cfg-in X=ES
   [comp] vgain[0] cfg-in Z=0.21
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route vgain[0].X = ES
   [sln] route vgain[0].Z = 0.21
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=Etot
     [comp] input.I[0] cfg-out O=Etot
     [comp] input.I[1] cfg-in X=Stot
     [comp] input.I[1] cfg-out O=Stot
     [comp] input.I[2] cfg-in X=3.154
     [comp] input.I[2] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0
     [comp] input.V[0] cfg-out O=0
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.I[6] cfg-in X=0.21
     [comp] input.I[6] cfg-out O=0.21
     [comp] input.I[7] cfg-in X=2.525
     [comp] input.I[7] cfg-out O=2.525
     [comp] input.V[3] cfg-in X=1
     [comp] input.V[3] cfg-out O=1
     [comp] input.V[4] cfg-in X=1
     [comp] input.V[4] cfg-out O=1
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route iadd[6].B = Etot
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = Etot
     [sln] rm-route iadd[2].B = Stot
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = Stot
     [sln] rm-route iadd[6].C = P
     [sln] rm-route iadd[2].C = P
     [sln] rm-route vgain[0].X = ES
     [sln] rm-route mm[3].kf = 3.154
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 3.154
     [sln] rm-route vdadd[1].OUT_0 = 0
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0
     [sln] rm-route vdadd[1].B = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].D = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[6].A = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route mm[3].XY0 = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vgain[0].Z = 0.21
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0.21
     [sln] rm-route mm[3].kr = 2.525
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 2.525
     [sln] rm-route vgain[5].X = 1
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 1
     [sln] rm-route vgain[4].X = 1
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = Etot
     [sln] route input.I[1].X = Stot
     [sln] route input.I[2].X = 3.154
     [sln] route input.V[0].X = 0
     [sln] route input.V[1].X = 0
     [sln] route input.I[3].X = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.I[6].X = 0.21
     [sln] route input.I[7].X = 2.525
     [sln] route input.V[3].X = 1
     [sln] route input.V[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.I2
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.V2
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [274] [CONN] input.I[0].O => iadd[6].B (Etot)
     add-goal [275] [CONN] input.I[1].O => iadd[2].B (Stot)
     add-goal [276] [CONN] vdadd[1].OUT => iadd[6].C (P)
     add-goal [277] [CONN] vdadd[1].OUT => iadd[2].C (P)
     add-goal [278] [CONN] mm[3].XY => vgain[0].X (ES)
     add-goal [279] [CONN] input.I[2].O => mm[3].kf (3.154)
     add-goal [280] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
     add-goal [281] [CONN] input.V[1].O => vdadd[1].B (0)
     add-goal [282] [CONN] input.I[3].O => vdadd[1].D (0)
     add-goal [283] [CONN] input.I[4].O => iadd[2].A (0)
     add-goal [284] [CONN] input.I[5].O => iadd[6].A (0)
     add-goal [285] [CONN] input.V[2].O => mm[3].XY0 (0)
     add-goal [286] [CONN] input.I[6].O => vgain[0].Z (0.21)
     add-goal [287] [CONN] input.I[7].O => mm[3].kr (2.525)
     add-goal [288] [CONN] input.V[3].O => vgain[5].X (1)
     add-goal [289] [CONN] input.V[4].O => vgain[4].X (1)
     add-goal [290] [CONN] mm[3].Y => output.V[0].X (S)
     add-goal [291] [CONN] vdadd[1].OUT => output.V[1].X (P)
     add-goal [292] [CONN] mm[3].X => output.V[2].X (E)
     add-goal [293] [CONN] mm[3].XY => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[288] [CONN] input.V[3].O => vgain[5].X (1)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[281] [CONN] input.V[1].O => vdadd[1].B (0)
[274] [CONN] input.I[0].O => iadd[6].B (Etot)
[279] [CONN] input.I[2].O => mm[3].kf (3.154)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[278] [CONN] mm[3].XY => vgain[0].X (ES)
[287] [CONN] input.I[7].O => mm[3].kr (2.525)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[275] [CONN] input.I[1].O => iadd[2].B (Stot)
[289] [CONN] input.V[4].O => vgain[4].X (1)
[290] [CONN] mm[3].Y => output.V[0].X (S)
[291] [CONN] vdadd[1].OUT => output.V[1].X (P)
[283] [CONN] input.I[4].O => iadd[2].A (0)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[276] [CONN] vdadd[1].OUT => iadd[6].C (P)
[277] [CONN] vdadd[1].OUT => iadd[2].C (P)
[292] [CONN] mm[3].X => output.V[2].X (E)
[284] [CONN] input.I[5].O => iadd[6].A (0)
[282] [CONN] input.I[3].O => vdadd[1].D (0)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[280] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
[285] [CONN] input.V[2].O => mm[3].XY0 (0)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[286] [CONN] input.I[6].O => vgain[0].Z (0.21)
[293] [CONN] mm[3].XY => output.V[3].X (ES)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [293] [CONN] mm[3].XY => output.V[3].X (ES)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[276] [CONN] vdadd[1].OUT => iadd[6].C (P)
[277] [CONN] vdadd[1].OUT => iadd[2].C (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[286] [CONN] input.I[6].O => vgain[0].Z (0.21)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [286] [CONN] input.I[6].O => vgain[0].Z (0.21)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[276] [CONN] vdadd[1].OUT => iadd[6].C (P)
[277] [CONN] vdadd[1].OUT => iadd[2].C (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[295] [CONN] input.I[6].O => iadd[7].B (0.21)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [295] [CONN] input.I[6].O => iadd[7].B (0.21)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[276] [CONN] vdadd[1].OUT => iadd[6].C (P)
[277] [CONN] vdadd[1].OUT => iadd[2].C (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [277] [CONN] vdadd[1].OUT => iadd[2].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 9
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[276] [CONN] vdadd[1].OUT => iadd[6].C (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[298] [CONN] vdadd[1].OUT => vtoi[0].X (P)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [298] [CONN] vdadd[1].OUT => vtoi[0].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[276] [CONN] vdadd[1].OUT => iadd[6].C (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [276] [CONN] vdadd[1].OUT => iadd[6].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 13
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[301] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [301] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 14
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=8

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = Etot
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = Stot
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 3.154
[multi]     - ignoring route to input block.
[multi] > iadd[7].C = 0
[multi]    - making an input block.
[multi] > iadd[7].A = 0
[multi]    - making an input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[6].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[7].X = 2.525
[multi]     - ignoring route to input block.
[multi] > vtoi[1].K = 1
[multi]    - making an input block.
[multi] > vtoi[0].K = 1
[multi]    - making an input block.
[multi] > input.V[3].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 1
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > input.I[0].O = Etot
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = Stot
[multi]     - ignoring generate to input block.
[multi] > mm[3].Y = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > mm[3].X = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > mm[3].XY = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[2].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[6].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[7].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 1
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[0].P = (0.21*ES)
[multi] > iadd[7].OUT = 0.21
[multi] > vtoi[0].Y = P
[multi] > vtoi[1].Y = P
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [comp] input.I[9] cfg-in X=0
     [comp] input.I[9] cfg-out O=0
     [comp] input.V[5] cfg-in X=1
     [comp] input.V[5] cfg-out O=1
     [comp] input.V[6] cfg-in X=1
     [comp] input.V[6] cfg-out O=1
     [sln] rm-route iadd[7].C = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] rm-route iadd[7].A = 0
     [sln] add-comp input.I[9]
     [sln] generate input.I[9].O = 0
     [sln] rm-route vtoi[1].K = 1
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 1
     [sln] rm-route vtoi[0].K = 1
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 1
     [sln] route input.I[8].X = 0
     [sln] route input.I[9].X = 0
     [sln] route input.V[5].X = 1
     [sln] route input.V[6].X = 1
     [comp] make-comp input.I8
     [comp] make-comp input.I9
     [comp] make-comp input.V5
     [comp] make-comp input.V6
     add-goal [302] [CONN] input.I[8].O => iadd[7].C (0)
     add-goal [303] [CONN] input.I[9].O => iadd[7].A (0)
     add-goal [304] [CONN] input.V[5].O => vtoi[1].K (1)
     add-goal [305] [CONN] input.V[6].O => vtoi[0].K (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[277] [CONN] vdadd[1].OUT => iadd[2].C (P)
[276] [CONN] vdadd[1].OUT => iadd[6].C (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
[294] [CONN] input.I[6].O => iadd[7].A (0.21)

============
>> Current Goal: [294] [CONN] input.I[6].O => iadd[7].A (0.21)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 12
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[300] [CONN] vdadd[1].OUT => switch[1].Vmax (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [300] [CONN] vdadd[1].OUT => switch[1].Vmax (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 17
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=9

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 11
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = Etot
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = Stot
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 3.154
[multi]     - ignoring route to input block.
[multi] > switch[1].n = 0
[multi]    - making an input block.
[multi] > iadd[7].C = 0
[multi]    - making an input block.
[multi] > iadd[7].A = 0
[multi]    - making an input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[6].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[7].X = 2.525
[multi]     - ignoring route to input block.
[multi] > vtoi[0].K = 1
[multi]    - making an input block.
[multi] > input.V[3].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 1
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > input.I[0].O = Etot
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = Stot
[multi]     - ignoring generate to input block.
[multi] > mm[3].Y = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > mm[3].X = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > mm[3].XY = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[2].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[6].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[7].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 1
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[0].P = (0.21*ES)
[multi] > iadd[7].OUT = 0.21
[multi] > vtoi[0].Y = P
[multi] > switch[1].PROD = P
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[7] cfg-in X=0
     [comp] input.V[7] cfg-out O=0
     [comp] input.I[10] cfg-in X=0
     [comp] input.I[10] cfg-out O=0
     [comp] input.I[11] cfg-in X=0
     [comp] input.I[11] cfg-out O=0
     [comp] input.V[8] cfg-in X=1
     [comp] input.V[8] cfg-out O=1
     [sln] rm-route switch[1].n = 0
     [sln] add-comp input.V[7]
     [sln] generate input.V[7].O = 0
     [sln] rm-route iadd[7].C = 0
     [sln] add-comp input.I[10]
     [sln] generate input.I[10].O = 0
     [sln] rm-route iadd[7].A = 0
     [sln] add-comp input.I[11]
     [sln] generate input.I[11].O = 0
     [sln] rm-route vtoi[0].K = 1
     [sln] add-comp input.V[8]
     [sln] generate input.V[8].O = 1
     [sln] route input.V[7].X = 0
     [sln] route input.I[10].X = 0
     [sln] route input.I[11].X = 0
     [sln] route input.V[8].X = 1
     [comp] make-comp input.V7
     [comp] make-comp input.I10
     [comp] make-comp input.I11
     [comp] make-comp input.V8
     add-goal [306] [CONN] input.V[7].O => switch[1].n (0)
     add-goal [307] [CONN] input.I[10].O => iadd[7].C (0)
     add-goal [308] [CONN] input.I[11].O => iadd[7].A (0)
     add-goal [309] [CONN] input.V[8].O => vtoi[0].K (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[307] [CONN] input.I[10].O => iadd[7].C (0)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[309] [CONN] input.V[8].O => vtoi[0].K (1)
[306] [CONN] input.V[7].O => switch[1].n (0)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[308] [CONN] input.I[11].O => iadd[7].A (0)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [308] [CONN] input.I[11].O => iadd[7].A (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 19
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=10

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 11
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~127P~25 :: 19
[multi] Number of Solutions: 0
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: ES~127P~25 :: 19
[[Z3]] ---> Executing SMT Solver prob=11

[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: vgain[5].Z
[rslvr] z32cstr.wire: vtoi[0].X
[rslvr] z32cstr.wire: vgain[5].P
[rslvr] z32cstr.wire: vdadd[1].B
[rslvr] z32cstr.wire: mm[3].Ytot
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: vgain[0].P
[rslvr] z32cstr.wire: vgain[5].X
[rslvr] z32cstr.wire: iadd[6].C
[rslvr] z32cstr.wire: mm[3].Xtot
[rslvr] z32cstr.wire: iadd[7].A
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vgain[0].X
[rslvr] z32cstr.wire: switch[1].PROD
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: switch[1].Vmax
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vgain[4].X
[rslvr] z32cstr.wire: vgain[4].P
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vgain[0].Z
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: iadd[7].C
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: input.I[10].O
[rslvr] z32cstr.wire: mm[3].XY
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: vtoi[0].Y
[rslvr] z32cstr.wire: iadd[7].OUT
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: input.I[11].O
[rslvr] z32cstr.wire: vtoi[0].K
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: mm[3].kf
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: iadd[6].B
[rslvr] z32cstr.wire: mm[3].XY0
[rslvr] z32cstr.wire: switch[1].n
[rslvr] z32cstr.wire: iadd[6].A
[rslvr] z32cstr.wire: mm[3].X
[rslvr] z32cstr.wire: iadd[6].OUT
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vgain[4].Z
[rslvr] z32cstr.wire: iadd[2].OUT
[rslvr] z32cstr.wire: mm[3].Y
[rslvr] z32cstr.wire: mm[3].kr
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: iadd[7].B
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: input.V[4].O
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_0_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_0_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_0_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_0_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=12

[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: vgain[5].Z
[rslvr] z32cstr.wire: vtoi[0].X
[rslvr] z32cstr.wire: vgain[5].P
[rslvr] z32cstr.wire: vdadd[1].B
[rslvr] z32cstr.wire: mm[3].Ytot
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: vgain[0].P
[rslvr] z32cstr.wire: vgain[5].X
[rslvr] z32cstr.wire: iadd[6].C
[rslvr] z32cstr.wire: mm[3].Xtot
[rslvr] z32cstr.wire: iadd[7].A
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vgain[0].X
[rslvr] z32cstr.wire: switch[1].PROD
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: switch[1].Vmax
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vgain[4].X
[rslvr] z32cstr.wire: vgain[4].P
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vgain[0].Z
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: iadd[7].C
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: input.I[10].O
[rslvr] z32cstr.wire: mm[3].XY
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: vtoi[0].Y
[rslvr] z32cstr.wire: iadd[7].OUT
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: input.I[11].O
[rslvr] z32cstr.wire: vtoi[0].K
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: mm[3].kf
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: iadd[6].B
[rslvr] z32cstr.wire: mm[3].XY0
[rslvr] z32cstr.wire: switch[1].n
[rslvr] z32cstr.wire: iadd[6].A
[rslvr] z32cstr.wire: mm[3].X
[rslvr] z32cstr.wire: iadd[6].OUT
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vgain[4].Z
[rslvr] z32cstr.wire: iadd[2].OUT
[rslvr] z32cstr.wire: mm[3].Y
[rslvr] z32cstr.wire: mm[3].kr
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: iadd[7].B
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: input.V[4].O
->input.I[3]
->input.I[4]
->mm[3]
->output.V[3]
->input.I[5]
->input.V[4]
->input.I[1]
->vgain[4]
->vdadd[1]
->input.I[2]
->input.I[7]
->input.V[2]
->output.V[0]
->vtoi[0]
->vgain[0]
->input.I[10]
->input.V[1]
->switch[1]
->iadd[7]
->output.V[1]
->input.V[3]
->input.I[11]
->input.V[8]
->input.I[6]
->input.V[7]
->iadd[2]
->input.I[0]
->output.V[2]
->vgain[5]
->input.V[0]
->iadd[6]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (78) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=13

[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 80
[multi] # partial ids = 2
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] vgain[0] cfg-in P=(0.21*ES)
   [comp] vgain[0] cfg-in Z=0.21
   [comp] vgain[0] cfg-in X=ES
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route vgain[0].Z = 0.21
   [sln] route vgain[0].X = ES
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ==== ROUTES =====
[multi] > iadd[6].B = Etot
[multi]    - making an input block.
[multi] > iadd[2].B = Stot
[multi]    - making an input block.
[multi] > iadd[6].C = P
[multi]    - connecting generates to routes.
[multi] > iadd[2].C = P
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = ES
[multi]    - connecting generates to routes.
[multi] > mm[3].kf = 3.154
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].B = 0
[multi]    - making an input block.
[multi] > vdadd[1].D = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[6].A = 0
[multi]    - making an input block.
[multi] > mm[3].XY0 = 0
[multi]    - making an input block.
[multi] > vgain[0].Z = 0.21
[multi]    - making an input block.
[multi] > mm[3].kr = 2.525
[multi]    - making an input block.
[multi] > vgain[5].X = 1
[multi]    - making an input block.
[multi] > vgain[4].X = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[3].Y = S
[multi]    - making an output block.
[multi] > vdadd[1].OUT = P
[multi]    - making an output block.
[multi] > mm[3].X = E
[multi]    - making an output block.
[multi] > mm[3].XY = ES
[multi]    - making an output block.
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 20
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] vgain[0] cfg-in P=(0.21*ES)
   [comp] vgain[0] cfg-in Z=0.21
   [comp] vgain[0] cfg-in X=ES
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route vgain[0].Z = 0.21
   [sln] route vgain[0].X = ES
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=Etot
     [comp] input.I[0] cfg-out O=Etot
     [comp] input.I[1] cfg-in X=Stot
     [comp] input.I[1] cfg-out O=Stot
     [comp] input.I[2] cfg-in X=3.154
     [comp] input.I[2] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0
     [comp] input.V[0] cfg-out O=0
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.I[6] cfg-in X=0.21
     [comp] input.I[6] cfg-out O=0.21
     [comp] input.I[7] cfg-in X=2.525
     [comp] input.I[7] cfg-out O=2.525
     [comp] input.V[3] cfg-in X=1
     [comp] input.V[3] cfg-out O=1
     [comp] input.V[4] cfg-in X=1
     [comp] input.V[4] cfg-out O=1
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route iadd[6].B = Etot
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = Etot
     [sln] rm-route iadd[2].B = Stot
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = Stot
     [sln] rm-route iadd[6].C = P
     [sln] rm-route iadd[2].C = P
     [sln] rm-route vgain[0].X = ES
     [sln] rm-route mm[3].kf = 3.154
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 3.154
     [sln] rm-route vdadd[1].OUT_0 = 0
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0
     [sln] rm-route vdadd[1].B = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].D = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[6].A = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route mm[3].XY0 = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vgain[0].Z = 0.21
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0.21
     [sln] rm-route mm[3].kr = 2.525
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 2.525
     [sln] rm-route vgain[5].X = 1
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 1
     [sln] rm-route vgain[4].X = 1
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = Etot
     [sln] route input.I[1].X = Stot
     [sln] route input.I[2].X = 3.154
     [sln] route input.V[0].X = 0
     [sln] route input.V[1].X = 0
     [sln] route input.I[3].X = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.I[6].X = 0.21
     [sln] route input.I[7].X = 2.525
     [sln] route input.V[3].X = 1
     [sln] route input.V[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.I2
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.V2
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [310] [CONN] input.I[0].O => iadd[6].B (Etot)
     add-goal [311] [CONN] input.I[1].O => iadd[2].B (Stot)
     add-goal [312] [CONN] vdadd[1].OUT => iadd[6].C (P)
     add-goal [313] [CONN] vdadd[1].OUT => iadd[2].C (P)
     add-goal [314] [CONN] mm[3].XY => vgain[0].X (ES)
     add-goal [315] [CONN] input.I[2].O => mm[3].kf (3.154)
     add-goal [316] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
     add-goal [317] [CONN] input.V[1].O => vdadd[1].B (0)
     add-goal [318] [CONN] input.I[3].O => vdadd[1].D (0)
     add-goal [319] [CONN] input.I[4].O => iadd[2].A (0)
     add-goal [320] [CONN] input.I[5].O => iadd[6].A (0)
     add-goal [321] [CONN] input.V[2].O => mm[3].XY0 (0)
     add-goal [322] [CONN] input.I[6].O => vgain[0].Z (0.21)
     add-goal [323] [CONN] input.I[7].O => mm[3].kr (2.525)
     add-goal [324] [CONN] input.V[3].O => vgain[5].X (1)
     add-goal [325] [CONN] input.V[4].O => vgain[4].X (1)
     add-goal [326] [CONN] mm[3].Y => output.V[0].X (S)
     add-goal [327] [CONN] vdadd[1].OUT => output.V[1].X (P)
     add-goal [328] [CONN] mm[3].X => output.V[2].X (E)
     add-goal [329] [CONN] mm[3].XY => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[315] [CONN] input.I[2].O => mm[3].kf (3.154)
[317] [CONN] input.V[1].O => vdadd[1].B (0)
[320] [CONN] input.I[5].O => iadd[6].A (0)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[329] [CONN] mm[3].XY => output.V[3].X (ES)
[312] [CONN] vdadd[1].OUT => iadd[6].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[324] [CONN] input.V[3].O => vgain[5].X (1)
[319] [CONN] input.I[4].O => iadd[2].A (0)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[323] [CONN] input.I[7].O => mm[3].kr (2.525)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[327] [CONN] vdadd[1].OUT => output.V[1].X (P)
[314] [CONN] mm[3].XY => vgain[0].X (ES)
[321] [CONN] input.V[2].O => mm[3].XY0 (0)
[328] [CONN] mm[3].X => output.V[2].X (E)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[311] [CONN] input.I[1].O => iadd[2].B (Stot)
[313] [CONN] vdadd[1].OUT => iadd[2].C (P)
[325] [CONN] input.V[4].O => vgain[4].X (1)
[310] [CONN] input.I[0].O => iadd[6].B (Etot)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[322] [CONN] input.I[6].O => vgain[0].Z (0.21)
[318] [CONN] input.I[3].O => vdadd[1].D (0)
[326] [CONN] mm[3].Y => output.V[0].X (S)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
[316] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)

============
>> Current Goal: [316] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[312] [CONN] vdadd[1].OUT => iadd[6].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[313] [CONN] vdadd[1].OUT => iadd[2].C (P)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[322] [CONN] input.I[6].O => vgain[0].Z (0.21)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [322] [CONN] input.I[6].O => vgain[0].Z (0.21)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[312] [CONN] vdadd[1].OUT => iadd[6].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[313] [CONN] vdadd[1].OUT => iadd[2].C (P)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[331] [CONN] input.I[6].O => iadd[7].B (0.21)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [331] [CONN] input.I[6].O => iadd[7].B (0.21)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[312] [CONN] vdadd[1].OUT => iadd[6].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[313] [CONN] vdadd[1].OUT => iadd[2].C (P)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [313] [CONN] vdadd[1].OUT => iadd[2].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 9
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[312] [CONN] vdadd[1].OUT => iadd[6].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[334] [CONN] vdadd[1].OUT => vtoi[0].X (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [334] [CONN] vdadd[1].OUT => vtoi[0].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[312] [CONN] vdadd[1].OUT => iadd[6].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [312] [CONN] vdadd[1].OUT => iadd[6].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 13
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[337] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [337] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 14
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=14

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = Etot
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = Stot
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 3.154
[multi]     - ignoring route to input block.
[multi] > iadd[7].C = 0
[multi]    - making an input block.
[multi] > iadd[7].A = 0
[multi]    - making an input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[6].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[7].X = 2.525
[multi]     - ignoring route to input block.
[multi] > vtoi[1].K = 1
[multi]    - making an input block.
[multi] > vtoi[0].K = 1
[multi]    - making an input block.
[multi] > input.V[3].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 1
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > input.I[0].O = Etot
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = Stot
[multi]     - ignoring generate to input block.
[multi] > mm[3].Y = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > mm[3].X = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > mm[3].XY = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[2].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[6].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[7].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 1
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[0].P = (0.21*ES)
[multi] > iadd[7].OUT = 0.21
[multi] > vtoi[0].Y = P
[multi] > vtoi[1].Y = P
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [comp] input.I[9] cfg-in X=0
     [comp] input.I[9] cfg-out O=0
     [comp] input.V[5] cfg-in X=1
     [comp] input.V[5] cfg-out O=1
     [comp] input.V[6] cfg-in X=1
     [comp] input.V[6] cfg-out O=1
     [sln] rm-route iadd[7].C = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] rm-route iadd[7].A = 0
     [sln] add-comp input.I[9]
     [sln] generate input.I[9].O = 0
     [sln] rm-route vtoi[1].K = 1
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 1
     [sln] rm-route vtoi[0].K = 1
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 1
     [sln] route input.I[8].X = 0
     [sln] route input.I[9].X = 0
     [sln] route input.V[5].X = 1
     [sln] route input.V[6].X = 1
     [comp] make-comp input.I8
     [comp] make-comp input.I9
     [comp] make-comp input.V5
     [comp] make-comp input.V6
     add-goal [338] [CONN] input.I[8].O => iadd[7].C (0)
     add-goal [339] [CONN] input.I[9].O => iadd[7].A (0)
     add-goal [340] [CONN] input.V[5].O => vtoi[1].K (1)
     add-goal [341] [CONN] input.V[6].O => vtoi[0].K (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[330] [CONN] input.I[6].O => iadd[7].A (0.21)
[312] [CONN] vdadd[1].OUT => iadd[6].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[313] [CONN] vdadd[1].OUT => iadd[2].C (P)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [313] [CONN] vdadd[1].OUT => iadd[2].C (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 12
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[336] [CONN] vdadd[1].OUT => switch[1].Vmax (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [336] [CONN] vdadd[1].OUT => switch[1].Vmax (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 17
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=15

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 11
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = Etot
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = Stot
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 3.154
[multi]     - ignoring route to input block.
[multi] > switch[1].n = 0
[multi]    - making an input block.
[multi] > iadd[7].C = 0
[multi]    - making an input block.
[multi] > iadd[7].A = 0
[multi]    - making an input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[6].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[7].X = 2.525
[multi]     - ignoring route to input block.
[multi] > vtoi[0].K = 1
[multi]    - making an input block.
[multi] > input.V[3].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 1
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > input.I[0].O = Etot
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = Stot
[multi]     - ignoring generate to input block.
[multi] > mm[3].Y = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > mm[3].X = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > mm[3].XY = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[2].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[6].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[7].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 1
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[0].P = (0.21*ES)
[multi] > iadd[7].OUT = 0.21
[multi] > vtoi[0].Y = P
[multi] > switch[1].PROD = P
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[7] cfg-in X=0
     [comp] input.V[7] cfg-out O=0
     [comp] input.I[10] cfg-in X=0
     [comp] input.I[10] cfg-out O=0
     [comp] input.I[11] cfg-in X=0
     [comp] input.I[11] cfg-out O=0
     [comp] input.V[8] cfg-in X=1
     [comp] input.V[8] cfg-out O=1
     [sln] rm-route switch[1].n = 0
     [sln] add-comp input.V[7]
     [sln] generate input.V[7].O = 0
     [sln] rm-route iadd[7].C = 0
     [sln] add-comp input.I[10]
     [sln] generate input.I[10].O = 0
     [sln] rm-route iadd[7].A = 0
     [sln] add-comp input.I[11]
     [sln] generate input.I[11].O = 0
     [sln] rm-route vtoi[0].K = 1
     [sln] add-comp input.V[8]
     [sln] generate input.V[8].O = 1
     [sln] route input.V[7].X = 0
     [sln] route input.I[10].X = 0
     [sln] route input.I[11].X = 0
     [sln] route input.V[8].X = 1
     [comp] make-comp input.V7
     [comp] make-comp input.I10
     [comp] make-comp input.I11
     [comp] make-comp input.V8
     add-goal [342] [CONN] input.V[7].O => switch[1].n (0)
     add-goal [343] [CONN] input.I[10].O => iadd[7].C (0)
     add-goal [344] [CONN] input.I[11].O => iadd[7].A (0)
     add-goal [345] [CONN] input.V[8].O => vtoi[0].K (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[344] [CONN] input.I[11].O => iadd[7].A (0)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[342] [CONN] input.V[7].O => switch[1].n (0)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[345] [CONN] input.V[8].O => vtoi[0].K (1)
[343] [CONN] input.I[10].O => iadd[7].C (0)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [343] [CONN] input.I[10].O => iadd[7].C (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 19
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=16

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 11
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~127P~23 :: 19
[multi] Number of Solutions: 1
[multi] => Global Solution: ES~127P~25 :: 19
[multi] >>>NOT NEW! KILLING SOLUTION<<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 80
[multi] # partial ids = 2
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] itov[0] cfg-in Y=(0.21*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=0.21
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 0.21
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ==== ROUTES =====
[multi] > iadd[6].B = Etot
[multi]    - making an input block.
[multi] > iadd[2].B = Stot
[multi]    - making an input block.
[multi] > iadd[6].C = P
[multi]    - connecting generates to routes.
[multi] > iadd[2].C = P
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > mm[3].kf = 3.154
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].B = 0
[multi]    - making an input block.
[multi] > vdadd[1].D = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[6].A = 0
[multi]    - making an input block.
[multi] > mm[3].XY0 = 0
[multi]    - making an input block.
[multi] > itov[0].X = 0.21
[multi]    - making an input block.
[multi] > mm[3].kr = 2.525
[multi]    - making an input block.
[multi] > vgain[5].X = 1
[multi]    - making an input block.
[multi] > vgain[4].X = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[3].Y = S
[multi]    - making an output block.
[multi] > vdadd[1].OUT = P
[multi]    - making an output block.
[multi] > mm[3].X = E
[multi]    - making an output block.
[multi] > mm[3].XY = ES
[multi]    - making an output block.
[multi] > itov[0].Y = (0.21*ES)
[multi] > itov[0].Y = (0.21*ES)
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 20
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] itov[0] cfg-in Y=(0.21*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=0.21
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 0.21
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=Etot
     [comp] input.I[0] cfg-out O=Etot
     [comp] input.I[1] cfg-in X=Stot
     [comp] input.I[1] cfg-out O=Stot
     [comp] input.I[2] cfg-in X=3.154
     [comp] input.I[2] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0
     [comp] input.V[0] cfg-out O=0
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.I[6] cfg-in X=0.21
     [comp] input.I[6] cfg-out O=0.21
     [comp] input.I[7] cfg-in X=2.525
     [comp] input.I[7] cfg-out O=2.525
     [comp] input.V[3] cfg-in X=1
     [comp] input.V[3] cfg-out O=1
     [comp] input.V[4] cfg-in X=1
     [comp] input.V[4] cfg-out O=1
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route iadd[6].B = Etot
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = Etot
     [sln] rm-route iadd[2].B = Stot
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = Stot
     [sln] rm-route iadd[6].C = P
     [sln] rm-route iadd[2].C = P
     [sln] rm-route itov[0].K = ES
     [sln] rm-route mm[3].kf = 3.154
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 3.154
     [sln] rm-route vdadd[1].OUT_0 = 0
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0
     [sln] rm-route vdadd[1].B = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].D = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[6].A = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route mm[3].XY0 = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route itov[0].X = 0.21
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0.21
     [sln] rm-route mm[3].kr = 2.525
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 2.525
     [sln] rm-route vgain[5].X = 1
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 1
     [sln] rm-route vgain[4].X = 1
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = Etot
     [sln] route input.I[1].X = Stot
     [sln] route input.I[2].X = 3.154
     [sln] route input.V[0].X = 0
     [sln] route input.V[1].X = 0
     [sln] route input.I[3].X = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.I[6].X = 0.21
     [sln] route input.I[7].X = 2.525
     [sln] route input.V[3].X = 1
     [sln] route input.V[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.I2
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.V2
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [346] [CONN] input.I[0].O => iadd[6].B (Etot)
     add-goal [347] [CONN] input.I[1].O => iadd[2].B (Stot)
     add-goal [348] [CONN] vdadd[1].OUT => iadd[6].C (P)
     add-goal [349] [CONN] vdadd[1].OUT => iadd[2].C (P)
     add-goal [350] [CONN] mm[3].XY => itov[0].K (ES)
     add-goal [351] [CONN] input.I[2].O => mm[3].kf (3.154)
     add-goal [352] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
     add-goal [353] [CONN] input.V[1].O => vdadd[1].B (0)
     add-goal [354] [CONN] input.I[3].O => vdadd[1].D (0)
     add-goal [355] [CONN] input.I[4].O => iadd[2].A (0)
     add-goal [356] [CONN] input.I[5].O => iadd[6].A (0)
     add-goal [357] [CONN] input.V[2].O => mm[3].XY0 (0)
     add-goal [358] [CONN] input.I[6].O => itov[0].X (0.21)
     add-goal [359] [CONN] input.I[7].O => mm[3].kr (2.525)
     add-goal [360] [CONN] input.V[3].O => vgain[5].X (1)
     add-goal [361] [CONN] input.V[4].O => vgain[4].X (1)
     add-goal [362] [CONN] mm[3].Y => output.V[0].X (S)
     add-goal [363] [CONN] vdadd[1].OUT => output.V[1].X (P)
     add-goal [364] [CONN] mm[3].X => output.V[2].X (E)
     add-goal [365] [CONN] mm[3].XY => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[350] [CONN] mm[3].XY => itov[0].K (ES)
[359] [CONN] input.I[7].O => mm[3].kr (2.525)
[346] [CONN] input.I[0].O => iadd[6].B (Etot)
[347] [CONN] input.I[1].O => iadd[2].B (Stot)
[362] [CONN] mm[3].Y => output.V[0].X (S)
[357] [CONN] input.V[2].O => mm[3].XY0 (0)
[364] [CONN] mm[3].X => output.V[2].X (E)
[363] [CONN] vdadd[1].OUT => output.V[1].X (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[361] [CONN] input.V[4].O => vgain[4].X (1)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[348] [CONN] vdadd[1].OUT => iadd[6].C (P)
[360] [CONN] input.V[3].O => vgain[5].X (1)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[351] [CONN] input.I[2].O => mm[3].kf (3.154)
[353] [CONN] input.V[1].O => vdadd[1].B (0)
[365] [CONN] mm[3].XY => output.V[3].X (ES)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[354] [CONN] input.I[3].O => vdadd[1].D (0)
[349] [CONN] vdadd[1].OUT => iadd[2].C (P)
[356] [CONN] input.I[5].O => iadd[6].A (0)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[358] [CONN] input.I[6].O => itov[0].X (0.21)
[355] [CONN] input.I[4].O => iadd[2].A (0)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
[352] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)

============
>> Current Goal: [352] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[350] [CONN] mm[3].XY => itov[0].K (ES)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[348] [CONN] vdadd[1].OUT => iadd[6].C (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[349] [CONN] vdadd[1].OUT => iadd[2].C (P)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [349] [CONN] vdadd[1].OUT => iadd[2].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 6
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[350] [CONN] mm[3].XY => itov[0].K (ES)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[348] [CONN] vdadd[1].OUT => iadd[6].C (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[368] [CONN] vdadd[1].OUT => vtoi[0].X (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [368] [CONN] vdadd[1].OUT => vtoi[0].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 7
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[350] [CONN] mm[3].XY => itov[0].K (ES)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[348] [CONN] vdadd[1].OUT => iadd[6].C (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [348] [CONN] vdadd[1].OUT => iadd[6].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 10
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[350] [CONN] mm[3].XY => itov[0].K (ES)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[371] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [371] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 11
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[350] [CONN] mm[3].XY => itov[0].K (ES)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [350] [CONN] mm[3].XY => itov[0].K (ES)
vgain.P || # ins: 2 / connected / V ?= V/distance=0
vgain.P -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn] ==== vgain====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: P=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vgain====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: P=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Z=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->itov.K
[eqn] -> [valid?] testing node 13
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[373] [CONN] mm[3].XY => vgain[6].Z (ES)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [373] [CONN] mm[3].XY => vgain[6].Z (ES)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->vgain.Z
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 14
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=17

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = Etot
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = Stot
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[6].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[7].X = 2.525
[multi]     - ignoring route to input block.
[multi] > vgain[6].X = 1
[multi]    - making an input block.
[multi] > vtoi[1].K = 1
[multi]    - making an input block.
[multi] > vtoi[0].K = 1
[multi]    - making an input block.
[multi] > input.V[3].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 1
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > input.I[0].O = Etot
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = Stot
[multi]     - ignoring generate to input block.
[multi] > mm[3].Y = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > mm[3].X = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > mm[3].XY = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[2].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[6].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[7].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 1
[multi]     - ignoring generate to input block.
[multi] > itov[0].Y = (0.21*ES)
[multi] > itov[0].Y = (0.21*ES)
[multi] > vtoi[0].Y = P
[multi] > vtoi[1].Y = P
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[6].P = ES
[multi] --> Number of options 3
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[5] cfg-in X=1
     [comp] input.V[5] cfg-out O=1
     [comp] input.V[6] cfg-in X=1
     [comp] input.V[6] cfg-out O=1
     [comp] input.V[7] cfg-in X=1
     [comp] input.V[7] cfg-out O=1
     [sln] rm-route vgain[6].X = 1
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 1
     [sln] rm-route vtoi[1].K = 1
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 1
     [sln] rm-route vtoi[0].K = 1
     [sln] add-comp input.V[7]
     [sln] generate input.V[7].O = 1
     [sln] route input.V[5].X = 1
     [sln] route input.V[6].X = 1
     [sln] route input.V[7].X = 1
     [comp] make-comp input.V5
     [comp] make-comp input.V6
     [comp] make-comp input.V7
     add-goal [374] [CONN] input.V[5].O => vgain[6].X (1)
     add-goal [375] [CONN] input.V[6].O => vtoi[1].K (1)
     add-goal [376] [CONN] input.V[7].O => vtoi[0].K (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[350] [CONN] mm[3].XY => itov[0].K (ES)
[366] [CONN] vdadd[1].OUT => switch[0].Vmax (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[348] [CONN] vdadd[1].OUT => iadd[6].C (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [348] [CONN] vdadd[1].OUT => iadd[6].C (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 12
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[372] [CONN] mm[3].XY => vgain[6].X (ES)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [372] [CONN] mm[3].XY => vgain[6].X (ES)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->vgain.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 17
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=18

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 16
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = Etot
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = Stot
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[6].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[7].X = 2.525
[multi]     - ignoring route to input block.
[multi] > vgain[6].Z = 1
[multi]    - making an input block.
[multi] > vtoi[1].K = 1
[multi]    - making an input block.
[multi] > vtoi[0].K = 1
[multi]    - making an input block.
[multi] > input.V[3].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 1
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > input.I[0].O = Etot
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = Stot
[multi]     - ignoring generate to input block.
[multi] > mm[3].Y = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > mm[3].X = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > mm[3].XY = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[2].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[6].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[7].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 1
[multi]     - ignoring generate to input block.
[multi] > itov[0].Y = (0.21*ES)
[multi] > itov[0].Y = (0.21*ES)
[multi] > vtoi[0].Y = P
[multi] > vtoi[1].Y = P
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[6].P = ES
[multi] --> Number of options 3
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[8] cfg-in X=1
     [comp] input.I[8] cfg-out O=1
     [comp] input.V[8] cfg-in X=1
     [comp] input.V[8] cfg-out O=1
     [comp] input.V[9] cfg-in X=1
     [comp] input.V[9] cfg-out O=1
     [sln] rm-route vgain[6].Z = 1
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 1
     [sln] rm-route vtoi[1].K = 1
     [sln] add-comp input.V[8]
     [sln] generate input.V[8].O = 1
     [sln] rm-route vtoi[0].K = 1
     [sln] add-comp input.V[9]
     [sln] generate input.V[9].O = 1
     [sln] route input.I[8].X = 1
     [sln] route input.V[8].X = 1
     [sln] route input.V[9].X = 1
     [comp] make-comp input.I8
     [comp] make-comp input.V8
     [comp] make-comp input.V9
     add-goal [377] [CONN] input.I[8].O => vgain[6].Z (1)
     add-goal [378] [CONN] input.V[8].O => vtoi[1].K (1)
     add-goal [379] [CONN] input.V[9].O => vtoi[0].K (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[377] [CONN] input.I[8].O => vgain[6].Z (1)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[378] [CONN] input.V[8].O => vtoi[1].K (1)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[379] [CONN] input.V[9].O => vtoi[0].K (1)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [379] [CONN] input.V[9].O => vtoi[0].K (1)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 19
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[377] [CONN] input.I[8].O => vgain[6].Z (1)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [377] [CONN] input.I[8].O => vgain[6].Z (1)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 21
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[381] [CONN] input.I[8].O => iadd[7].B (1)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [381] [CONN] input.I[8].O => iadd[7].B (1)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 22
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=19

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 20
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = Etot
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = Stot
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 3.154
[multi]     - ignoring route to input block.
[multi] > iadd[7].C = 0
[multi]    - making an input block.
[multi] > iadd[7].A = 0
[multi]    - making an input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[6].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[7].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[8].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[8].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[9].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 1
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > input.I[0].O = Etot
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = Stot
[multi]     - ignoring generate to input block.
[multi] > mm[3].Y = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > mm[3].X = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > mm[3].XY = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[2].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[6].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[7].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[8].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[8].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[9].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 1
[multi]     - ignoring generate to input block.
[multi] > itov[0].Y = (0.21*ES)
[multi] > itov[0].Y = (0.21*ES)
[multi] > iadd[7].OUT = 1
[multi] > vtoi[0].Y = P
[multi] > vtoi[1].Y = P
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[6].P = ES
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[9] cfg-in X=0
     [comp] input.I[9] cfg-out O=0
     [comp] input.I[10] cfg-in X=0
     [comp] input.I[10] cfg-out O=0
     [sln] rm-route iadd[7].C = 0
     [sln] add-comp input.I[9]
     [sln] generate input.I[9].O = 0
     [sln] rm-route iadd[7].A = 0
     [sln] add-comp input.I[10]
     [sln] generate input.I[10].O = 0
     [sln] route input.I[9].X = 0
     [sln] route input.I[10].X = 0
     [comp] make-comp input.I9
     [comp] make-comp input.I10
     add-goal [382] [CONN] input.I[9].O => iadd[7].C (0)
     add-goal [383] [CONN] input.I[10].O => iadd[7].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[382] [CONN] input.I[9].O => iadd[7].C (0)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[383] [CONN] input.I[10].O => iadd[7].A (0)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [383] [CONN] input.I[10].O => iadd[7].A (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 24
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=20

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 20
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~127P~59 :: 24
[multi] Number of Solutions: 1
[multi] => Global Solution: ES~127P~25 :: 19
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: ES~127P~59 :: 24
[[Z3]] ---> Executing SMT Solver prob=21

[rslvr] z32cstr.wire: vgain[5].P
[rslvr] z32cstr.wire: iadd[6].B
[rslvr] z32cstr.wire: vgain[4].Z
[rslvr] z32cstr.wire: iadd[7].A
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: iadd[7].OUT
[rslvr] z32cstr.wire: iadd[2].OUT
[rslvr] z32cstr.wire: input.I[10].O
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: iadd[6].OUT
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: input.I[9].O
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: vtoi[0].K
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: vtoi[1].Y
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: mm[3].kr
[rslvr] z32cstr.wire: vgain[5].Z
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: vtoi[1].X
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: vgain[4].P
[rslvr] z32cstr.wire: iadd[7].B
[rslvr] z32cstr.wire: mm[3].kf
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: mm[3].Ytot
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: mm[3].Xtot
[rslvr] z32cstr.wire: input.I[8].O
[rslvr] z32cstr.wire: iadd[6].A
[rslvr] z32cstr.wire: vtoi[0].X
[rslvr] z32cstr.wire: vgain[5].X
[rslvr] z32cstr.wire: mm[3].X
[rslvr] z32cstr.wire: vtoi[0].Y
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: mm[3].Y
[rslvr] z32cstr.wire: iadd[7].C
[rslvr] z32cstr.wire: vtoi[1].K
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: iadd[6].C
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: vgain[4].X
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: mm[3].XY
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: mm[3].XY0
[rslvr] z32cstr.wire: input.V[9].O
[rslvr] z32cstr.wire: vdadd[1].B
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_1_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_1_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_1_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_1_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=22

[rslvr] z32cstr.wire: vgain[5].P
[rslvr] z32cstr.wire: iadd[6].B
[rslvr] z32cstr.wire: vgain[4].Z
[rslvr] z32cstr.wire: iadd[7].A
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: iadd[7].OUT
[rslvr] z32cstr.wire: iadd[2].OUT
[rslvr] z32cstr.wire: input.I[10].O
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: iadd[6].OUT
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: input.I[9].O
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: vtoi[0].K
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: vtoi[1].Y
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: mm[3].kr
[rslvr] z32cstr.wire: vgain[5].Z
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: vtoi[1].X
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: vgain[4].P
[rslvr] z32cstr.wire: iadd[7].B
[rslvr] z32cstr.wire: mm[3].kf
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: mm[3].Ytot
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: mm[3].Xtot
[rslvr] z32cstr.wire: input.I[8].O
[rslvr] z32cstr.wire: iadd[6].A
[rslvr] z32cstr.wire: vtoi[0].X
[rslvr] z32cstr.wire: vgain[5].X
[rslvr] z32cstr.wire: mm[3].X
[rslvr] z32cstr.wire: vtoi[0].Y
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: mm[3].Y
[rslvr] z32cstr.wire: iadd[7].C
[rslvr] z32cstr.wire: vtoi[1].K
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: iadd[6].C
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: vgain[4].X
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: mm[3].XY
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: mm[3].XY0
[rslvr] z32cstr.wire: input.V[9].O
[rslvr] z32cstr.wire: vdadd[1].B
->vgain[6]
->input.I[3]
->input.I[4]
->mm[3]
->input.I[8]
->output.V[3]
->input.I[5]
->input.V[4]
->input.I[1]
->itov[0]
->vgain[4]
->vdadd[1]
->input.I[2]
->input.I[7]
->input.V[2]
->output.V[0]
->vtoi[0]
->input.I[10]
->input.V[1]
->input.I[9]
->iadd[7]
->input.V[9]
->output.V[1]
->input.V[3]
->input.V[8]
->input.I[6]
->iadd[2]
->input.I[0]
->output.V[2]
->vgain[5]
->vtoi[1]
->input.V[0]
->iadd[6]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (83) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=23

[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 80
[multi] # partial ids = 2
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] vgain[0] cfg-in P=(0.21*ES)
   [comp] vgain[0] cfg-in Z=ES
   [comp] vgain[0] cfg-in X=0.21
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route vgain[0].Z = ES
   [sln] route vgain[0].X = 0.21
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ==== ROUTES =====
[multi] > iadd[6].B = Etot
[multi]    - making an input block.
[multi] > iadd[2].B = Stot
[multi]    - making an input block.
[multi] > iadd[6].C = P
[multi]    - connecting generates to routes.
[multi] > iadd[2].C = P
[multi]    - connecting generates to routes.
[multi] > vgain[0].Z = ES
[multi]    - connecting generates to routes.
[multi] > mm[3].kf = 3.154
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].B = 0
[multi]    - making an input block.
[multi] > vdadd[1].D = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[6].A = 0
[multi]    - making an input block.
[multi] > mm[3].XY0 = 0
[multi]    - making an input block.
[multi] > vgain[0].X = 0.21
[multi]    - making an input block.
[multi] > mm[3].kr = 2.525
[multi]    - making an input block.
[multi] > vgain[5].X = 1
[multi]    - making an input block.
[multi] > vgain[4].X = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[3].Y = S
[multi]    - making an output block.
[multi] > vdadd[1].OUT = P
[multi]    - making an output block.
[multi] > mm[3].X = E
[multi]    - making an output block.
[multi] > mm[3].XY = ES
[multi]    - making an output block.
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 20
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] vgain[0] cfg-in P=(0.21*ES)
   [comp] vgain[0] cfg-in Z=ES
   [comp] vgain[0] cfg-in X=0.21
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (0.21*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route vgain[0].Z = ES
   [sln] route vgain[0].X = 0.21
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=Etot
     [comp] input.I[0] cfg-out O=Etot
     [comp] input.I[1] cfg-in X=Stot
     [comp] input.I[1] cfg-out O=Stot
     [comp] input.I[2] cfg-in X=3.154
     [comp] input.I[2] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0
     [comp] input.V[0] cfg-out O=0
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0.21
     [comp] input.V[3] cfg-out O=0.21
     [comp] input.I[6] cfg-in X=2.525
     [comp] input.I[6] cfg-out O=2.525
     [comp] input.V[4] cfg-in X=1
     [comp] input.V[4] cfg-out O=1
     [comp] input.V[5] cfg-in X=1
     [comp] input.V[5] cfg-out O=1
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route iadd[6].B = Etot
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = Etot
     [sln] rm-route iadd[2].B = Stot
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = Stot
     [sln] rm-route iadd[6].C = P
     [sln] rm-route iadd[2].C = P
     [sln] rm-route vgain[0].Z = ES
     [sln] rm-route mm[3].kf = 3.154
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 3.154
     [sln] rm-route vdadd[1].OUT_0 = 0
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0
     [sln] rm-route vdadd[1].B = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].D = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[6].A = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route mm[3].XY0 = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vgain[0].X = 0.21
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.21
     [sln] rm-route mm[3].kr = 2.525
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 2.525
     [sln] rm-route vgain[5].X = 1
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 1
     [sln] rm-route vgain[4].X = 1
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = Etot
     [sln] route input.I[1].X = Stot
     [sln] route input.I[2].X = 3.154
     [sln] route input.V[0].X = 0
     [sln] route input.V[1].X = 0
     [sln] route input.I[3].X = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0.21
     [sln] route input.I[6].X = 2.525
     [sln] route input.V[4].X = 1
     [sln] route input.V[5].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.I2
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I6
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [384] [CONN] input.I[0].O => iadd[6].B (Etot)
     add-goal [385] [CONN] input.I[1].O => iadd[2].B (Stot)
     add-goal [386] [CONN] vdadd[1].OUT => iadd[6].C (P)
     add-goal [387] [CONN] vdadd[1].OUT => iadd[2].C (P)
     add-goal [388] [CONN] mm[3].XY => vgain[0].Z (ES)
     add-goal [389] [CONN] input.I[2].O => mm[3].kf (3.154)
     add-goal [390] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
     add-goal [391] [CONN] input.V[1].O => vdadd[1].B (0)
     add-goal [392] [CONN] input.I[3].O => vdadd[1].D (0)
     add-goal [393] [CONN] input.I[4].O => iadd[2].A (0)
     add-goal [394] [CONN] input.I[5].O => iadd[6].A (0)
     add-goal [395] [CONN] input.V[2].O => mm[3].XY0 (0)
     add-goal [396] [CONN] input.V[3].O => vgain[0].X (0.21)
     add-goal [397] [CONN] input.I[6].O => mm[3].kr (2.525)
     add-goal [398] [CONN] input.V[4].O => vgain[5].X (1)
     add-goal [399] [CONN] input.V[5].O => vgain[4].X (1)
     add-goal [400] [CONN] mm[3].Y => output.V[0].X (S)
     add-goal [401] [CONN] vdadd[1].OUT => output.V[1].X (P)
     add-goal [402] [CONN] mm[3].X => output.V[2].X (E)
     add-goal [403] [CONN] mm[3].XY => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[396] [CONN] input.V[3].O => vgain[0].X (0.21)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[390] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
[385] [CONN] input.I[1].O => iadd[2].B (Stot)
[398] [CONN] input.V[4].O => vgain[5].X (1)
[387] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[395] [CONN] input.V[2].O => mm[3].XY0 (0)
[400] [CONN] mm[3].Y => output.V[0].X (S)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[384] [CONN] input.I[0].O => iadd[6].B (Etot)
[402] [CONN] mm[3].X => output.V[2].X (E)
[389] [CONN] input.I[2].O => mm[3].kf (3.154)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[401] [CONN] vdadd[1].OUT => output.V[1].X (P)
[393] [CONN] input.I[4].O => iadd[2].A (0)
[394] [CONN] input.I[5].O => iadd[6].A (0)
[399] [CONN] input.V[5].O => vgain[4].X (1)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[388] [CONN] mm[3].XY => vgain[0].Z (ES)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[391] [CONN] input.V[1].O => vdadd[1].B (0)
[403] [CONN] mm[3].XY => output.V[3].X (ES)
[397] [CONN] input.I[6].O => mm[3].kr (2.525)
[392] [CONN] input.I[3].O => vdadd[1].D (0)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
[386] [CONN] vdadd[1].OUT => iadd[6].C (P)

============
>> Current Goal: [386] [CONN] vdadd[1].OUT => iadd[6].C (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->vgain.Z
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[387] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
[386] [CONN] vdadd[1].OUT => iadd[6].C (P)

============
>> Current Goal: [386] [CONN] vdadd[1].OUT => iadd[6].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 6
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[387] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[406] [CONN] vdadd[1].OUT => vtoi[0].X (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [406] [CONN] vdadd[1].OUT => vtoi[0].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 7
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[387] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [387] [CONN] vdadd[1].OUT => iadd[2].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 10
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[409] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [409] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 11
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=24

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 9
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = Etot
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = Stot
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[6].X = 2.525
[multi]     - ignoring route to input block.
[multi] > vtoi[1].K = 1
[multi]    - making an input block.
[multi] > vtoi[0].K = 1
[multi]    - making an input block.
[multi] > input.V[4].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 1
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > input.I[0].O = Etot
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = Stot
[multi]     - ignoring generate to input block.
[multi] > mm[3].Y = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > mm[3].X = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > mm[3].XY = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[2].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[6].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 1
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[0].P = (0.21*ES)
[multi] > vtoi[0].Y = P
[multi] > vtoi[1].Y = P
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[6] cfg-in X=1
     [comp] input.V[6] cfg-out O=1
     [comp] input.V[7] cfg-in X=1
     [comp] input.V[7] cfg-out O=1
     [sln] rm-route vtoi[1].K = 1
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 1
     [sln] rm-route vtoi[0].K = 1
     [sln] add-comp input.V[7]
     [sln] generate input.V[7].O = 1
     [sln] route input.V[6].X = 1
     [sln] route input.V[7].X = 1
     [comp] make-comp input.V6
     [comp] make-comp input.V7
     add-goal [410] [CONN] input.V[6].O => vtoi[1].K (1)
     add-goal [411] [CONN] input.V[7].O => vtoi[0].K (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[387] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[404] [CONN] vdadd[1].OUT => switch[0].Vmax (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [404] [CONN] vdadd[1].OUT => switch[0].Vmax (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 13
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[387] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [387] [CONN] vdadd[1].OUT => iadd[2].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 16
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[414] [CONN] vdadd[1].OUT => vtoi[2].X (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [414] [CONN] vdadd[1].OUT => vtoi[2].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 17
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=25

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 15
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = Etot
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = Stot
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 3.154
[multi]     - ignoring route to input block.
[multi] > switch[0].SUB = 0
[multi]    - making an input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > switch[0].n = -500
[multi]    - making an input block.
[multi] > input.V[3].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[6].X = 2.525
[multi]     - ignoring route to input block.
[multi] > vtoi[2].K = 1
[multi]    - making an input block.
[multi] > switch[0].Kmod = 1
[multi]    - making an input block.
[multi] > input.V[4].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 1
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > input.I[0].O = Etot
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = Stot
[multi]     - ignoring generate to input block.
[multi] > mm[3].Y = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > mm[3].X = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > mm[3].XY = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[2].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[6].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 1
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (0.21*ES)
[multi] > vgain[0].P = (0.21*ES)
[multi] > switch[0].PROD = P
[multi] > vtoi[2].Y = P
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [comp] input.V[8] cfg-in X=-500
     [comp] input.V[8] cfg-out O=-500
     [comp] input.V[9] cfg-in X=1
     [comp] input.V[9] cfg-out O=1
     [comp] input.I[8] cfg-in X=1
     [comp] input.I[8] cfg-out O=1
     [sln] rm-route switch[0].SUB = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] rm-route switch[0].n = -500
     [sln] add-comp input.V[8]
     [sln] generate input.V[8].O = -500
     [sln] rm-route vtoi[2].K = 1
     [sln] add-comp input.V[9]
     [sln] generate input.V[9].O = 1
     [sln] rm-route switch[0].Kmod = 1
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 1
     [sln] route input.I[7].X = 0
     [sln] route input.V[8].X = -500
     [sln] route input.V[9].X = 1
     [sln] route input.I[8].X = 1
     [comp] make-comp input.I7
     [comp] make-comp input.V8
     [comp] make-comp input.V9
     [comp] make-comp input.I8
     add-goal [415] [CONN] input.I[7].O => switch[0].SUB (0)
     add-goal [416] [CONN] input.V[8].O => switch[0].n (-500)
     add-goal [417] [CONN] input.V[9].O => vtoi[2].K (1)
     add-goal [418] [CONN] input.I[8].O => switch[0].Kmod (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[418] [CONN] input.I[8].O => switch[0].Kmod (1)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[417] [CONN] input.V[9].O => vtoi[2].K (1)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[416] [CONN] input.V[8].O => switch[0].n (-500)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[415] [CONN] input.I[7].O => switch[0].SUB (0)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [415] [CONN] input.I[7].O => switch[0].SUB (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.SUB
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 19
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=26

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 15
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~127P~27 :: 19
[multi] Number of Solutions: 2
[multi] => Global Solution: ES~127P~25 :: 19
[multi] => Global Solution: ES~127P~59 :: 24
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: ES~127P~27 :: 19
[[Z3]] ---> Executing SMT Solver prob=27

[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: iadd[6].B
[rslvr] z32cstr.wire: mm[3].Ytot
[rslvr] z32cstr.wire: vgain[5].P
[rslvr] z32cstr.wire: vgain[0].Z
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: vgain[4].Z
[rslvr] z32cstr.wire: iadd[2].OUT
[rslvr] z32cstr.wire: mm[3].XY0
[rslvr] z32cstr.wire: mm[3].kr
[rslvr] z32cstr.wire: mm[3].Xtot
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: vgain[0].P
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vgain[4].P
[rslvr] z32cstr.wire: mm[3].XY
[rslvr] z32cstr.wire: vgain[5].X
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vgain[4].X
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: switch[0].SUB
[rslvr] z32cstr.wire: iadd[6].OUT
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vgain[0].X
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: switch[0].PROD
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: mm[3].X
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: iadd[6].A
[rslvr] z32cstr.wire: switch[0].n
[rslvr] z32cstr.wire: iadd[6].C
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: mm[3].kf
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: switch[0].Kmod
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: switch[0].Vmax
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: mm[3].Y
[rslvr] z32cstr.wire: vdadd[1].B
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: input.V[9].O
[rslvr] z32cstr.wire: vgain[5].Z
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: input.I[8].O
[rslvr] z32cstr.wire: input.V[4].O
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_2_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_2_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_2_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_2_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=28

[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: iadd[6].B
[rslvr] z32cstr.wire: mm[3].Ytot
[rslvr] z32cstr.wire: vgain[5].P
[rslvr] z32cstr.wire: vgain[0].Z
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: vgain[4].Z
[rslvr] z32cstr.wire: iadd[2].OUT
[rslvr] z32cstr.wire: mm[3].XY0
[rslvr] z32cstr.wire: mm[3].kr
[rslvr] z32cstr.wire: mm[3].Xtot
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: vgain[0].P
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vgain[4].P
[rslvr] z32cstr.wire: mm[3].XY
[rslvr] z32cstr.wire: vgain[5].X
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vgain[4].X
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: switch[0].SUB
[rslvr] z32cstr.wire: iadd[6].OUT
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vgain[0].X
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: switch[0].PROD
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: mm[3].X
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: iadd[6].A
[rslvr] z32cstr.wire: switch[0].n
[rslvr] z32cstr.wire: iadd[6].C
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: mm[3].kf
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: switch[0].Kmod
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: switch[0].Vmax
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: mm[3].Y
[rslvr] z32cstr.wire: vdadd[1].B
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: input.V[9].O
[rslvr] z32cstr.wire: vgain[5].Z
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: input.I[8].O
[rslvr] z32cstr.wire: input.V[4].O
->input.I[3]
->input.I[4]
->mm[3]
->input.I[8]
->output.V[3]
->input.I[5]
->input.V[4]
->vtoi[2]
->input.I[1]
->vgain[4]
->vdadd[1]
->input.I[7]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->switch[0]
->input.V[1]
->input.V[5]
->input.V[9]
->output.V[1]
->input.V[3]
->input.V[8]
->input.I[6]
->iadd[2]
->input.I[0]
->output.V[2]
->vgain[5]
->input.V[0]
->iadd[6]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (73) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=29

[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 80
[multi] # partial ids = 2
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] itov[0] cfg-in Y=(0.21*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=0.21
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 0.21
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ==== ROUTES =====
[multi] > iadd[6].B = Etot
[multi]    - making an input block.
[multi] > iadd[2].B = Stot
[multi]    - making an input block.
[multi] > iadd[6].C = P
[multi]    - connecting generates to routes.
[multi] > iadd[2].C = P
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > mm[3].kf = 3.154
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].B = 0
[multi]    - making an input block.
[multi] > vdadd[1].D = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[6].A = 0
[multi]    - making an input block.
[multi] > mm[3].XY0 = 0
[multi]    - making an input block.
[multi] > itov[0].X = 0.21
[multi]    - making an input block.
[multi] > mm[3].kr = 2.525
[multi]    - making an input block.
[multi] > vgain[5].X = 1
[multi]    - making an input block.
[multi] > vgain[4].X = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[3].Y = S
[multi]    - making an output block.
[multi] > vdadd[1].OUT = P
[multi]    - making an output block.
[multi] > mm[3].X = E
[multi]    - making an output block.
[multi] > mm[3].XY = ES
[multi]    - making an output block.
[multi] > itov[0].Y = (0.21*ES)
[multi] > itov[0].Y = (0.21*ES)
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 20
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] itov[0] cfg-in Y=(0.21*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=0.21
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 0.21
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=Etot
     [comp] input.I[0] cfg-out O=Etot
     [comp] input.I[1] cfg-in X=Stot
     [comp] input.I[1] cfg-out O=Stot
     [comp] input.I[2] cfg-in X=3.154
     [comp] input.I[2] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0
     [comp] input.V[0] cfg-out O=0
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.I[6] cfg-in X=0.21
     [comp] input.I[6] cfg-out O=0.21
     [comp] input.I[7] cfg-in X=2.525
     [comp] input.I[7] cfg-out O=2.525
     [comp] input.V[3] cfg-in X=1
     [comp] input.V[3] cfg-out O=1
     [comp] input.V[4] cfg-in X=1
     [comp] input.V[4] cfg-out O=1
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route iadd[6].B = Etot
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = Etot
     [sln] rm-route iadd[2].B = Stot
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = Stot
     [sln] rm-route iadd[6].C = P
     [sln] rm-route iadd[2].C = P
     [sln] rm-route itov[0].K = ES
     [sln] rm-route mm[3].kf = 3.154
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 3.154
     [sln] rm-route vdadd[1].OUT_0 = 0
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0
     [sln] rm-route vdadd[1].B = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].D = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[6].A = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route mm[3].XY0 = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route itov[0].X = 0.21
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0.21
     [sln] rm-route mm[3].kr = 2.525
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 2.525
     [sln] rm-route vgain[5].X = 1
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 1
     [sln] rm-route vgain[4].X = 1
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = Etot
     [sln] route input.I[1].X = Stot
     [sln] route input.I[2].X = 3.154
     [sln] route input.V[0].X = 0
     [sln] route input.V[1].X = 0
     [sln] route input.I[3].X = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.I[6].X = 0.21
     [sln] route input.I[7].X = 2.525
     [sln] route input.V[3].X = 1
     [sln] route input.V[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.I2
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.V2
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [419] [CONN] input.I[0].O => iadd[6].B (Etot)
     add-goal [420] [CONN] input.I[1].O => iadd[2].B (Stot)
     add-goal [421] [CONN] vdadd[1].OUT => iadd[6].C (P)
     add-goal [422] [CONN] vdadd[1].OUT => iadd[2].C (P)
     add-goal [423] [CONN] mm[3].XY => itov[0].K (ES)
     add-goal [424] [CONN] input.I[2].O => mm[3].kf (3.154)
     add-goal [425] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
     add-goal [426] [CONN] input.V[1].O => vdadd[1].B (0)
     add-goal [427] [CONN] input.I[3].O => vdadd[1].D (0)
     add-goal [428] [CONN] input.I[4].O => iadd[2].A (0)
     add-goal [429] [CONN] input.I[5].O => iadd[6].A (0)
     add-goal [430] [CONN] input.V[2].O => mm[3].XY0 (0)
     add-goal [431] [CONN] input.I[6].O => itov[0].X (0.21)
     add-goal [432] [CONN] input.I[7].O => mm[3].kr (2.525)
     add-goal [433] [CONN] input.V[3].O => vgain[5].X (1)
     add-goal [434] [CONN] input.V[4].O => vgain[4].X (1)
     add-goal [435] [CONN] mm[3].Y => output.V[0].X (S)
     add-goal [436] [CONN] vdadd[1].OUT => output.V[1].X (P)
     add-goal [437] [CONN] mm[3].X => output.V[2].X (E)
     add-goal [438] [CONN] mm[3].XY => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[431] [CONN] input.I[6].O => itov[0].X (0.21)
[426] [CONN] input.V[1].O => vdadd[1].B (0)
[433] [CONN] input.V[3].O => vgain[5].X (1)
[437] [CONN] mm[3].X => output.V[2].X (E)
[429] [CONN] input.I[5].O => iadd[6].A (0)
[432] [CONN] input.I[7].O => mm[3].kr (2.525)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[420] [CONN] input.I[1].O => iadd[2].B (Stot)
[425] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
[435] [CONN] mm[3].Y => output.V[0].X (S)
[422] [CONN] vdadd[1].OUT => iadd[2].C (P)
[428] [CONN] input.I[4].O => iadd[2].A (0)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[421] [CONN] vdadd[1].OUT => iadd[6].C (P)
[438] [CONN] mm[3].XY => output.V[3].X (ES)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[419] [CONN] input.I[0].O => iadd[6].B (Etot)
[424] [CONN] input.I[2].O => mm[3].kf (3.154)
[436] [CONN] vdadd[1].OUT => output.V[1].X (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[423] [CONN] mm[3].XY => itov[0].K (ES)
[434] [CONN] input.V[4].O => vgain[4].X (1)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[427] [CONN] input.I[3].O => vdadd[1].D (0)
[430] [CONN] input.V[2].O => mm[3].XY0 (0)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [430] [CONN] input.V[2].O => mm[3].XY0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[422] [CONN] vdadd[1].OUT => iadd[2].C (P)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[421] [CONN] vdadd[1].OUT => iadd[6].C (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[423] [CONN] mm[3].XY => itov[0].K (ES)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [423] [CONN] mm[3].XY => itov[0].K (ES)
vgain.P || # ins: 2 / connected / V ?= V/distance=0
vgain.P -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn] ==== vgain====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: P=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vgain====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: P=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Z=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->itov.K
[eqn] -> [valid?] testing node 5
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[422] [CONN] vdadd[1].OUT => iadd[2].C (P)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[421] [CONN] vdadd[1].OUT => iadd[6].C (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[440] [CONN] mm[3].XY => vgain[6].Z (ES)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [440] [CONN] mm[3].XY => vgain[6].Z (ES)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->vgain.Z
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[422] [CONN] vdadd[1].OUT => iadd[2].C (P)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[421] [CONN] vdadd[1].OUT => iadd[6].C (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [421] [CONN] vdadd[1].OUT => iadd[6].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 9
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[443] [CONN] vdadd[1].OUT => vtoi[0].X (P)
[422] [CONN] vdadd[1].OUT => iadd[2].C (P)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [422] [CONN] vdadd[1].OUT => iadd[2].C (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[422] [CONN] vdadd[1].OUT => iadd[2].C (P)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [422] [CONN] vdadd[1].OUT => iadd[2].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 13
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[446] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [446] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 14
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=30

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = Etot
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = Stot
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[6].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[7].X = 2.525
[multi]     - ignoring route to input block.
[multi] > vtoi[1].K = 1
[multi]    - making an input block.
[multi] > vtoi[0].K = 1
[multi]    - making an input block.
[multi] > vgain[6].X = 1
[multi]    - making an input block.
[multi] > input.V[3].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 1
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > input.I[0].O = Etot
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = Stot
[multi]     - ignoring generate to input block.
[multi] > mm[3].Y = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > mm[3].X = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > mm[3].XY = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[2].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[6].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[7].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 1
[multi]     - ignoring generate to input block.
[multi] > itov[0].Y = (0.21*ES)
[multi] > itov[0].Y = (0.21*ES)
[multi] > vtoi[0].Y = P
[multi] > vtoi[1].Y = P
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[6].P = ES
[multi] --> Number of options 3
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[5] cfg-in X=1
     [comp] input.V[5] cfg-out O=1
     [comp] input.V[6] cfg-in X=1
     [comp] input.V[6] cfg-out O=1
     [comp] input.V[7] cfg-in X=1
     [comp] input.V[7] cfg-out O=1
     [sln] rm-route vtoi[1].K = 1
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 1
     [sln] rm-route vtoi[0].K = 1
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 1
     [sln] rm-route vgain[6].X = 1
     [sln] add-comp input.V[7]
     [sln] generate input.V[7].O = 1
     [sln] route input.V[5].X = 1
     [sln] route input.V[6].X = 1
     [sln] route input.V[7].X = 1
     [comp] make-comp input.V5
     [comp] make-comp input.V6
     [comp] make-comp input.V7
     add-goal [447] [CONN] input.V[5].O => vtoi[1].K (1)
     add-goal [448] [CONN] input.V[6].O => vtoi[0].K (1)
     add-goal [449] [CONN] input.V[7].O => vgain[6].X (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[422] [CONN] vdadd[1].OUT => iadd[2].C (P)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[421] [CONN] vdadd[1].OUT => iadd[6].C (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[439] [CONN] mm[3].XY => vgain[6].X (ES)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [439] [CONN] mm[3].XY => vgain[6].X (ES)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->vgain.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 12
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[445] [CONN] vdadd[1].OUT => switch[1].Vmax (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [445] [CONN] vdadd[1].OUT => switch[1].Vmax (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 17
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=31

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 11
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = Etot
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = Stot
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 3.154
[multi]     - ignoring route to input block.
[multi] > switch[1].n = 0
[multi]    - making an input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[6].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[7].X = 2.525
[multi]     - ignoring route to input block.
[multi] > vtoi[0].K = 1
[multi]    - making an input block.
[multi] > vgain[6].X = 1
[multi]    - making an input block.
[multi] > input.V[3].X = 1
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 1
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > input.I[0].O = Etot
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = Stot
[multi]     - ignoring generate to input block.
[multi] > mm[3].Y = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > mm[3].X = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > mm[3].XY = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[2].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[6].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[7].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 1
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 1
[multi]     - ignoring generate to input block.
[multi] > itov[0].Y = (0.21*ES)
[multi] > itov[0].Y = (0.21*ES)
[multi] > vtoi[0].Y = P
[multi] > switch[1].PROD = P
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[6].P = ES
[multi] --> Number of options 3
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[8] cfg-in X=0
     [comp] input.V[8] cfg-out O=0
     [comp] input.V[9] cfg-in X=1
     [comp] input.V[9] cfg-out O=1
     [comp] input.V[10] cfg-in X=1
     [comp] input.V[10] cfg-out O=1
     [sln] rm-route switch[1].n = 0
     [sln] add-comp input.V[8]
     [sln] generate input.V[8].O = 0
     [sln] rm-route vtoi[0].K = 1
     [sln] add-comp input.V[9]
     [sln] generate input.V[9].O = 1
     [sln] rm-route vgain[6].X = 1
     [sln] add-comp input.V[10]
     [sln] generate input.V[10].O = 1
     [sln] route input.V[8].X = 0
     [sln] route input.V[9].X = 1
     [sln] route input.V[10].X = 1
     [comp] make-comp input.V8
     [comp] make-comp input.V9
     [comp] make-comp input.V10
     add-goal [450] [CONN] input.V[8].O => switch[1].n (0)
     add-goal [451] [CONN] input.V[9].O => vtoi[0].K (1)
     add-goal [452] [CONN] input.V[10].O => vgain[6].X (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[451] [CONN] input.V[9].O => vtoi[0].K (1)
[450] [CONN] input.V[8].O => switch[1].n (0)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[452] [CONN] input.V[10].O => vgain[6].X (1)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [452] [CONN] input.V[10].O => vgain[6].X (1)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 19
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=32

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 11
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: ES~127P~61 :: 19
[multi] Number of Solutions: 3
[multi] => Global Solution: ES~127P~25 :: 19
[multi] => Global Solution: ES~127P~59 :: 24
[multi] => Global Solution: ES~127P~27 :: 19
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: ES~127P~61 :: 19
[[Z3]] ---> Executing SMT Solver prob=33

[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: vgain[5].Z
[rslvr] z32cstr.wire: mm[3].Ytot
[rslvr] z32cstr.wire: vgain[5].P
[rslvr] z32cstr.wire: mm[3].kr
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: mm[3].XY0
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: mm[3].Xtot
[rslvr] z32cstr.wire: mm[3].XY
[rslvr] z32cstr.wire: vdadd[1].B
[rslvr] z32cstr.wire: switch[1].PROD
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vgain[4].P
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: vgain[4].X
[rslvr] z32cstr.wire: input.V[10].O
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: iadd[6].A
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vtoi[0].Y
[rslvr] z32cstr.wire: mm[3].X
[rslvr] z32cstr.wire: input.V[9].O
[rslvr] z32cstr.wire: mm[3].Y
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vtoi[0].K
[rslvr] z32cstr.wire: mm[3].kf
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: iadd[6].C
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: iadd[6].B
[rslvr] z32cstr.wire: switch[1].n
[rslvr] z32cstr.wire: vgain[4].Z
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: iadd[6].OUT
[rslvr] z32cstr.wire: vtoi[0].X
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: vgain[5].X
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: switch[1].Vmax
[rslvr] z32cstr.wire: iadd[2].OUT
[rslvr] z32cstr.wire: input.V[4].O
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_3_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_3_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_3_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_3_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=34

[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: vgain[5].Z
[rslvr] z32cstr.wire: mm[3].Ytot
[rslvr] z32cstr.wire: vgain[5].P
[rslvr] z32cstr.wire: mm[3].kr
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: mm[3].XY0
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: mm[3].Xtot
[rslvr] z32cstr.wire: mm[3].XY
[rslvr] z32cstr.wire: vdadd[1].B
[rslvr] z32cstr.wire: switch[1].PROD
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vgain[4].P
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: vgain[4].X
[rslvr] z32cstr.wire: input.V[10].O
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: iadd[6].A
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vtoi[0].Y
[rslvr] z32cstr.wire: mm[3].X
[rslvr] z32cstr.wire: input.V[9].O
[rslvr] z32cstr.wire: mm[3].Y
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vtoi[0].K
[rslvr] z32cstr.wire: mm[3].kf
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: iadd[6].C
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: iadd[6].B
[rslvr] z32cstr.wire: switch[1].n
[rslvr] z32cstr.wire: vgain[4].Z
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: iadd[6].OUT
[rslvr] z32cstr.wire: vtoi[0].X
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: vgain[5].X
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: switch[1].Vmax
[rslvr] z32cstr.wire: iadd[2].OUT
[rslvr] z32cstr.wire: input.V[4].O
->vgain[6]
->input.I[3]
->input.I[4]
->mm[3]
->output.V[3]
->input.V[10]
->input.I[5]
->input.V[4]
->input.I[1]
->itov[0]
->vgain[4]
->vdadd[1]
->input.I[2]
->input.I[7]
->input.V[2]
->output.V[0]
->vtoi[0]
->input.V[1]
->switch[1]
->input.V[9]
->output.V[1]
->input.V[3]
->input.V[8]
->input.I[6]
->iadd[2]
->input.I[0]
->output.V[2]
->vgain[5]
->input.V[0]
->iadd[6]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (74) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=35

[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 80
[multi] # partial ids = 2
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] itov[0] cfg-in Y=(0.21*ES)
   [comp] itov[0] cfg-in X=ES
   [comp] itov[0] cfg-in K=0.21
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route itov[0].X = ES
   [sln] route itov[0].K = 0.21
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ==== ROUTES =====
[multi] > iadd[6].B = Etot
[multi]    - making an input block.
[multi] > iadd[2].B = Stot
[multi]    - making an input block.
[multi] > iadd[6].C = P
[multi]    - connecting generates to routes.
[multi] > iadd[2].C = P
[multi]    - connecting generates to routes.
[multi] > itov[0].X = ES
[multi]    - connecting generates to routes.
[multi] > mm[3].kf = 3.154
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].B = 0
[multi]    - making an input block.
[multi] > vdadd[1].D = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[6].A = 0
[multi]    - making an input block.
[multi] > mm[3].XY0 = 0
[multi]    - making an input block.
[multi] > itov[0].K = 0.21
[multi]    - making an input block.
[multi] > mm[3].kr = 2.525
[multi]    - making an input block.
[multi] > vgain[5].X = 1
[multi]    - making an input block.
[multi] > vgain[4].X = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > mm[3].Y = S
[multi]    - making an output block.
[multi] > vdadd[1].OUT = P
[multi]    - making an output block.
[multi] > mm[3].X = E
[multi]    - making an output block.
[multi] > mm[3].XY = ES
[multi]    - making an output block.
[multi] > itov[0].Y = (0.21*ES)
[multi] > itov[0].Y = (0.21*ES)
[multi] > vgain[5].P = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[6].OUT = (Etot+(-1*P))
[multi] > iadd[2].OUT = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] > vgain[4].P = ((-1*P)+Stot)
[multi] --> Number of options 20
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   remove-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   remove-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   remove-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   remove-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   remove-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   remove-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   remove-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))
   [comp] itov[0] cfg-in Y=(0.21*ES)
   [comp] itov[0] cfg-in X=ES
   [comp] itov[0] cfg-in K=0.21
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=P
   [comp] vdadd[1] cfg-param BSW=1
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in B=0
   [comp] vdadd[1] cfg-in A=(0.21*ES)
   [comp] vdadd[1] cfg-in D=0
   [comp] iadd[2] cfg-in OUT=((-1*P)+Stot)
   [comp] iadd[2] cfg-in A=0
   [comp] iadd[2] cfg-in B=Stot
   [comp] iadd[2] cfg-in C=P
   [comp] mm[3] cfg-in XY0=0
   [comp] mm[3] cfg-in XY=ES
   [comp] mm[3] cfg-in Xtot=(Etot+(-1*P))
   [comp] mm[3] cfg-in Ytot=((-1*P)+Stot)
   [comp] mm[3] cfg-in Y=S
   [comp] mm[3] cfg-in X=E
   [comp] mm[3] cfg-in kf=3.154
   [comp] mm[3] cfg-in kr=2.525
   [comp] vgain[4] cfg-in P=((-1*P)+Stot)
   [comp] vgain[4] cfg-in Z=((-1*P)+Stot)
   [comp] vgain[4] cfg-in X=1
   [comp] vgain[5] cfg-in P=(Etot+(-1*P))
   [comp] vgain[5] cfg-in Z=(Etot+(-1*P))
   [comp] vgain[5] cfg-in X=1
   [comp] iadd[6] cfg-in OUT=(Etot+(-1*P))
   [comp] iadd[6] cfg-in A=0
   [comp] iadd[6] cfg-in B=Etot
   [comp] iadd[6] cfg-in C=P
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (0.21*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = P
   [sln] add-comp vdadd[1]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] add-comp iadd[2]
   [sln] generate iadd[2].OUT = ((-1*P)+Stot)
   [sln] conn iadd[2].OUT->vgain[4].Z
   [sln] generate mm[3].XY = ES
   [sln] generate mm[3].Y = S
   [sln] generate mm[3].X = E
   [sln] add-comp mm[3]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] add-comp vgain[4]
   [sln] generate vgain[4].P = ((-1*P)+Stot)
   [sln] conn vgain[4].P->mm[3].Ytot
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (Etot+(-1*P))
   [sln] conn vgain[5].P->mm[3].Xtot
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] add-comp iadd[6]
   [sln] generate iadd[6].OUT = (Etot+(-1*P))
   [sln] conn iadd[6].OUT->vgain[5].Z
   [sln] route itov[0].X = ES
   [sln] route itov[0].K = 0.21
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].B = 0
   [sln] route vdadd[1].D = 0
   [sln] route iadd[2].A = 0
   [sln] route iadd[2].B = Stot
   [sln] route iadd[2].C = P
   [sln] route mm[3].XY0 = 0
   [sln] route mm[3].kf = 3.154
   [sln] route mm[3].kr = 2.525
   [sln] route vgain[4].X = 1
   [sln] route vgain[5].X = 1
   [sln] route iadd[6].A = 0
   [sln] route iadd[6].B = Etot
   [sln] route iadd[6].C = P
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp iadd2
   [comp] make-comp mm3
   [comp] make-comp vgain4
   [comp] make-comp vgain5
   [comp] make-comp iadd6
   change-goal-status 212 to disabled
   change-goal-status 213 to disabled
   change-goal-status 215 to disabled
   change-goal-status 216 to disabled
   change-goal-status 217 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   add-goal [212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [214] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [233] [EXPR]vdadd[1].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
   add-goal [1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
   add-goal [2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}
   add-goal [4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
   add-goal [5] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
   add-goal [121] [EXPR]mm[3].Xtot<V>=(Etot+(-1*P))
   add-goal [120] [EXPR]mm[3].Ytot<V>=((-1*P)+Stot)
   add-goal [127] [EXPR]vgain[4].Z<I>=((-1*P)+Stot)
   add-goal [133] [EXPR]vgain[5].Z<I>=(Etot+(-1*P))

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=Etot
     [comp] input.I[0] cfg-out O=Etot
     [comp] input.I[1] cfg-in X=Stot
     [comp] input.I[1] cfg-out O=Stot
     [comp] input.I[2] cfg-in X=3.154
     [comp] input.I[2] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0
     [comp] input.V[0] cfg-out O=0
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0.21
     [comp] input.V[3] cfg-out O=0.21
     [comp] input.I[6] cfg-in X=2.525
     [comp] input.I[6] cfg-out O=2.525
     [comp] input.V[4] cfg-in X=1
     [comp] input.V[4] cfg-out O=1
     [comp] input.V[5] cfg-in X=1
     [comp] input.V[5] cfg-out O=1
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route iadd[6].B = Etot
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = Etot
     [sln] rm-route iadd[2].B = Stot
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = Stot
     [sln] rm-route iadd[6].C = P
     [sln] rm-route iadd[2].C = P
     [sln] rm-route itov[0].X = ES
     [sln] rm-route mm[3].kf = 3.154
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 3.154
     [sln] rm-route vdadd[1].OUT_0 = 0
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0
     [sln] rm-route vdadd[1].B = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].D = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[6].A = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route mm[3].XY0 = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route itov[0].K = 0.21
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.21
     [sln] rm-route mm[3].kr = 2.525
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 2.525
     [sln] rm-route vgain[5].X = 1
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 1
     [sln] rm-route vgain[4].X = 1
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = Etot
     [sln] route input.I[1].X = Stot
     [sln] route input.I[2].X = 3.154
     [sln] route input.V[0].X = 0
     [sln] route input.V[1].X = 0
     [sln] route input.I[3].X = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0.21
     [sln] route input.I[6].X = 2.525
     [sln] route input.V[4].X = 1
     [sln] route input.V[5].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.I2
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I6
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [453] [CONN] input.I[0].O => iadd[6].B (Etot)
     add-goal [454] [CONN] input.I[1].O => iadd[2].B (Stot)
     add-goal [455] [CONN] vdadd[1].OUT => iadd[6].C (P)
     add-goal [456] [CONN] vdadd[1].OUT => iadd[2].C (P)
     add-goal [457] [CONN] mm[3].XY => itov[0].X (ES)
     add-goal [458] [CONN] input.I[2].O => mm[3].kf (3.154)
     add-goal [459] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
     add-goal [460] [CONN] input.V[1].O => vdadd[1].B (0)
     add-goal [461] [CONN] input.I[3].O => vdadd[1].D (0)
     add-goal [462] [CONN] input.I[4].O => iadd[2].A (0)
     add-goal [463] [CONN] input.I[5].O => iadd[6].A (0)
     add-goal [464] [CONN] input.V[2].O => mm[3].XY0 (0)
     add-goal [465] [CONN] input.V[3].O => itov[0].K (0.21)
     add-goal [466] [CONN] input.I[6].O => mm[3].kr (2.525)
     add-goal [467] [CONN] input.V[4].O => vgain[5].X (1)
     add-goal [468] [CONN] input.V[5].O => vgain[4].X (1)
     add-goal [469] [CONN] mm[3].Y => output.V[0].X (S)
     add-goal [470] [CONN] vdadd[1].OUT => output.V[1].X (P)
     add-goal [471] [CONN] mm[3].X => output.V[2].X (E)
     add-goal [472] [CONN] mm[3].XY => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[462] [CONN] input.I[4].O => iadd[2].A (0)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[463] [CONN] input.I[5].O => iadd[6].A (0)
[468] [CONN] input.V[5].O => vgain[4].X (1)
[456] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[469] [CONN] mm[3].Y => output.V[0].X (S)
[471] [CONN] mm[3].X => output.V[2].X (E)
[460] [CONN] input.V[1].O => vdadd[1].B (0)
[470] [CONN] vdadd[1].OUT => output.V[1].X (P)
[472] [CONN] mm[3].XY => output.V[3].X (ES)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[465] [CONN] input.V[3].O => itov[0].K (0.21)
[467] [CONN] input.V[4].O => vgain[5].X (1)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[461] [CONN] input.I[3].O => vdadd[1].D (0)
[466] [CONN] input.I[6].O => mm[3].kr (2.525)
[453] [CONN] input.I[0].O => iadd[6].B (Etot)
[459] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[454] [CONN] input.I[1].O => iadd[2].B (Stot)
[455] [CONN] vdadd[1].OUT => iadd[6].C (P)
[458] [CONN] input.I[2].O => mm[3].kf (3.154)
[464] [CONN] input.V[2].O => mm[3].XY0 (0)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [464] [CONN] input.V[2].O => mm[3].XY0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->mm.XY0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kf
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->mm.kr
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.XY->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.X->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>mm.Y->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[456] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[455] [CONN] vdadd[1].OUT => iadd[6].C (P)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [455] [CONN] vdadd[1].OUT => iadd[6].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 6
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[475] [CONN] vdadd[1].OUT => vtoi[0].X (P)
[456] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [456] [CONN] vdadd[1].OUT => iadd[2].C (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 7
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[456] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [456] [CONN] vdadd[1].OUT => iadd[2].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 10
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[478] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [478] [CONN] vdadd[1].OUT => vtoi[1].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 11
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [457] [CONN] mm[3].XY => itov[0].X (ES)
switch.PROD || # ins: 4 / connected / I ?= I/distance=1
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=1
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=1
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=1
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  0 <<<
[eqn] //NO-SOLS// ===> Found no solutions
[slvrsearch] > weight++: <conn-ports-goal>mm.XY->itov.X
[eqn] -> [valid?] testing node 9
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[477] [CONN] vdadd[1].OUT => switch[1].Vmax (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [477] [CONN] vdadd[1].OUT => switch[1].Vmax (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 12
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [457] [CONN] mm[3].XY => itov[0].X (ES)
switch.PROD || # ins: 4 / connected / I ?= I/distance=1
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=1
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=1
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=1
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  0 <<<
[eqn] //NO-SOLS// ===> Found no solutions
[slvrsearch] > weight++: <conn-ports-goal>mm.XY->itov.X
[eqn] -> [valid?] testing node 8
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[476] [CONN] vdadd[1].OUT => switch[1].Vmax (P)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [476] [CONN] vdadd[1].OUT => switch[1].Vmax (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 13
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [457] [CONN] mm[3].XY => itov[0].X (ES)
switch.PROD || # ins: 4 / connected / I ?= I/distance=1
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=1
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=1
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=1
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  0 <<<
[eqn] //NO-SOLS// ===> Found no solutions
[slvrsearch] > weight++: <conn-ports-goal>mm.XY->itov.X
[eqn] -> [valid?] testing node 5
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[456] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[474] [CONN] vdadd[1].OUT => switch[0].Vmax (P)
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [474] [CONN] vdadd[1].OUT => switch[0].Vmax (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 14
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[456] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [456] [CONN] vdadd[1].OUT => iadd[2].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 17
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[481] [CONN] vdadd[1].OUT => vtoi[2].X (P)
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [481] [CONN] vdadd[1].OUT => vtoi[2].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 18
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [457] [CONN] mm[3].XY => itov[0].X (ES)
switch.PROD || # ins: 4 / connected / I ?= I/distance=1
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=1
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=1
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=1
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  0 <<<
[eqn] //NO-SOLS// ===> Found no solutions
[slvrsearch] > weight++: <conn-ports-goal>mm.XY->itov.X
[eqn] -> [valid?] testing node 16
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[480] [CONN] vdadd[1].OUT => switch[2].Vmax (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [480] [CONN] vdadd[1].OUT => switch[2].Vmax (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 19
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [457] [CONN] mm[3].XY => itov[0].X (ES)
switch.PROD || # ins: 4 / connected / I ?= I/distance=1
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=1
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=1
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=1
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  0 <<<
[eqn] //NO-SOLS// ===> Found no solutions
[slvrsearch] > weight++: <conn-ports-goal>mm.XY->itov.X
[eqn] -> [valid?] testing node 15
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[479] [CONN] vdadd[1].OUT => switch[2].Vmax (P)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [479] [CONN] vdadd[1].OUT => switch[2].Vmax (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 20
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [457] [CONN] mm[3].XY => itov[0].X (ES)
switch.PROD || # ins: 4 / connected / I ?= I/distance=1
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=1
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=1
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=1
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  0 <<<
[eqn] //NO-SOLS// ===> Found no solutions
[slvrsearch] > weight++: <conn-ports-goal>mm.XY->itov.X
[eqn] -> [valid?] testing node 4
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[473] [CONN] vdadd[1].OUT => switch[0].Vmax (P)
[456] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [456] [CONN] vdadd[1].OUT => iadd[2].C (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 21
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[456] [CONN] vdadd[1].OUT => iadd[2].C (P)
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [456] [CONN] vdadd[1].OUT => iadd[2].C (P)
switch.PROD || # ins: 4 / connected / I ?= I/distance=0
switch.PROD -> true
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=0
ihill_stim.STIM -> true
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=0
ihill_rep.REP -> true
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=0
vtoi.Y -> true
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  4 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 14 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Vmax=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== switch====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: PROD=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: SUB=(__tmp__+-1)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== ihill_stim====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: STIM=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn] ==== ihill_rep====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: REP=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: Vmax=(2*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: X=__tmp__
[eqn]     -> converted to 10 ssteps
[eqn] ==== vtoi====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: Y=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: K=(__tmp__^-1)
[eqn]     -> failed to convert unify steps
[eqn] [FOUND-SOLS] ===> Found <3> solutions
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->iadd.C
[eqn] -> [valid?] testing node 24
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[484] [CONN] vdadd[1].OUT => vtoi[3].X (P)
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [484] [CONN] vdadd[1].OUT => vtoi[3].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 25
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [457] [CONN] mm[3].XY => itov[0].X (ES)
switch.PROD || # ins: 4 / connected / I ?= I/distance=1
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=1
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=1
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=1
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  0 <<<
[eqn] //NO-SOLS// ===> Found no solutions
[slvrsearch] > weight++: <conn-ports-goal>mm.XY->itov.X
[eqn] -> [valid?] testing node 23
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[483] [CONN] vdadd[1].OUT => switch[3].Vmax (P)
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [483] [CONN] vdadd[1].OUT => switch[3].Vmax (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 26
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [457] [CONN] mm[3].XY => itov[0].X (ES)
switch.PROD || # ins: 4 / connected / I ?= I/distance=1
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=1
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=1
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=1
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  0 <<<
[eqn] //NO-SOLS// ===> Found no solutions
[slvrsearch] > weight++: <conn-ports-goal>mm.XY->itov.X
[eqn] -> [valid?] testing node 22
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[482] [CONN] vdadd[1].OUT => switch[3].Vmax (P)
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [482] [CONN] vdadd[1].OUT => switch[3].Vmax (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 27
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[457] [CONN] mm[3].XY => itov[0].X (ES)
[2] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.0294] / [P]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[216] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[212] [MATH]output S :> S=(Stot-ES-P) / std(S) = gauss (0.04*S) {[S]=[0.,0.3]}
[217] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.3535,0.132468] / [ES]=[0.,0.14] / max-sample = <none>min-speed = <none>}
[213] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[4] [MATH]input Stot :> <input> {[Stot]=[0.,0.256]}
[1] [MATH]input Etot :> <input> {[Etot]=[0.,0.124]}
[215] [MATH]output E :> E=(Etot-ES-P) / std(E) = gauss (0.04*E) {[E]=[0.,0.14]}

============
>> Current Goal: [457] [CONN] mm[3].XY => itov[0].X (ES)
switch.PROD || # ins: 4 / connected / I ?= I/distance=1
ihill_stim.STIM || # ins: 4 / connected / I ?= I/distance=1
ihill_rep.REP || # ins: 4 / connected / I ?= I/distance=1
ihill_rep2.REP2 || # ins: 3 / connected / I ?= I/distance=1
vtoi.Y || # ins: 2 / connected / I ?= I/distance=1
igenebind.GE || # ins: 3 / connected / I ?= I/distance=1
iadd.OUT || # ins: 3 / connected / I ?= I/distance=1
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  0 <<<
[eqn] //NO-SOLS// ===> Found no solutions
[slvrsearch] > weight++: <conn-ports-goal>mm.XY->itov.X
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found NO Solutions.
[multi]    xx let's kill this branch
[multi] [search_tree] is exhausted
[multi] # Found 4, Required: 1
[multi] [DONE] found enough solutions
[multi] ===== Getting Solutions =====
[multi] Number of Solutions: 4
[multi] => Global Solution: ES~127P~61 :: 19
[multi] => Global Solution: ES~127P~25 :: 19
[multi] => Global Solution: ES~127P~59 :: 24
[multi] => Global Solution: ES~127P~27 :: 19
