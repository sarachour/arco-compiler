==== Loaded Config File (benchmarks/biology_nojaunt/configs/prod.cfg) ====
bool enable-jaunt false
int multi-num-global-solutions 1
bool eqn-use-map-heuristic true
int slvr-solutions 1
string multi-selector-branch solved-and-ncomps
int multi-num-global-solutions-per-partial 1
int slvr-partial-depth 15
int interactive 0
int eqn-unifications 12
int multi-num-partial-solutions 1
int map-infer-feasible-timeout 60
int slvr-global-depth 30
int debug 2
string eqn-selector-goal trivial
int z3-minimize-depth 4
int uast-depth 5
string uast-selector-branch uniform
bool _force false
string z3-minimize-strategy binary
string eqn-selector-branch goals
=================================
======== Infer Math Vars =============
derive: umodif -> [0.,15.6]
derive: VTF -> [0.802409638554,13.32]
derive: V -> [-12.5175903614,13.32]
derive: UTF -> [0.0240543630064,15.6]
derive: U -> [-15.575945637,15.6]
inference hw vars
-> derived [0.,5000.] -> P
-> derived [0.,10.] -> PROD
-> derived [0.,3300.] -> Y
-> derived [0.,10.] -> REP2
-> derived [0.,1.] -> Y
-> derived [0.,80000.] -> REP
-> derived [0.,1000000.] -> STIM
-> derived [0.,10.] -> Y
-> derived {[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } -> OUT
-> derived [0.,10.] -> Y
-> derived [-5.,10.] -> OUT
-> derived [0.,10.] -> GE
==== Units ====
==== Vars =====
> MAKE vgain
input(<vgain,X>)
cover
input(<vgain,Z>)
cover
output(<vgain,P>)
cover
>
>
offset(<vgain,X>)=0
offset(<vgain,Z>)=0
ve(scale(<vgain,P>)=scale(<vgain,X>)*scale(<vgain,Z>))
offset(<vgain,P>)=0
>>> # Partitions vgain=3
> MAKE switch
input(<switch,n>)
cover
input(<switch,SUB>)
cover
input(<switch,Kmod>)
cover
input(<switch,Vmax>)
cover
output(<switch,PROD>)
cover
>
>
offset(<switch,SUB>)=0
offset(<switch,Kmod>)=0
ee(scale(<switch,Kmod>)^-1*scale(<switch,SUB>)=scale(<switch,Kmod>)^-1*scale(<switch,SUB>))
ee(1=scale(<switch,Kmod>)^-1*scale(<switch,SUB>))
ee(scale(<switch,Kmod>)^-1*scale(<switch,SUB>)=1)
ee(1=1)
>
offset(<switch,n>)=0
valid
ec(0+0=0)
valid
ec(scale(<switch,n>)/1=1)
valid
valid
>
offset(<switch,Vmax>)=0
valid
ve(scale(<switch,PROD>)=1/1^(switch.V{n}:/500.)*scale(<switch,Vmax>))
offset(<switch,PROD>)=0
>>> # Partitions switch=4
> MAKE ihill_stim
input(<ihill_stim,n>)
cover
input(<ihill_stim,S>)
cover
input(<ihill_stim,Km>)
cover
input(<ihill_stim,Vmax>)
cover
output(<ihill_stim,STIM>)
cover
>
>
offset(<ihill_stim,S>)=0
offset(<ihill_stim,Km>)=0
>
valid
offset(<ihill_stim,n>)=0
scale(<ihill_stim,n>)=1
>
>
offset(<ihill_stim,S>)=0
offset(<ihill_stim,Km>)=0
>
valid
offset(<ihill_stim,n>)=0
scale(<ihill_stim,n>)=1
ee(scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:=scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:)
ee(1=scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:)
ee(scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:=1)
ee(1=1)
valid
ec(0+0=0)
>
ve(scale(<ihill_stim,STIM>)=scale(<ihill_stim,Vmax>)*scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:/1)
offset(<ihill_stim,STIM>)=0
>>> # Partitions ihill_stim=4
> MAKE ihill_rep
input(<ihill_rep,n>)
cover
input(<ihill_rep,S>)
cover
input(<ihill_rep,Km>)
cover
input(<ihill_rep,Vmax>)
cover
output(<ihill_rep,REP>)
cover
>
>
offset(<ihill_rep,Km>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
>
>
offset(<ihill_rep,S>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
>
>
offset(<ihill_rep,Km>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
ee(scale(<ihill_rep,Km>)^ihill_rep.V{n}:=scale(<ihill_rep,Km>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,S>)^ihill_rep.V{n}:=scale(<ihill_rep,Km>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,Km>)^ihill_rep.V{n}:=scale(<ihill_rep,S>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,S>)^ihill_rep.V{n}:=scale(<ihill_rep,S>)^ihill_rep.V{n}:)
valid
ec(0+0=0)
>
offset(<ihill_rep,Vmax>)=0
valid
ve(scale(<ihill_rep,REP>)=scale(<ihill_rep,Km>)^ihill_rep.V{n}:/scale(<ihill_rep,S>)^ihill_rep.V{n}:*scale(<ihill_rep,Vmax>))
offset(<ihill_rep,REP>)=0
>>> # Partitions ihill_rep=4
> MAKE vdadd
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
valid
offset(<vdadd,D>)=0
offset(<vdadd,OUT>)=0
>
valid
offset(<vdadd,B>)=0
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=2
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
valid
offset(<vdadd,D>)=0
offset(<vdadd,OUT>)=0
>
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=3
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
>
valid
offset(<vdadd,B>)=0
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=3
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
>
>
>
>
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=4
> MAKE ihill_rep2
input(<ihill_rep2,n>)
cover
input(<ihill_rep2,S>)
cover
input(<ihill_rep2,Vmax>)
cover
output(<ihill_rep2,REP2>)
cover
>
>
offset(<ihill_rep2,S>)=0
offset(<ihill_rep2,n>)=0
scale(<ihill_rep2,n>)=1
ee(scale(<ihill_rep2,S>)^ihill_rep2.V{n}:=scale(<ihill_rep2,S>)^ihill_rep2.V{n}:)
ee(1=scale(<ihill_rep2,S>)^ihill_rep2.V{n}:)
ee(scale(<ihill_rep2,S>)^ihill_rep2.V{n}:=1)
ee(1=1)
valid
ec(0+0=0)
>
offset(<ihill_rep2,Vmax>)=0
valid
vv(scale(<ihill_rep2,REP2>)=scale(<ihill_rep2,Vmax>))
offset(<ihill_rep2,REP2>)=0
>>> # Partitions ihill_rep2=2
> MAKE input.I
input(<input.I,X>)
cover
output(<input.I,O>)
cover
>
vv(scale(<input.I,O>)=scale(<input.I,X>))
vv(offset(<input.I,O>)=offset(<input.I,X>))
>>> # Partitions input.I=2
> MAKE output.V
input(<output.V,X>)
cover
output(<output.V,O>)
cover
>
vv(scale(<output.V,O>)=scale(<output.V,X>))
vv(offset(<output.V,O>)=offset(<output.V,X>))
>>> # Partitions output.V=2
> MAKE copy.V
input(<copy.V,X>)
cover
output(<copy.V,Y>)
cover
>
vv(scale(<copy.V,Y>)=scale(<copy.V,X>))
vv(offset(<copy.V,Y>)=offset(<copy.V,X>))
>>> # Partitions copy.V=2
> MAKE vadd
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
valid
offset(<vadd,C>)=0
>
valid
offset(<vadd,B>)=0
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=3
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
valid
offset(<vadd,C>)=0
>
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=4
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
>
valid
offset(<vadd,B>)=0
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=4
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
>
>
>
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=5
> MAKE vtoi
input(<vtoi,X>)
cover
input(<vtoi,K>)
cover
output(<vtoi,Y>)
cover
>
>
valid
offset(<vtoi,K>)=0
valid
offset(<vtoi,X>)=0
ve(scale(<vtoi,Y>)=scale(<vtoi,K>)^-1*scale(<vtoi,X>))
offset(<vtoi,Y>)=0
>>> # Partitions vtoi=3
> MAKE igenebind
input(<igenebind,TF>)
cover
input(<igenebind,K>)
cover
input(<igenebind,Vmax>)
cover
output(<igenebind,GE>)
cover
>
>
offset(<igenebind,K>)=0
offset(<igenebind,TF>)=0
ee(1=1)
ee(scale(<igenebind,K>)*scale(<igenebind,TF>)=1)
ee(1=scale(<igenebind,K>)*scale(<igenebind,TF>))
ee(scale(<igenebind,K>)*scale(<igenebind,TF>)=scale(<igenebind,K>)*scale(<igenebind,TF>))
valid
ec(0+0=0)
>
offset(<igenebind,Vmax>)=0
valid
ve(scale(<igenebind,GE>)=scale(<igenebind,K>)^-1*scale(<igenebind,TF>)^-1*scale(<igenebind,Vmax>))
offset(<igenebind,GE>)=0
>>> # Partitions igenebind=4
> MAKE mm
input(<mm,kr>)
cover
input(<mm,XY0>)
cover
input(<mm,Ytot>)
cover
input(<mm,kf>)
cover
input(<mm,Xtot>)
cover
output(<mm,X>)
cover
output(<mm,XY>)
cover
XY
output(<mm,Y>)
cover
>
>
vv(scale(<mm,Xtot>)=scale(<mm,Xtot>))
vv(scale(<mm,XY>)=scale(<mm,Xtot>))
vv(scale(<mm,Xtot>)=scale(<mm,XY>))
vv(scale(<mm,XY>)=scale(<mm,XY>))
vv(scale(<mm,X>)=scale(<mm,Xtot>))
ve(offset(<mm,X>)=offset(<mm,XY>)+offset(<mm,Xtot>))
>
>
offset(<mm,kr>)=0
offset(<mm,XY>)=0
>
>
>
offset(<mm,kf>)=0
offset(<mm,X>)=0
offset(<mm,Y>)=0
ee(scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>)=scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>))
ee(scale(<mm,XY>)*scale(<mm,kr>)=scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>))
ee(scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>)=scale(<mm,XY>)*scale(<mm,kr>))
ee(scale(<mm,XY>)*scale(<mm,kr>)=scale(<mm,XY>)*scale(<mm,kr>))
ve(scale(<mm,XY>)=scale(<mm,XY>)*scale(<mm,kr>))
offset(<mm,XY>)=0
=
priority
offset(<mm,XY>)=0
vv(scale(<mm,XY>)=scale(<mm,XY0>))
vv(offset(<mm,XY>)=offset(<mm,XY0>))
>
>
vv(scale(<mm,Ytot>)=scale(<mm,Ytot>))
vv(scale(<mm,XY>)=scale(<mm,Ytot>))
vv(scale(<mm,Ytot>)=scale(<mm,XY>))
vv(scale(<mm,XY>)=scale(<mm,XY>))
vv(scale(<mm,Y>)=scale(<mm,Ytot>))
ve(offset(<mm,Y>)=offset(<mm,XY>)+offset(<mm,Ytot>))
>>> # Partitions mm=4
> MAKE input.V
input(<input.V,X>)
cover
output(<input.V,O>)
cover
>
vv(scale(<input.V,O>)=scale(<input.V,X>))
vv(offset(<input.V,O>)=offset(<input.V,X>))
>>> # Partitions input.V=2
> MAKE itov
input(<itov,X>)
cover
input(<itov,K>)
cover
output(<itov,Y>)
cover
>
>
offset(<itov,K>)=0
offset(<itov,X>)=0
ve(scale(<itov,Y>)=scale(<itov,K>)*scale(<itov,X>))
offset(<itov,Y>)=0
>>> # Partitions itov=3
> MAKE iadd
input(<iadd,C>)
cover
input(<iadd,A>)
cover
input(<iadd,B>)
cover
output(<iadd,OUT>)
cover
>
>
>
vv(scale(<iadd,A>)=scale(<iadd,A>))
vv(scale(<iadd,B>)=scale(<iadd,A>))
vv(scale(<iadd,A>)=scale(<iadd,B>))
vv(scale(<iadd,B>)=scale(<iadd,B>))
vv(scale(<iadd,A>)=scale(<iadd,A>))
vv(scale(<iadd,C>)=scale(<iadd,A>))
vv(scale(<iadd,A>)=scale(<iadd,C>))
vv(scale(<iadd,C>)=scale(<iadd,C>))
vv(scale(<iadd,OUT>)=scale(<iadd,A>))
ve(offset(<iadd,OUT>)=offset(<iadd,A>)+offset(<iadd,B>)+offset(<iadd,C>))
>>> # Partitions iadd=5
> MAKE output.I
input(<output.I,X>)
cover
output(<output.I,O>)
cover
>
vv(scale(<output.I,O>)=scale(<output.I,X>))
vv(offset(<output.I,O>)=offset(<output.I,X>))
>>> # Partitions output.I=2
> MAKE copy.I
input(<copy.I,X>)
cover
output(<copy.I,Y>)
cover
>
vv(scale(<copy.I,Y>)=scale(<copy.I,X>))
vv(offset(<copy.I,Y>)=offset(<copy.I,X>))
>>> # Partitions copy.I=2
=== mm ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<mm,Ytot>)

v(0) = exprs=v(0)+v(2)=v(0)+v(1)
cstrs==
value=0
mems=offset(<mm,XY0>),offset(<mm,Y>),offset(<mm,kf>),offset(<mm,XY>),offset(<mm,kr>),offset(<mm,X>)

v(3) = exprs=v(3)*v(3)*v(3)=v(3)*v(3)
cstrs=>
value=<none>
mems=scale(<mm,Ytot>),scale(<mm,Y>),scale(<mm,XY>),scale(<mm,XY0>),scale(<mm,kr>),scale(<mm,kf>),scale(<mm,Xtot>),scale(<mm,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<mm,Xtot>)


kr = string_of_map_port: unimpl
XY0 = string_of_map_port: unimpl
Ytot = string_of_map_port: unimpl
Xtot = string_of_map_port: unimpl
kf = string_of_map_port: unimpl

X = string_of_map_port: unimpl
XY = string_of_map_port: unimpl
Y = string_of_map_port: unimpl



=== vgain ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=0
mems=offset(<vgain,P>),offset(<vgain,Z>),offset(<vgain,X>)

v(0) = exprs=v(1)*v(1)
cstrs=
value=<none>
mems=scale(<vgain,P>)

v(1) = exprs=
cstrs=>
value=<none>
mems=scale(<vgain,Z>),scale(<vgain,X>)


X = string_of_map_port: unimpl
Z = string_of_map_port: unimpl

P = string_of_map_port: unimpl



=== vdadd ===
 = 
 = ====== #2 ======
v(2) = exprs=
cstrs==
value=0
mems=offset(<vdadd,D>),offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>)

v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,B>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,B>)

v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(3) = exprs=
cstrs==
value=0
mems=offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,D>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #3 ======
v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs==
value=0
mems=offset(<vdadd,D>),offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>),offset(<vdadd,B>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #1 ======
v(2) = exprs=
cstrs==
value=0
mems=offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>),offset(<vdadd,B>)

v(0) = exprs=v(0)*v(0)
cstrs=>
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,D>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vdadd,D>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== switch ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=>
value=<none>
mems=scale(<switch,n>),scale(<switch,Vmax>),scale(<switch,Kmod>),scale(<switch,SUB>)

v(0) = exprs=v(2)/1=v(2)^-1*v(2)
cstrs=
value=1
mems=

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<switch,SUB>),offset(<switch,n>),offset(<switch,Kmod>),offset(<switch,PROD>),offset(<switch,Vmax>)

v(1) = exprs=1/1^(switch.V{n}:/500.)*v(2)
cstrs=
value=<none>
mems=scale(<switch,PROD>)


SUB = string_of_map_port: unimpl
n = string_of_map_port: unimpl
Kmod = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

PROD = string_of_map_port: unimpl



=== itov ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=0
mems=offset(<itov,K>),offset(<itov,X>),offset(<itov,Y>)

v(0) = exprs=v(1)*v(1)
cstrs=
value=<none>
mems=scale(<itov,Y>)

v(1) = exprs=
cstrs=>
value=<none>
mems=scale(<itov,K>),scale(<itov,X>)


X = string_of_map_port: unimpl
K = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== output.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<output.I,O>),scale(<output.I,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<output.I,X>),offset(<output.I,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== input.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<input.V,X>),scale(<input.V,O>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<input.V,X>),offset(<input.V,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== output.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<output.V,X>),scale(<output.V,O>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<output.V,O>),offset(<output.V,X>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== ihill_rep2 ===
 = 
 = ====== #0 ======
v(0) = exprs=v(0)^ihill_rep2.V{n}:=1
cstrs=>
value=<none>
mems=scale(<ihill_rep2,n>),scale(<ihill_rep2,REP2>),scale(<ihill_rep2,Vmax>),scale(<ihill_rep2,S>)

v(1) = exprs=0+0
cstrs=
value=0
mems=offset(<ihill_rep2,Vmax>),offset(<ihill_rep2,S>),offset(<ihill_rep2,REP2>),offset(<ihill_rep2,n>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

REP2 = string_of_map_port: unimpl



=== copy.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<copy.V,Y>),scale(<copy.V,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<copy.V,X>),offset(<copy.V,Y>)


X = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== ihill_rep ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=>
value=1
mems=scale(<ihill_rep,Km>),scale(<ihill_rep,S>),scale(<ihill_rep,n>),scale(<ihill_rep,Vmax>)

v(0) = exprs=v(2)^ihill_rep.V{n}:=v(2)^ihill_rep.V{n}:
cstrs=
value=<none>
mems=

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<ihill_rep,n>),offset(<ihill_rep,REP>),offset(<ihill_rep,Km>),offset(<ihill_rep,S>),offset(<ihill_rep,Vmax>)

v(1) = exprs=v(2)^ihill_rep.V{n}:/v(2)^ihill_rep.V{n}:*v(2)
cstrs=
value=<none>
mems=scale(<ihill_rep,REP>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Km = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

REP = string_of_map_port: unimpl



=== ihill_stim ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<ihill_stim,Vmax>)

v(0) = exprs=v(0)/v(0)^ihill_stim.V{n}:=1
cstrs=>
value=<none>
mems=scale(<ihill_stim,S>),scale(<ihill_stim,n>),scale(<ihill_stim,Vmax>),scale(<ihill_stim,Km>)

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<ihill_stim,STIM>),offset(<ihill_stim,n>),offset(<ihill_stim,S>),offset(<ihill_stim,Km>)

v(1) = exprs=v(0)*v(0)/v(0)^ihill_stim.V{n}:/1
cstrs=
value=<none>
mems=scale(<ihill_stim,STIM>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Km = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

STIM = string_of_map_port: unimpl



=== vtoi ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=0
mems=offset(<vtoi,X>),offset(<vtoi,Y>),offset(<vtoi,K>)

v(0) = exprs=v(1)^-1*v(1)
cstrs=
value=<none>
mems=scale(<vtoi,Y>)

v(1) = exprs=
cstrs=>
value=<none>
mems=scale(<vtoi,X>),scale(<vtoi,K>)


X = string_of_map_port: unimpl
K = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== vadd ===
 = 
 = ====== #2 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,B>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(3) = exprs=
cstrs=
value=0
mems=offset(<vadd,C>),offset(<vadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(3) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,B>)

v(4) = exprs=v(2)+0+0
cstrs=
value=0
mems=offset(<vadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,C>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #3 ======
v(2) = exprs=v(1)+0+0
cstrs=
value=0
mems=offset(<vadd,B>),offset(<vadd,C>),offset(<vadd,OUT>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #1 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,A>)

v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(3) = exprs=v(2)+0+0
cstrs=
value=0
mems=offset(<vadd,B>),offset(<vadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<vadd,C>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== copy.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<copy.I,Y>),scale(<copy.I,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<copy.I,X>),offset(<copy.I,Y>)


X = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== iadd ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=offset(<iadd,A>)

v(0) = exprs=v(2)+v(1)+v(3)
cstrs=
value=<none>
mems=offset(<iadd,OUT>)

v(3) = exprs=
cstrs=
value=<none>
mems=offset(<iadd,C>)

v(4) = exprs=
cstrs=>
value=<none>
mems=scale(<iadd,OUT>),scale(<iadd,A>),scale(<iadd,B>),scale(<iadd,C>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<iadd,B>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== input.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=>
value=<none>
mems=scale(<input.I,O>),scale(<input.I,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=offset(<input.I,X>),offset(<input.I,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== igenebind ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=>
value=<none>
mems=scale(<igenebind,TF>),scale(<igenebind,Vmax>),scale(<igenebind,K>)

v(0) = exprs=1=v(2)*v(2)
cstrs=
value=<none>
mems=

v(3) = exprs=0+0
cstrs=
value=0
mems=offset(<igenebind,GE>),offset(<igenebind,K>),offset(<igenebind,Vmax>),offset(<igenebind,TF>)

v(1) = exprs=v(2)^-1*v(2)^-1*v(2)
cstrs=
value=<none>
mems=scale(<igenebind,GE>)


TF = string_of_map_port: unimpl
K = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

GE = string_of_map_port: unimpl



[multi] # Found 0, Required: 1
[multi] solving target: VTF
[multi] search tree is not exhausted. adding existing:VTF
[multi] finding new partial solution
[multi] made a partial tree with 7 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> Current Goal: [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
vgain.P -> true
switch.PROD -> true
ihill_stim.STIM -> true
ihill_rep.REP -> true
ihill_rep2.REP2 -> true
vadd.OUT -> true
vtoi.Y -> true
igenebind.GE -> true
mm.X -> true
mm.Y -> true
itov.Y -> true
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  12 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn] new: [0] <ihill_rep2> output REP2.I
<analog>:(ihill_rep2.I{Vmax}:*(1/((ihill_rep2.I{S}:^ihill_rep2.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <vadd> output OUT.V
<analog>:(((vadd.V{A}:+(vadd.BSW*vadd.V{B}:))-(vadd.CSW*vadd.V{C}:))*0.25) / std=gauss ((0.001*vadd.V{OUT}:)+0.1)
<analog> [v]={[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <igenebind> output GE.I
<analog>:(igenebind.I{Vmax}:*(1/(1+(igenebind.I{K}:*igenebind.I{TF}:)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <mm> output Y.V
<analog>:(mm.V{Ytot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <mm> output X.V
<analog>:(mm.V{Xtot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <itov> output Y.V
<analog>:(itov.V{K}:*itov.I{X}:) / std=gauss 0.1
<analog> [v]=[0.,3300.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] [FOUND-SOLS] ===> Found <102> solutions
[slvrsearch] > weight--: <mvar-goal>VTF
[eqn] -> [valid?] testing node 171
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=0

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 170
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=1

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 169
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=2

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 85
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=3

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 83
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=4

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 35
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=5

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 168
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 85 ==
[multi] == Adding Local Solution : 170 ==
[multi] == Adding Local Solution : 171 ==
[multi] == Adding Local Solution : 83 ==
[multi] == Adding Local Solution : 35 ==
[multi] == Adding Local Solution : 169 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] # partial ids = 1
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] ihill_rep2[0] cfg-in REP2=VTF
   [comp] ihill_rep2[0] cfg-in Vmax=13.32
   [comp] ihill_rep2[0] cfg-in S=umodif
   [comp] ihill_rep2[0] cfg-in n=1
   [sln] generate ihill_rep2[0].REP2 = VTF
   [sln] add-comp ihill_rep2[0]
   [sln] route ihill_rep2[0].Vmax = 13.32
   [sln] route ihill_rep2[0].S = umodif
   [sln] route ihill_rep2[0].n = 1
   [comp] make-comp ihill_rep20
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep2[0].S = umodif
[multi]    - connecting generates to routes.
[multi] > ihill_rep2[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep2[0].n = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > ihill_rep2[0].REP2 = VTF
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 24 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] ihill_rep2[0] cfg-in REP2=VTF
   [comp] ihill_rep2[0] cfg-in Vmax=13.32
   [comp] ihill_rep2[0] cfg-in S=umodif
   [comp] ihill_rep2[0] cfg-in n=1
   [sln] generate ihill_rep2[0].REP2 = VTF
   [sln] add-comp ihill_rep2[0]
   [sln] route ihill_rep2[0].Vmax = 13.32
   [sln] route ihill_rep2[0].S = umodif
   [sln] route ihill_rep2[0].n = 1
   [comp] make-comp ihill_rep20
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=13.32
     [comp] input.I[0] cfg-out O=13.32
     [comp] input.V[0] cfg-in X=1
     [comp] input.V[0] cfg-out O=1
     [sln] rm-route ihill_rep2[0].Vmax = 13.32
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 13.32
     [sln] rm-route ihill_rep2[0].n = 1
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 1
     [sln] route input.I[0].X = 13.32
     [sln] route input.V[0].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     add-goal [258] [CONN] input.I[0].O => ihill_rep2[0].Vmax (13.32)
     add-goal [259] [CONN] input.V[0].O => ihill_rep2[0].n (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[259] [CONN] input.V[0].O => ihill_rep2[0].n (1)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[258] [CONN] input.I[0].O => ihill_rep2[0].Vmax (13.32)
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> Current Goal: [258] [CONN] input.I[0].O => ihill_rep2[0].Vmax (13.32)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep2.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep2.n
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=6

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] # partial ids = 1
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [comp] make-comp igenebind0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > igenebind[0].GE = VTF
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 24 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [comp] make-comp igenebind0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=13.32
     [comp] input.I[0] cfg-out O=13.32
     [comp] input.I[1] cfg-in X=1
     [comp] input.I[1] cfg-out O=1
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 13.32
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 1
     [sln] route input.I[0].X = 13.32
     [sln] route input.I[1].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     add-goal [260] [CONN] input.I[0].O => igenebind[0].Vmax (13.32)
     add-goal [261] [CONN] input.I[1].O => igenebind[0].TF (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[261] [CONN] input.I[1].O => igenebind[0].TF (1)
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[260] [CONN] input.I[0].O => igenebind[0].Vmax (13.32)

============
>> Current Goal: [260] [CONN] input.I[0].O => igenebind[0].Vmax (13.32)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=7

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] # partial ids = 1
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=umodif
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=1
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] route igenebind[0].TF = umodif
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = 1
   [comp] make-comp igenebind0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > igenebind[0].TF = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > igenebind[0].K = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > igenebind[0].GE = VTF
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 24 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=umodif
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=1
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] route igenebind[0].TF = umodif
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = 1
   [comp] make-comp igenebind0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=13.32
     [comp] input.I[0] cfg-out O=13.32
     [comp] input.I[1] cfg-in X=1
     [comp] input.I[1] cfg-out O=1
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 13.32
     [sln] rm-route igenebind[0].K = 1
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 1
     [sln] route input.I[0].X = 13.32
     [sln] route input.I[1].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     add-goal [262] [CONN] input.I[0].O => igenebind[0].Vmax (13.32)
     add-goal [263] [CONN] input.I[1].O => igenebind[0].K (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[263] [CONN] input.I[1].O => igenebind[0].K (1)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[262] [CONN] input.I[0].O => igenebind[0].Vmax (13.32)
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> Current Goal: [262] [CONN] input.I[0].O => igenebind[0].Vmax (13.32)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.K
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=8

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] ihill_rep[0] cfg-in REP=VTF
   [comp] ihill_rep[0] cfg-in n=1
   [comp] ihill_rep[0] cfg-in S=umodif
   [comp] ihill_rep[0] cfg-in Vmax=13.32
   [comp] ihill_rep[0] cfg-in Km=1
   [sln] generate ihill_rep[0].REP = VTF
   [sln] add-comp ihill_rep[0]
   [sln] route ihill_rep[0].n = 1
   [sln] route ihill_rep[0].S = umodif
   [sln] route ihill_rep[0].Vmax = 13.32
   [sln] route ihill_rep[0].Km = 1
   [comp] make-comp ihill_rep0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[0].S = umodif
[multi]    - connecting generates to routes.
[multi] > ihill_rep[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[0].Km = 1
[multi]    - making an input block.
[multi] > ihill_rep[0].n = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > ihill_rep[0].REP = VTF
[multi] --> Number of options 3
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] ihill_rep[0] cfg-in REP=VTF
   [comp] ihill_rep[0] cfg-in n=1
   [comp] ihill_rep[0] cfg-in S=umodif
   [comp] ihill_rep[0] cfg-in Vmax=13.32
   [comp] ihill_rep[0] cfg-in Km=1
   [sln] generate ihill_rep[0].REP = VTF
   [sln] add-comp ihill_rep[0]
   [sln] route ihill_rep[0].n = 1
   [sln] route ihill_rep[0].S = umodif
   [sln] route ihill_rep[0].Vmax = 13.32
   [sln] route ihill_rep[0].Km = 1
   [comp] make-comp ihill_rep0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=13.32
     [comp] input.I[0] cfg-out O=13.32
     [comp] input.I[1] cfg-in X=1
     [comp] input.I[1] cfg-out O=1
     [comp] input.V[0] cfg-in X=1
     [comp] input.V[0] cfg-out O=1
     [sln] rm-route ihill_rep[0].Vmax = 13.32
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 13.32
     [sln] rm-route ihill_rep[0].Km = 1
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 1
     [sln] rm-route ihill_rep[0].n = 1
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 1
     [sln] route input.I[0].X = 13.32
     [sln] route input.I[1].X = 1
     [sln] route input.V[0].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V0
     add-goal [264] [CONN] input.I[0].O => ihill_rep[0].Vmax (13.32)
     add-goal [265] [CONN] input.I[1].O => ihill_rep[0].Km (1)
     add-goal [266] [CONN] input.V[0].O => ihill_rep[0].n (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[265] [CONN] input.I[1].O => ihill_rep[0].Km (1)
[266] [CONN] input.V[0].O => ihill_rep[0].n (1)
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[264] [CONN] input.I[0].O => ihill_rep[0].Vmax (13.32)
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> Current Goal: [264] [CONN] input.I[0].O => ihill_rep[0].Vmax (13.32)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=9

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 26
[multi] # partial ids = 1
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] switch[0] cfg-in PROD=VTF
   [comp] switch[0] cfg-in n=500
   [comp] switch[0] cfg-in Kmod=1
   [comp] switch[0] cfg-in Vmax=13.32
   [comp] switch[0] cfg-in SUB=umodif
   [sln] generate switch[0].PROD = VTF
   [sln] add-comp switch[0]
   [sln] route switch[0].n = 500
   [sln] route switch[0].Kmod = 1
   [sln] route switch[0].Vmax = 13.32
   [sln] route switch[0].SUB = umodif
   [comp] make-comp switch0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > switch[0].SUB = umodif
[multi]    - connecting generates to routes.
[multi] > switch[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > switch[0].n = 500
[multi]    - making an input block.
[multi] > switch[0].Kmod = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[0].PROD = VTF
[multi] --> Number of options 3
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 26 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] switch[0] cfg-in PROD=VTF
   [comp] switch[0] cfg-in n=500
   [comp] switch[0] cfg-in Kmod=1
   [comp] switch[0] cfg-in Vmax=13.32
   [comp] switch[0] cfg-in SUB=umodif
   [sln] generate switch[0].PROD = VTF
   [sln] add-comp switch[0]
   [sln] route switch[0].n = 500
   [sln] route switch[0].Kmod = 1
   [sln] route switch[0].Vmax = 13.32
   [sln] route switch[0].SUB = umodif
   [comp] make-comp switch0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=13.32
     [comp] input.I[0] cfg-out O=13.32
     [comp] input.V[0] cfg-in X=500
     [comp] input.V[0] cfg-out O=500
     [comp] input.I[1] cfg-in X=1
     [comp] input.I[1] cfg-out O=1
     [sln] rm-route switch[0].Vmax = 13.32
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 13.32
     [sln] rm-route switch[0].n = 500
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 500
     [sln] rm-route switch[0].Kmod = 1
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 1
     [sln] route input.I[0].X = 13.32
     [sln] route input.V[0].X = 500
     [sln] route input.I[1].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     add-goal [267] [CONN] input.I[0].O => switch[0].Vmax (13.32)
     add-goal [268] [CONN] input.V[0].O => switch[0].n (500)
     add-goal [269] [CONN] input.I[1].O => switch[0].Kmod (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[267] [CONN] input.I[0].O => switch[0].Vmax (13.32)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[269] [CONN] input.I[1].O => switch[0].Kmod (1)
[268] [CONN] input.V[0].O => switch[0].n (500)
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> Current Goal: [268] [CONN] input.V[0].O => switch[0].n (500)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=10

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] # partial ids = 1
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [comp] make-comp igenebind0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > igenebind[0].GE = VTF
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 24 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [comp] make-comp igenebind0
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=13.32
     [comp] input.I[0] cfg-out O=13.32
     [comp] input.I[1] cfg-in X=1
     [comp] input.I[1] cfg-out O=1
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 13.32
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 1
     [sln] route input.I[0].X = 13.32
     [sln] route input.I[1].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     add-goal [270] [CONN] input.I[0].O => igenebind[0].Vmax (13.32)
     add-goal [271] [CONN] input.I[1].O => igenebind[0].TF (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[271] [CONN] input.I[1].O => igenebind[0].TF (1)
[270] [CONN] input.I[0].O => igenebind[0].Vmax (13.32)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> Current Goal: [270] [CONN] input.I[0].O => igenebind[0].Vmax (13.32)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=11

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi] # Found 0, Required: 1
[multi] solving target: UTF
[multi] search tree is not exhausted. adding existing:UTF
[multi] finding new partial solution
[multi] made a partial tree with 7 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> Current Goal: [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
vgain.P -> true
switch.PROD -> true
ihill_stim.STIM -> true
ihill_rep.REP -> true
ihill_rep2.REP2 -> true
vadd.OUT -> true
vtoi.Y -> true
igenebind.GE -> true
mm.X -> true
mm.Y -> true
itov.Y -> true
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  12 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of ihill_rep[0].S to an input block.
7number reachable input blocks 1/7
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
checking reachability of ihill_rep[0].S to an input block.
7number reachable input blocks 1/7
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of ihill_rep[0].Km to an input block.
7number reachable input blocks 1/7
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of ihill_rep[1].S to an input block.
7number reachable input blocks 1/7
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
checking reachability of ihill_rep[1].S to an input block.
7number reachable input blocks 1/7
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
checking reachability of ihill_rep[1].Km to an input block.
7number reachable input blocks 1/7
[eqn]     -> converted to 13 ssteps
[eqn] new: [0] <ihill_rep2> output REP2.I
<analog>:(ihill_rep2.I{Vmax}:*(1/((ihill_rep2.I{S}:^ihill_rep2.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <vadd> output OUT.V
<analog>:(((vadd.V{A}:+(vadd.BSW*vadd.V{B}:))-(vadd.CSW*vadd.V{C}:))*0.25) / std=gauss ((0.001*vadd.V{OUT}:)+0.1)
<analog> [v]={[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <igenebind> output GE.I
<analog>:(igenebind.I{Vmax}:*(1/(1+(igenebind.I{K}:*igenebind.I{TF}:)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <mm> output Y.V
<analog>:(mm.V{Ytot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <mm> output X.V
<analog>:(mm.V{Xtot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <itov> output Y.V
<analog>:(itov.V{K}:*itov.I{X}:) / std=gauss 0.1
<analog> [v]=[0.,3300.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] [FOUND-SOLS] ===> Found <116> solutions
[slvrsearch] > weight--: <mvar-goal>UTF
[eqn] -> [valid?] testing node 97
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=12

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 85
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 97 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] # partial ids = 2
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[1].Km = K2P
[multi]    - making an input block.
[multi] > ihill_rep[1].S = V
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[1].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[1].Vmax = 15.6
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > ihill_rep[1].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] --> Number of options 5
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 50 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[0] cfg-in X=2.5
     [comp] input.V[0] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [sln] rm-route ihill_rep[1].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[1].n = 2.5
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 2.5
     [sln] rm-route ihill_rep[1].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[0].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.I[3].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.I1
     [comp] make-comp input.V0
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     add-goal [662] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
     add-goal [663] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [664] [CONN] input.V[0].O => ihill_rep[1].n (2.5)
     add-goal [665] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
     add-goal [666] [CONN] input.I[3].O => igenebind[0].TF (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[664] [CONN] input.V[0].O => ihill_rep[1].n (2.5)
[665] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
[662] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[666] [CONN] input.I[3].O => igenebind[0].TF (1)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[663] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> Current Goal: [663] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=13

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi] # Found 0, Required: 1
[multi] solving target: umodif
[multi] search tree is not exhausted. adding existing:umodif
[multi] finding new partial solution
[multi] made a partial tree with 7 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}

============
>> Current Goal: [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
vgain.P -> true
switch.PROD -> true
ihill_stim.STIM -> true
ihill_rep.REP -> true
ihill_rep2.REP2 -> true
vadd.OUT -> true
vtoi.Y -> true
igenebind.GE -> true
mm.X -> true
mm.Y -> true
itov.Y -> true
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  12 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <ihill_rep2> output REP2.I
<analog>:(ihill_rep2.I{Vmax}:*(1/((ihill_rep2.I{S}:^ihill_rep2.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] new: [0] <vadd> output OUT.V
<analog>:(((vadd.V{A}:+(vadd.BSW*vadd.V{B}:))-(vadd.CSW*vadd.V{C}:))*0.25) / std=gauss ((0.001*vadd.V{OUT}:)+0.1)
<analog> [v]={[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <igenebind> output GE.I
<analog>:(igenebind.I{Vmax}:*(1/(1+(igenebind.I{K}:*igenebind.I{TF}:)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] new: [0] <mm> output Y.V
<analog>:(mm.V{Ytot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <mm> output X.V
<analog>:(mm.V{Xtot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <itov> output Y.V
<analog>:(itov.V{K}:*itov.I{X}:) / std=gauss 0.1
<analog> [v]=[0.,3300.] {v}->[v]=@


[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn]     -> converted to 9 ssteps
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] [FOUND-SOLS] ===> Found <92> solutions
[slvrsearch] > weight--: <mvar-goal>umodif
[eqn] -> [valid?] testing node 45
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}

============
>> Current Goal: [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
vtoi.Y -> true
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  2 <<<
[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[2].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[2].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[2].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[2].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[2].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[2].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[3].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[3].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[3].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[3].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[3].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
checking reachability of vtoi[3].X to an input block.
4number reachable input blocks 1/4
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn] [FOUND-SOLS] ===> Found <22> solutions
[slvrsearch] > weight--: (337.632520764*IPTG)
[eqn] -> [valid?] testing node 203
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=14

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 202
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=15

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 201
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=16

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 199
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=17

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 198
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=18

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 197
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=19

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 193
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=20

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 192
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=21

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 191
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=22

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 189
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=23

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 188
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=24

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 187
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=25

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 226
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 191 ==
[multi] == Adding Local Solution : 199 ==
[multi] == Adding Local Solution : 188 ==
[multi] == Adding Local Solution : 193 ==
[multi] == Adding Local Solution : 189 ==
[multi] == Adding Local Solution : 187 ==
[multi] == Adding Local Solution : 197 ==
[multi] == Adding Local Solution : 198 ==
[multi] == Adding Local Solution : 202 ==
[multi] == Adding Local Solution : 201 ==
[multi] == Adding Local Solution : 203 ==
[multi] == Adding Local Solution : 192 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 24
[multi] found # steps: 26
[multi] # partial ids = 3
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[3].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[0].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[3].S = V
[multi]    - connecting generates to routes.
[multi] > switch[1].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[2].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[2].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[3].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[3].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[1].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[0].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[2].TF = 1
[multi]    - making an input block.
[multi] > switch[1].Kmod = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[1].PROD = umodif
[multi] > ihill_rep[3].REP = UTF
[multi] > igenebind[2].GE = VTF
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[3].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[0].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[2].K = umodif
     [sln] rm-route igenebind[2].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[3].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[3].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[1].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[0].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route igenebind[2].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[1].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [972] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
     add-goal [973] [CONN] input.V[0].O => vtoi[0].X (IPTG)
     add-goal [974] [CONN] switch[1].PROD => igenebind[2].K (umodif)
     add-goal [975] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
     add-goal [976] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
     add-goal [977] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
     add-goal [978] [CONN] input.V[2].O => switch[1].n (1000.75)
     add-goal [979] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
     add-goal [980] [CONN] input.I[3].O => igenebind[2].TF (1)
     add-goal [981] [CONN] input.I[4].O => switch[1].Kmod (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[973] [CONN] input.V[0].O => vtoi[0].X (IPTG)
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[980] [CONN] input.I[3].O => igenebind[2].TF (1)
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[977] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[975] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
[978] [CONN] input.V[2].O => switch[1].n (1000.75)
[981] [CONN] input.I[4].O => switch[1].Kmod (1)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[979] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[976] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[974] [CONN] switch[1].PROD => igenebind[2].K (umodif)
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[972] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)

============
>> Current Goal: [972] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=26

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 24
[multi] found # steps: 26
[multi] # partial ids = 3
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[3].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[0].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[3].S = V
[multi]    - connecting generates to routes.
[multi] > switch[1].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[2].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[2].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[3].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[3].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[1].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[0].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[2].TF = 1
[multi]    - making an input block.
[multi] > switch[1].Kmod = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[1].PROD = umodif
[multi] > ihill_rep[3].REP = UTF
[multi] > igenebind[2].GE = VTF
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[3].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[0].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[2].K = umodif
     [sln] rm-route igenebind[2].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[3].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[3].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[1].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[0].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route igenebind[2].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[1].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [982] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
     add-goal [983] [CONN] input.V[0].O => vtoi[0].X (IPTG)
     add-goal [984] [CONN] switch[1].PROD => igenebind[2].K (umodif)
     add-goal [985] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
     add-goal [986] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
     add-goal [987] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
     add-goal [988] [CONN] input.V[2].O => switch[1].n (1000.75)
     add-goal [989] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
     add-goal [990] [CONN] input.I[3].O => igenebind[2].TF (1)
     add-goal [991] [CONN] input.I[4].O => switch[1].Kmod (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[987] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[982] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
[989] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
[983] [CONN] input.V[0].O => vtoi[0].X (IPTG)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[991] [CONN] input.I[4].O => switch[1].Kmod (1)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[984] [CONN] switch[1].PROD => igenebind[2].K (umodif)
[986] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[990] [CONN] input.I[3].O => igenebind[2].TF (1)
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[988] [CONN] input.V[2].O => switch[1].n (1000.75)
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[985] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)

============
>> Current Goal: [985] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=27

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 37
[multi] found # steps: 26
[multi] # partial ids = 3
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [759] [EXPR]switch[2].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vtoi[1] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[1] cfg-in X=IPTG
   [comp] vtoi[1] cfg-in K=0.0029618
   [comp] switch[2] cfg-in PROD=umodif
   [comp] switch[2] cfg-in n=1000.75
   [comp] switch[2] cfg-in Kmod=1
   [comp] switch[2] cfg-in Vmax=U
   [comp] switch[2] cfg-in SUB=(337.632520764*IPTG)
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vtoi[1].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[1]
   [sln] generate vtoi[1].Y = (337.632520764*IPTG)
   [sln] conn vtoi[1].Y->switch[2].SUB
   [sln] generate switch[2].PROD = umodif
   [sln] add-comp switch[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vtoi[1].X = IPTG
   [sln] route vtoi[1].K = 0.0029618
   [sln] route switch[2].n = 1000.75
   [sln] route switch[2].Kmod = 1
   [sln] route switch[2].Vmax = U
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp igenebind0
   [comp] make-comp vtoi1
   [comp] make-comp switch2
   [comp] make-comp ihill_rep3
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[2].SUB<I>=(337.632520764*IPTG)
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[3].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[1].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[3].S = V
[multi]    - connecting generates to routes.
[multi] > switch[2].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[3].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[3].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[2].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[1].K = 0.0029618
[multi]    - making an input block.
[multi] > switch[2].Kmod = 1
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[2].PROD = umodif
[multi] > ihill_rep[3].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[1].Y = (337.632520764*IPTG)
[multi] > vtoi[1].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [759] [EXPR]switch[2].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vtoi[1] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[1] cfg-in X=IPTG
   [comp] vtoi[1] cfg-in K=0.0029618
   [comp] switch[2] cfg-in PROD=umodif
   [comp] switch[2] cfg-in n=1000.75
   [comp] switch[2] cfg-in Kmod=1
   [comp] switch[2] cfg-in Vmax=U
   [comp] switch[2] cfg-in SUB=(337.632520764*IPTG)
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vtoi[1].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[1]
   [sln] generate vtoi[1].Y = (337.632520764*IPTG)
   [sln] conn vtoi[1].Y->switch[2].SUB
   [sln] generate switch[2].PROD = umodif
   [sln] add-comp switch[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vtoi[1].X = IPTG
   [sln] route vtoi[1].K = 0.0029618
   [sln] route switch[2].n = 1000.75
   [sln] route switch[2].Kmod = 1
   [sln] route switch[2].Vmax = U
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp igenebind0
   [comp] make-comp vtoi1
   [comp] make-comp switch2
   [comp] make-comp ihill_rep3
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[2].SUB<I>=(337.632520764*IPTG)
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[3].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[1].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[3].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[3].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[2].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[1].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route switch[2].Kmod = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [992] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
     add-goal [993] [CONN] input.V[0].O => vtoi[1].X (IPTG)
     add-goal [994] [CONN] switch[2].PROD => igenebind[0].K (umodif)
     add-goal [995] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [996] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
     add-goal [997] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
     add-goal [998] [CONN] input.V[2].O => switch[2].n (1000.75)
     add-goal [999] [CONN] input.V[3].O => vtoi[1].K (0.0029618)
     add-goal [1000] [CONN] input.I[3].O => switch[2].Kmod (1)
     add-goal [1001] [CONN] input.I[4].O => igenebind[0].TF (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[997] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1001] [CONN] input.I[4].O => igenebind[0].TF (1)
[1000] [CONN] input.I[3].O => switch[2].Kmod (1)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[994] [CONN] switch[2].PROD => igenebind[0].K (umodif)
[996] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[992] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
[993] [CONN] input.V[0].O => vtoi[1].X (IPTG)
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[995] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[998] [CONN] input.V[2].O => switch[2].n (1000.75)
[999] [CONN] input.V[3].O => vtoi[1].K (0.0029618)

============
>> Current Goal: [999] [CONN] input.V[3].O => vtoi[1].K (0.0029618)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=28

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 24
[multi] found # steps: 26
[multi] # partial ids = 3
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[3].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[0].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[3].S = V
[multi]    - connecting generates to routes.
[multi] > switch[1].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[2].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[2].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[3].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[3].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[1].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[0].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[2].TF = 1
[multi]    - making an input block.
[multi] > switch[1].Kmod = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[1].PROD = umodif
[multi] > ihill_rep[3].REP = UTF
[multi] > igenebind[2].GE = VTF
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[3].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[0].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[2].K = umodif
     [sln] rm-route igenebind[2].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[3].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[3].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[1].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[0].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route igenebind[2].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[1].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [1002] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
     add-goal [1003] [CONN] input.V[0].O => vtoi[0].X (IPTG)
     add-goal [1004] [CONN] switch[1].PROD => igenebind[2].K (umodif)
     add-goal [1005] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
     add-goal [1006] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
     add-goal [1007] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
     add-goal [1008] [CONN] input.V[2].O => switch[1].n (1000.75)
     add-goal [1009] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
     add-goal [1010] [CONN] input.I[3].O => igenebind[2].TF (1)
     add-goal [1011] [CONN] input.I[4].O => switch[1].Kmod (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1007] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1011] [CONN] input.I[4].O => switch[1].Kmod (1)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1002] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1010] [CONN] input.I[3].O => igenebind[2].TF (1)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1008] [CONN] input.V[2].O => switch[1].n (1000.75)
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1006] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1004] [CONN] switch[1].PROD => igenebind[2].K (umodif)
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1003] [CONN] input.V[0].O => vtoi[0].X (IPTG)
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1005] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
[1009] [CONN] input.V[3].O => vtoi[0].K (0.0029618)

============
>> Current Goal: [1009] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=29

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 24
[multi] found # steps: 26
[multi] # partial ids = 3
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[3].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[0].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[3].S = V
[multi]    - connecting generates to routes.
[multi] > switch[1].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[2].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[2].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[3].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[3].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[1].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[0].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[2].TF = 1
[multi]    - making an input block.
[multi] > switch[1].Kmod = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[1].PROD = umodif
[multi] > ihill_rep[3].REP = UTF
[multi] > igenebind[2].GE = VTF
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[3].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[0].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[2].K = umodif
     [sln] rm-route igenebind[2].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[3].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[3].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[1].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[0].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route igenebind[2].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[1].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [1012] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
     add-goal [1013] [CONN] input.V[0].O => vtoi[0].X (IPTG)
     add-goal [1014] [CONN] switch[1].PROD => igenebind[2].K (umodif)
     add-goal [1015] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
     add-goal [1016] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
     add-goal [1017] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
     add-goal [1018] [CONN] input.V[2].O => switch[1].n (1000.75)
     add-goal [1019] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
     add-goal [1020] [CONN] input.I[3].O => igenebind[2].TF (1)
     add-goal [1021] [CONN] input.I[4].O => switch[1].Kmod (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1016] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
[1018] [CONN] input.V[2].O => switch[1].n (1000.75)
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1021] [CONN] input.I[4].O => switch[1].Kmod (1)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1019] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1017] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1012] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1020] [CONN] input.I[3].O => igenebind[2].TF (1)
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1014] [CONN] switch[1].PROD => igenebind[2].K (umodif)
[1015] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
[1013] [CONN] input.V[0].O => vtoi[0].X (IPTG)

============
>> Current Goal: [1013] [CONN] input.V[0].O => vtoi[0].X (IPTG)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=30

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] found # steps: 37
[multi] # partial ids = 3
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vtoi[2] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[2] cfg-in K=0.0029618
   [comp] vtoi[2] cfg-in X=IPTG
   [comp] switch[3] cfg-in PROD=umodif
   [comp] switch[3] cfg-in n=1000.75
   [comp] switch[3] cfg-in Kmod=1
   [comp] switch[3] cfg-in Vmax=U
   [comp] switch[3] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] conn vtoi[2].Y->switch[3].SUB
   [sln] generate switch[3].PROD = umodif
   [sln] add-comp switch[3]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vtoi[2].K = 0.0029618
   [sln] route vtoi[2].X = IPTG
   [sln] route switch[3].n = 1000.75
   [sln] route switch[3].Kmod = 1
   [sln] route switch[3].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vtoi2
   [comp] make-comp switch3
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)

[multi] ==== ROUTES =====
[multi] > ihill_rep[1].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[2].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[1].S = V
[multi]    - connecting generates to routes.
[multi] > switch[3].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[1].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[1].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[3].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.0029618
[multi]    - making an input block.
[multi] > switch[3].Kmod = 1
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[3].PROD = umodif
[multi] > ihill_rep[1].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[2].Y = (337.632520764*IPTG)
[multi] > vtoi[2].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vtoi[2] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[2] cfg-in K=0.0029618
   [comp] vtoi[2] cfg-in X=IPTG
   [comp] switch[3] cfg-in PROD=umodif
   [comp] switch[3] cfg-in n=1000.75
   [comp] switch[3] cfg-in Kmod=1
   [comp] switch[3] cfg-in Vmax=U
   [comp] switch[3] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] conn vtoi[2].Y->switch[3].SUB
   [sln] generate switch[3].PROD = umodif
   [sln] add-comp switch[3]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vtoi[2].K = 0.0029618
   [sln] route vtoi[2].X = IPTG
   [sln] route switch[3].n = 1000.75
   [sln] route switch[3].Kmod = 1
   [sln] route switch[3].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vtoi2
   [comp] make-comp switch3
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[1].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[2].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[1].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[1].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[3].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[2].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route switch[3].Kmod = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [1022] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
     add-goal [1023] [CONN] input.V[0].O => vtoi[2].X (IPTG)
     add-goal [1024] [CONN] switch[3].PROD => igenebind[0].K (umodif)
     add-goal [1025] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [1026] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
     add-goal [1027] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
     add-goal [1028] [CONN] input.V[2].O => switch[3].n (1000.75)
     add-goal [1029] [CONN] input.V[3].O => vtoi[2].K (0.0029618)
     add-goal [1030] [CONN] input.I[3].O => switch[3].Kmod (1)
     add-goal [1031] [CONN] input.I[4].O => igenebind[0].TF (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1025] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[1023] [CONN] input.V[0].O => vtoi[2].X (IPTG)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1022] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1030] [CONN] input.I[3].O => switch[3].Kmod (1)
[1031] [CONN] input.I[4].O => igenebind[0].TF (1)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1028] [CONN] input.V[2].O => switch[3].n (1000.75)
[1029] [CONN] input.V[3].O => vtoi[2].K (0.0029618)
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1024] [CONN] switch[3].PROD => igenebind[0].K (umodif)
[1026] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1027] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> Current Goal: [1027] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=31

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 24
[multi] found # steps: 26
[multi] # partial ids = 3
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[3].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[0].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[3].S = V
[multi]    - connecting generates to routes.
[multi] > switch[1].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[2].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[2].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[3].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[3].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[1].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[0].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[2].TF = 1
[multi]    - making an input block.
[multi] > switch[1].Kmod = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[1].PROD = umodif
[multi] > ihill_rep[3].REP = UTF
[multi] > igenebind[2].GE = VTF
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[3].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[0].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[2].K = umodif
     [sln] rm-route igenebind[2].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[3].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[3].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[1].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[0].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route igenebind[2].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[1].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [1032] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
     add-goal [1033] [CONN] input.V[0].O => vtoi[0].X (IPTG)
     add-goal [1034] [CONN] switch[1].PROD => igenebind[2].K (umodif)
     add-goal [1035] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
     add-goal [1036] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
     add-goal [1037] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
     add-goal [1038] [CONN] input.V[2].O => switch[1].n (1000.75)
     add-goal [1039] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
     add-goal [1040] [CONN] input.I[3].O => igenebind[2].TF (1)
     add-goal [1041] [CONN] input.I[4].O => switch[1].Kmod (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1032] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
[1037] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
[1038] [CONN] input.V[2].O => switch[1].n (1000.75)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1033] [CONN] input.V[0].O => vtoi[0].X (IPTG)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1039] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
[1040] [CONN] input.I[3].O => igenebind[2].TF (1)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1035] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1036] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1034] [CONN] switch[1].PROD => igenebind[2].K (umodif)
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1041] [CONN] input.I[4].O => switch[1].Kmod (1)

============
>> Current Goal: [1041] [CONN] input.I[4].O => switch[1].Kmod (1)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=32

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 24
[multi] found # steps: 26
[multi] # partial ids = 3
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].X = IPTG
   [sln] route vtoi[0].K = 0.0029618
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[3].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[0].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[3].S = V
[multi]    - connecting generates to routes.
[multi] > switch[1].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[2].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[2].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[3].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[3].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[1].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[0].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[2].TF = 1
[multi]    - making an input block.
[multi] > switch[1].Kmod = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[1].PROD = umodif
[multi] > ihill_rep[3].REP = UTF
[multi] > igenebind[2].GE = VTF
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].X = IPTG
   [sln] route vtoi[0].K = 0.0029618
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[3].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[0].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[2].K = umodif
     [sln] rm-route igenebind[2].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[3].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[3].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[1].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[0].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route igenebind[2].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[1].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [1042] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
     add-goal [1043] [CONN] input.V[0].O => vtoi[0].X (IPTG)
     add-goal [1044] [CONN] switch[1].PROD => igenebind[2].K (umodif)
     add-goal [1045] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
     add-goal [1046] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
     add-goal [1047] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
     add-goal [1048] [CONN] input.V[2].O => switch[1].n (1000.75)
     add-goal [1049] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
     add-goal [1050] [CONN] input.I[3].O => igenebind[2].TF (1)
     add-goal [1051] [CONN] input.I[4].O => switch[1].Kmod (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1042] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1044] [CONN] switch[1].PROD => igenebind[2].K (umodif)
[1047] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1043] [CONN] input.V[0].O => vtoi[0].X (IPTG)
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1048] [CONN] input.V[2].O => switch[1].n (1000.75)
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1050] [CONN] input.I[3].O => igenebind[2].TF (1)
[1046] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
[1051] [CONN] input.I[4].O => switch[1].Kmod (1)
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1045] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
[1049] [CONN] input.V[3].O => vtoi[0].K (0.0029618)

============
>> Current Goal: [1049] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=33

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] found # steps: 37
[multi] # partial ids = 3
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vtoi[2] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[2] cfg-in K=0.0029618
   [comp] vtoi[2] cfg-in X=IPTG
   [comp] switch[3] cfg-in PROD=umodif
   [comp] switch[3] cfg-in n=1000.75
   [comp] switch[3] cfg-in Kmod=1
   [comp] switch[3] cfg-in Vmax=U
   [comp] switch[3] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] conn vtoi[2].Y->switch[3].SUB
   [sln] generate switch[3].PROD = umodif
   [sln] add-comp switch[3]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vtoi[2].K = 0.0029618
   [sln] route vtoi[2].X = IPTG
   [sln] route switch[3].n = 1000.75
   [sln] route switch[3].Kmod = 1
   [sln] route switch[3].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vtoi2
   [comp] make-comp switch3
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)

[multi] ==== ROUTES =====
[multi] > ihill_rep[1].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[2].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[1].S = V
[multi]    - connecting generates to routes.
[multi] > switch[3].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[1].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[1].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[3].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.0029618
[multi]    - making an input block.
[multi] > switch[3].Kmod = 1
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[3].PROD = umodif
[multi] > ihill_rep[1].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[2].Y = (337.632520764*IPTG)
[multi] > vtoi[2].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vtoi[2] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[2] cfg-in K=0.0029618
   [comp] vtoi[2] cfg-in X=IPTG
   [comp] switch[3] cfg-in PROD=umodif
   [comp] switch[3] cfg-in n=1000.75
   [comp] switch[3] cfg-in Kmod=1
   [comp] switch[3] cfg-in Vmax=U
   [comp] switch[3] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] conn vtoi[2].Y->switch[3].SUB
   [sln] generate switch[3].PROD = umodif
   [sln] add-comp switch[3]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vtoi[2].K = 0.0029618
   [sln] route vtoi[2].X = IPTG
   [sln] route switch[3].n = 1000.75
   [sln] route switch[3].Kmod = 1
   [sln] route switch[3].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vtoi2
   [comp] make-comp switch3
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[1].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[2].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[1].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[1].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[3].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[2].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route switch[3].Kmod = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [1052] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
     add-goal [1053] [CONN] input.V[0].O => vtoi[2].X (IPTG)
     add-goal [1054] [CONN] switch[3].PROD => igenebind[0].K (umodif)
     add-goal [1055] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [1056] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
     add-goal [1057] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
     add-goal [1058] [CONN] input.V[2].O => switch[3].n (1000.75)
     add-goal [1059] [CONN] input.V[3].O => vtoi[2].K (0.0029618)
     add-goal [1060] [CONN] input.I[3].O => switch[3].Kmod (1)
     add-goal [1061] [CONN] input.I[4].O => igenebind[0].TF (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1058] [CONN] input.V[2].O => switch[3].n (1000.75)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1054] [CONN] switch[3].PROD => igenebind[0].K (umodif)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1061] [CONN] input.I[4].O => igenebind[0].TF (1)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1060] [CONN] input.I[3].O => switch[3].Kmod (1)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1057] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1053] [CONN] input.V[0].O => vtoi[2].X (IPTG)
[1055] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1059] [CONN] input.V[3].O => vtoi[2].K (0.0029618)
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1052] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
[1056] [CONN] input.V[1].O => ihill_rep[1].n (2.5)

============
>> Current Goal: [1056] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=34

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] found # steps: 37
[multi] # partial ids = 3
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vtoi[2] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[2] cfg-in K=0.0029618
   [comp] vtoi[2] cfg-in X=IPTG
   [comp] switch[3] cfg-in PROD=umodif
   [comp] switch[3] cfg-in n=1000.75
   [comp] switch[3] cfg-in Kmod=1
   [comp] switch[3] cfg-in Vmax=U
   [comp] switch[3] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] conn vtoi[2].Y->switch[3].SUB
   [sln] generate switch[3].PROD = umodif
   [sln] add-comp switch[3]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vtoi[2].K = 0.0029618
   [sln] route vtoi[2].X = IPTG
   [sln] route switch[3].n = 1000.75
   [sln] route switch[3].Kmod = 1
   [sln] route switch[3].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vtoi2
   [comp] make-comp switch3
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)

[multi] ==== ROUTES =====
[multi] > ihill_rep[1].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[2].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[1].S = V
[multi]    - connecting generates to routes.
[multi] > switch[3].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[1].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[1].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[3].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.0029618
[multi]    - making an input block.
[multi] > switch[3].Kmod = 1
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[3].PROD = umodif
[multi] > ihill_rep[1].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[2].Y = (337.632520764*IPTG)
[multi] > vtoi[2].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vtoi[2] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[2] cfg-in K=0.0029618
   [comp] vtoi[2] cfg-in X=IPTG
   [comp] switch[3] cfg-in PROD=umodif
   [comp] switch[3] cfg-in n=1000.75
   [comp] switch[3] cfg-in Kmod=1
   [comp] switch[3] cfg-in Vmax=U
   [comp] switch[3] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (337.632520764*IPTG)
   [sln] conn vtoi[2].Y->switch[3].SUB
   [sln] generate switch[3].PROD = umodif
   [sln] add-comp switch[3]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vtoi[2].K = 0.0029618
   [sln] route vtoi[2].X = IPTG
   [sln] route switch[3].n = 1000.75
   [sln] route switch[3].Kmod = 1
   [sln] route switch[3].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vtoi2
   [comp] make-comp switch3
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[3].SUB<I>=(337.632520764*IPTG)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[1].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[2].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[1].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[1].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[3].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[2].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route switch[3].Kmod = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [1062] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
     add-goal [1063] [CONN] input.V[0].O => vtoi[2].X (IPTG)
     add-goal [1064] [CONN] switch[3].PROD => igenebind[0].K (umodif)
     add-goal [1065] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [1066] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
     add-goal [1067] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
     add-goal [1068] [CONN] input.V[2].O => switch[3].n (1000.75)
     add-goal [1069] [CONN] input.V[3].O => vtoi[2].K (0.0029618)
     add-goal [1070] [CONN] input.I[3].O => switch[3].Kmod (1)
     add-goal [1071] [CONN] input.I[4].O => igenebind[0].TF (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1067] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1071] [CONN] input.I[4].O => igenebind[0].TF (1)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1069] [CONN] input.V[3].O => vtoi[2].K (0.0029618)
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1063] [CONN] input.V[0].O => vtoi[2].X (IPTG)
[1062] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
[1066] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1068] [CONN] input.V[2].O => switch[3].n (1000.75)
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1065] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[1070] [CONN] input.I[3].O => switch[3].Kmod (1)
[1064] [CONN] switch[3].PROD => igenebind[0].K (umodif)

============
>> Current Goal: [1064] [CONN] switch[3].PROD => igenebind[0].K (umodif)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=35

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 24
[multi] found # steps: 26
[multi] # partial ids = 3
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[3].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[0].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[3].S = V
[multi]    - connecting generates to routes.
[multi] > switch[1].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[2].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[2].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[3].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[3].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[1].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[0].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[2].TF = 1
[multi]    - making an input block.
[multi] > switch[1].Kmod = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[1].PROD = umodif
[multi] > ihill_rep[3].REP = UTF
[multi] > igenebind[2].GE = VTF
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[3].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[0].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[2].K = umodif
     [sln] rm-route igenebind[2].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[3].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[3].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[1].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[0].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route igenebind[2].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[1].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [1072] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
     add-goal [1073] [CONN] input.V[0].O => vtoi[0].X (IPTG)
     add-goal [1074] [CONN] switch[1].PROD => igenebind[2].K (umodif)
     add-goal [1075] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
     add-goal [1076] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
     add-goal [1077] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
     add-goal [1078] [CONN] input.V[2].O => switch[1].n (1000.75)
     add-goal [1079] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
     add-goal [1080] [CONN] input.I[3].O => igenebind[2].TF (1)
     add-goal [1081] [CONN] input.I[4].O => switch[1].Kmod (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1080] [CONN] input.I[3].O => igenebind[2].TF (1)
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1077] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1076] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1075] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1074] [CONN] switch[1].PROD => igenebind[2].K (umodif)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1072] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
[1079] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1073] [CONN] input.V[0].O => vtoi[0].X (IPTG)
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1078] [CONN] input.V[2].O => switch[1].n (1000.75)
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1081] [CONN] input.I[4].O => switch[1].Kmod (1)

============
>> Current Goal: [1081] [CONN] input.I[4].O => switch[1].Kmod (1)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=36

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 37
[multi] found # steps: 24
[multi] found # steps: 26
[multi] # partial ids = 3
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[3].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[0].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[3].S = V
[multi]    - connecting generates to routes.
[multi] > switch[1].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[2].K = umodif
[multi]    - connecting generates to routes.
[multi] > igenebind[2].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[3].n = 2.5
[multi]    - making an input block.
[multi] > ihill_rep[3].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[1].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[0].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[2].TF = 1
[multi]    - making an input block.
[multi] > switch[1].Kmod = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > switch[1].PROD = umodif
[multi] > ihill_rep[3].REP = UTF
[multi] > igenebind[2].GE = VTF
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] > vtoi[0].Y = (337.632520764*IPTG)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 87 =======
[multi]    remove-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   [comp] vtoi[0] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[0] cfg-in K=0.0029618
   [comp] vtoi[0] cfg-in X=IPTG
   [comp] switch[1] cfg-in PROD=umodif
   [comp] switch[1] cfg-in n=1000.75
   [comp] switch[1] cfg-in Kmod=1
   [comp] switch[1] cfg-in Vmax=U
   [comp] switch[1] cfg-in SUB=(337.632520764*IPTG)
   [comp] igenebind[2] cfg-in GE=VTF
   [comp] igenebind[2] cfg-in TF=1
   [comp] igenebind[2] cfg-in Vmax=13.32
   [comp] igenebind[2] cfg-in K=umodif
   [comp] ihill_rep[3] cfg-in REP=UTF
   [comp] ihill_rep[3] cfg-in n=2.5
   [comp] ihill_rep[3] cfg-in S=V
   [comp] ihill_rep[3] cfg-in Vmax=15.6
   [comp] ihill_rep[3] cfg-in Km=K2P
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[0]
   [sln] generate vtoi[0].Y = (337.632520764*IPTG)
   [sln] conn vtoi[0].Y->switch[1].SUB
   [sln] generate switch[1].PROD = umodif
   [sln] add-comp switch[1]
   [sln] generate igenebind[2].GE = VTF
   [sln] add-comp igenebind[2]
   [sln] generate ihill_rep[3].REP = UTF
   [sln] add-comp ihill_rep[3]
   [sln] route vtoi[0].K = 0.0029618
   [sln] route vtoi[0].X = IPTG
   [sln] route switch[1].n = 1000.75
   [sln] route switch[1].Kmod = 1
   [sln] route switch[1].Vmax = U
   [sln] route igenebind[2].TF = 1
   [sln] route igenebind[2].Vmax = 13.32
   [sln] route igenebind[2].K = umodif
   [sln] route ihill_rep[3].n = 2.5
   [sln] route ihill_rep[3].S = V
   [sln] route ihill_rep[3].Vmax = 15.6
   [sln] route ihill_rep[3].Km = K2P
   [comp] make-comp vtoi0
   [comp] make-comp switch1
   [comp] make-comp igenebind2
   [comp] make-comp ihill_rep3
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[1].SUB<I>=(337.632520764*IPTG)
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[2] cfg-in X=1000.75
     [comp] input.V[2] cfg-out O=1000.75
     [comp] input.V[3] cfg-in X=0.0029618
     [comp] input.V[3] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [sln] rm-route ihill_rep[3].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[0].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route igenebind[2].K = umodif
     [sln] rm-route igenebind[2].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[3].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route ihill_rep[3].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[1].n = 1000.75
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 1000.75
     [sln] rm-route vtoi[0].K = 0.0029618
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.0029618
     [sln] rm-route igenebind[2].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[1].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[2].X = 1000.75
     [sln] route input.V[3].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.I2
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [1082] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
     add-goal [1083] [CONN] input.V[0].O => vtoi[0].X (IPTG)
     add-goal [1084] [CONN] switch[1].PROD => igenebind[2].K (umodif)
     add-goal [1085] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
     add-goal [1086] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
     add-goal [1087] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
     add-goal [1088] [CONN] input.V[2].O => switch[1].n (1000.75)
     add-goal [1089] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
     add-goal [1090] [CONN] input.I[3].O => igenebind[2].TF (1)
     add-goal [1091] [CONN] input.I[4].O => switch[1].Kmod (1)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1088] [CONN] input.V[2].O => switch[1].n (1000.75)
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1086] [CONN] input.V[1].O => ihill_rep[3].n (2.5)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1082] [CONN] input.I[0].O => ihill_rep[3].Km (K2P)
[1091] [CONN] input.I[4].O => switch[1].Kmod (1)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1083] [CONN] input.V[0].O => vtoi[0].X (IPTG)
[1085] [CONN] input.I[1].O => igenebind[2].Vmax (13.32)
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1087] [CONN] input.I[2].O => ihill_rep[3].Vmax (15.6)
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1089] [CONN] input.V[3].O => vtoi[0].K (0.0029618)
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1084] [CONN] switch[1].PROD => igenebind[2].K (umodif)
[1090] [CONN] input.I[3].O => igenebind[2].TF (1)

============
>> Current Goal: [1090] [CONN] input.I[3].O => igenebind[2].TF (1)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=37

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi] # Found 0, Required: 1
[multi] solving target: U
[multi] search tree is not exhausted. adding existing:U
[multi] finding new partial solution
[multi] made a partial tree with 7 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
vdadd.OUT -> true
mm.XY -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  2 <<<
[eqn] new: [0] <vdadd> output OUT.V
<analog-st> ((vdadd.V{A}:+(vdadd.BSW*vdadd.V{B}:))-(vdadd.DSW*vdadd.I{D}:*vdadd.V{OUT}:)) ic=OUT_0.V / std=none 0
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,12000.] {v}->[v]=@ {v}->*[v]=@


checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <mm> output XY.V
<analog-st> ((mm.I{kf}:*mm.V{X}:*mm.V{Y}:)-(mm.I{kr}:*mm.V{XY}:)) ic=XY0.V / std=gauss ((0.001*mm.V{XY}:)+0.1)
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,3200.] {v}->[v]=@ {v}->*[v]=@


[eqn] [FOUND-SOLS] ===> Found <19> solutions
[slvrsearch] > weight--: <mvar-goal>U
[eqn] -> [valid?] testing node 34
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=38

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 32
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=39

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 30
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=40

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 23
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=41

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 15
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 32 ==
[multi] == Adding Local Solution : 23 ==
[multi] == Adding Local Solution : 30 ==
[multi] == Adding Local Solution : 34 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] found # steps: 28
[multi] found # steps: 37
[multi] # partial ids = 4
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vdadd[2] cfg-in OUT_0=0.
   [comp] vdadd[2] cfg-in OUT=U
   [comp] vdadd[2] cfg-param BSW=1
   [comp] vdadd[2] cfg-param DSW=1
   [comp] vdadd[2] cfg-in B=0
   [comp] vdadd[2] cfg-in A=UTF
   [comp] vdadd[2] cfg-in D=1
   [comp] vtoi[3] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[3] cfg-in K=0.0029618
   [comp] vtoi[3] cfg-in X=IPTG
   [comp] switch[4] cfg-in PROD=umodif
   [comp] switch[4] cfg-in n=1000.75
   [comp] switch[4] cfg-in Kmod=1
   [comp] switch[4] cfg-in Vmax=U
   [comp] switch[4] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vdadd[2].OUT = U
   [sln] add-comp vdadd[2]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[3]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] conn vtoi[3].Y->switch[4].SUB
   [sln] generate switch[4].PROD = umodif
   [sln] add-comp switch[4]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vdadd[2].OUT_0 = 0.
   [sln] route vdadd[2].B = 0
   [sln] route vdadd[2].A = UTF
   [sln] route vdadd[2].D = 1
   [sln] route vtoi[3].K = 0.0029618
   [sln] route vtoi[3].X = IPTG
   [sln] route switch[4].n = 1000.75
   [sln] route switch[4].Kmod = 1
   [sln] route switch[4].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vdadd2
   [comp] make-comp vtoi3
   [comp] make-comp switch4
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)

[multi] ==== ROUTES =====
[multi] > ihill_rep[1].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[3].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[1].S = V
[multi]    - connecting generates to routes.
[multi] > switch[4].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > vdadd[2].A = UTF
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[1].n = 2.5
[multi]    - making an input block.
[multi] > vdadd[2].B = 0
[multi]    - making an input block.
[multi] > vdadd[2].OUT_0 = 0.
[multi]    - making an input block.
[multi] > ihill_rep[1].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[4].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[3].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] > switch[4].Kmod = 1
[multi]    - making an input block.
[multi] > vdadd[2].D = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[2].OUT = U
[multi]    - making an output block.
[multi] > switch[4].PROD = umodif
[multi] > ihill_rep[1].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[3].Y = (337.632520764*IPTG)
[multi] > vtoi[3].Y = (337.632520764*IPTG)
[multi] --> Number of options 16
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 115 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vdadd[2] cfg-in OUT_0=0.
   [comp] vdadd[2] cfg-in OUT=U
   [comp] vdadd[2] cfg-param BSW=1
   [comp] vdadd[2] cfg-param DSW=1
   [comp] vdadd[2] cfg-in B=0
   [comp] vdadd[2] cfg-in A=UTF
   [comp] vdadd[2] cfg-in D=1
   [comp] vtoi[3] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[3] cfg-in K=0.0029618
   [comp] vtoi[3] cfg-in X=IPTG
   [comp] switch[4] cfg-in PROD=umodif
   [comp] switch[4] cfg-in n=1000.75
   [comp] switch[4] cfg-in Kmod=1
   [comp] switch[4] cfg-in Vmax=U
   [comp] switch[4] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vdadd[2].OUT = U
   [sln] add-comp vdadd[2]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[3]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] conn vtoi[3].Y->switch[4].SUB
   [sln] generate switch[4].PROD = umodif
   [sln] add-comp switch[4]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vdadd[2].OUT_0 = 0.
   [sln] route vdadd[2].B = 0
   [sln] route vdadd[2].A = UTF
   [sln] route vdadd[2].D = 1
   [sln] route vtoi[3].K = 0.0029618
   [sln] route vtoi[3].X = IPTG
   [sln] route switch[4].n = 1000.75
   [sln] route switch[4].Kmod = 1
   [sln] route switch[4].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vdadd2
   [comp] make-comp vtoi3
   [comp] make-comp switch4
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0.
     [comp] input.V[3] cfg-out O=0.
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[4] cfg-in X=1000.75
     [comp] input.V[4] cfg-out O=1000.75
     [comp] input.V[5] cfg-in X=0.0029618
     [comp] input.V[5] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [comp] input.I[5] cfg-in X=1
     [comp] input.I[5] cfg-out O=1
     [comp] output.V[0] cfg-in X=U
     [comp] output.V[0] cfg-out O=U
     [sln] rm-route ihill_rep[1].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[3].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route switch[4].Vmax = U
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route vdadd[2].A = UTF
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[1].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route vdadd[2].B = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[2].OUT_0 = 0.
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.
     [sln] rm-route ihill_rep[1].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[4].n = 1000.75
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 1000.75
     [sln] rm-route vtoi[3].K = 0.0029618
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0.0029618
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[4].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] rm-route vdadd[2].D = 1
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = U
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0.
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[4].X = 1000.75
     [sln] route input.V[5].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [sln] route input.I[5].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I2
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp output.V0
     add-goal [1144] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
     add-goal [1145] [CONN] input.V[0].O => vtoi[3].X (IPTG)
     add-goal [1146] [CONN] vdadd[2].OUT => switch[4].Vmax (U)
     add-goal [1147] [CONN] switch[4].PROD => igenebind[0].K (umodif)
     add-goal [1148] [CONN] ihill_rep[1].REP => vdadd[2].A (UTF)
     add-goal [1149] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [1150] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
     add-goal [1151] [CONN] input.V[2].O => vdadd[2].B (0)
     add-goal [1152] [CONN] input.V[3].O => vdadd[2].OUT_0 (0.)
     add-goal [1153] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
     add-goal [1154] [CONN] input.V[4].O => switch[4].n (1000.75)
     add-goal [1155] [CONN] input.V[5].O => vtoi[3].K (0.0029618)
     add-goal [1156] [CONN] input.I[3].O => igenebind[0].TF (1)
     add-goal [1157] [CONN] input.I[4].O => switch[4].Kmod (1)
     add-goal [1158] [CONN] input.I[5].O => vdadd[2].D (1)
     add-goal [1159] [CONN] vdadd[2].OUT => output.V[0].X (U)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1157] [CONN] input.I[4].O => switch[4].Kmod (1)
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1147] [CONN] switch[4].PROD => igenebind[0].K (umodif)
[1150] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
[1152] [CONN] input.V[3].O => vdadd[2].OUT_0 (0.)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1145] [CONN] input.V[0].O => vtoi[3].X (IPTG)
[1154] [CONN] input.V[4].O => switch[4].n (1000.75)
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1151] [CONN] input.V[2].O => vdadd[2].B (0)
[1153] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
[1159] [CONN] vdadd[2].OUT => output.V[0].X (U)
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1149] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[1155] [CONN] input.V[5].O => vtoi[3].K (0.0029618)
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1148] [CONN] ihill_rep[1].REP => vdadd[2].A (UTF)
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1156] [CONN] input.I[3].O => igenebind[0].TF (1)
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1144] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1158] [CONN] input.I[5].O => vdadd[2].D (1)
[1146] [CONN] vdadd[2].OUT => switch[4].Vmax (U)

============
>> Current Goal: [1146] [CONN] vdadd[2].OUT => switch[4].Vmax (U)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>ihill_rep.REP->vdadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=42

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] found # steps: 26
[multi] found # steps: 37
[multi] # partial ids = 4
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vdadd[1] cfg-in OUT_0=0.
   [comp] vdadd[1] cfg-in OUT=U
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=1
   [comp] vdadd[1] cfg-in A=UTF
   [comp] ihill_rep[2] cfg-in REP=UTF
   [comp] ihill_rep[2] cfg-in n=2.5
   [comp] ihill_rep[2] cfg-in S=V
   [comp] ihill_rep[2] cfg-in Vmax=15.6
   [comp] ihill_rep[2] cfg-in Km=K2P
   [comp] vtoi[3] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[3] cfg-in K=0.0029618
   [comp] vtoi[3] cfg-in X=IPTG
   [comp] switch[4] cfg-in PROD=umodif
   [comp] switch[4] cfg-in n=1000.75
   [comp] switch[4] cfg-in Kmod=1
   [comp] switch[4] cfg-in Vmax=U
   [comp] switch[4] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vdadd[1].OUT = U
   [sln] add-comp vdadd[1]
   [sln] generate ihill_rep[2].REP = UTF
   [sln] add-comp ihill_rep[2]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[3]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] conn vtoi[3].Y->switch[4].SUB
   [sln] generate switch[4].PROD = umodif
   [sln] add-comp switch[4]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vdadd[1].OUT_0 = 0.
   [sln] route vdadd[1].D = 1
   [sln] route vdadd[1].A = UTF
   [sln] route ihill_rep[2].n = 2.5
   [sln] route ihill_rep[2].S = V
   [sln] route ihill_rep[2].Vmax = 15.6
   [sln] route ihill_rep[2].Km = K2P
   [sln] route vtoi[3].K = 0.0029618
   [sln] route vtoi[3].X = IPTG
   [sln] route switch[4].n = 1000.75
   [sln] route switch[4].Kmod = 1
   [sln] route switch[4].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp vdadd1
   [comp] make-comp ihill_rep2
   [comp] make-comp vtoi3
   [comp] make-comp switch4
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)

[multi] ==== ROUTES =====
[multi] > ihill_rep[2].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[3].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[2].S = V
[multi]    - connecting generates to routes.
[multi] > switch[4].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > vdadd[1].A = UTF
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[2].n = 2.5
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.
[multi]    - making an input block.
[multi] > ihill_rep[2].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[4].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[3].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] > switch[4].Kmod = 1
[multi]    - making an input block.
[multi] > vdadd[1].D = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = U
[multi]    - making an output block.
[multi] > switch[4].PROD = umodif
[multi] > ihill_rep[2].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[3].Y = (337.632520764*IPTG)
[multi] > vtoi[3].Y = (337.632520764*IPTG)
[multi] --> Number of options 15
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 113 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vdadd[1] cfg-in OUT_0=0.
   [comp] vdadd[1] cfg-in OUT=U
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=1
   [comp] vdadd[1] cfg-in A=UTF
   [comp] ihill_rep[2] cfg-in REP=UTF
   [comp] ihill_rep[2] cfg-in n=2.5
   [comp] ihill_rep[2] cfg-in S=V
   [comp] ihill_rep[2] cfg-in Vmax=15.6
   [comp] ihill_rep[2] cfg-in Km=K2P
   [comp] vtoi[3] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[3] cfg-in K=0.0029618
   [comp] vtoi[3] cfg-in X=IPTG
   [comp] switch[4] cfg-in PROD=umodif
   [comp] switch[4] cfg-in n=1000.75
   [comp] switch[4] cfg-in Kmod=1
   [comp] switch[4] cfg-in Vmax=U
   [comp] switch[4] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vdadd[1].OUT = U
   [sln] add-comp vdadd[1]
   [sln] generate ihill_rep[2].REP = UTF
   [sln] add-comp ihill_rep[2]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[3]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] conn vtoi[3].Y->switch[4].SUB
   [sln] generate switch[4].PROD = umodif
   [sln] add-comp switch[4]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vdadd[1].OUT_0 = 0.
   [sln] route vdadd[1].D = 1
   [sln] route vdadd[1].A = UTF
   [sln] route ihill_rep[2].n = 2.5
   [sln] route ihill_rep[2].S = V
   [sln] route ihill_rep[2].Vmax = 15.6
   [sln] route ihill_rep[2].Km = K2P
   [sln] route vtoi[3].K = 0.0029618
   [sln] route vtoi[3].X = IPTG
   [sln] route switch[4].n = 1000.75
   [sln] route switch[4].Kmod = 1
   [sln] route switch[4].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp vdadd1
   [comp] make-comp ihill_rep2
   [comp] make-comp vtoi3
   [comp] make-comp switch4
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.V[2] cfg-in X=0.
     [comp] input.V[2] cfg-out O=0.
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[3] cfg-in X=1000.75
     [comp] input.V[3] cfg-out O=1000.75
     [comp] input.V[4] cfg-in X=0.0029618
     [comp] input.V[4] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [comp] input.I[5] cfg-in X=1
     [comp] input.I[5] cfg-out O=1
     [comp] output.V[0] cfg-in X=U
     [comp] output.V[0] cfg-out O=U
     [sln] rm-route ihill_rep[2].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[3].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route switch[4].Vmax = U
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route vdadd[1].A = UTF
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[2].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route vdadd[1].OUT_0 = 0.
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.
     [sln] rm-route ihill_rep[2].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[4].n = 1000.75
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 1000.75
     [sln] rm-route vtoi[3].K = 0.0029618
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0.0029618
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[4].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] rm-route vdadd[1].D = 1
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = U
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.V[2].X = 0.
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[3].X = 1000.75
     [sln] route input.V[4].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [sln] route input.I[5].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.I2
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp output.V0
     add-goal [1160] [CONN] input.I[0].O => ihill_rep[2].Km (K2P)
     add-goal [1161] [CONN] input.V[0].O => vtoi[3].X (IPTG)
     add-goal [1162] [CONN] vdadd[1].OUT => switch[4].Vmax (U)
     add-goal [1163] [CONN] switch[4].PROD => igenebind[0].K (umodif)
     add-goal [1164] [CONN] ihill_rep[2].REP => vdadd[1].A (UTF)
     add-goal [1165] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [1166] [CONN] input.V[1].O => ihill_rep[2].n (2.5)
     add-goal [1167] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.)
     add-goal [1168] [CONN] input.I[2].O => ihill_rep[2].Vmax (15.6)
     add-goal [1169] [CONN] input.V[3].O => switch[4].n (1000.75)
     add-goal [1170] [CONN] input.V[4].O => vtoi[3].K (0.0029618)
     add-goal [1171] [CONN] input.I[3].O => igenebind[0].TF (1)
     add-goal [1172] [CONN] input.I[4].O => switch[4].Kmod (1)
     add-goal [1173] [CONN] input.I[5].O => vdadd[1].D (1)
     add-goal [1174] [CONN] vdadd[1].OUT => output.V[0].X (U)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1167] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.)
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1166] [CONN] input.V[1].O => ihill_rep[2].n (2.5)
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1164] [CONN] ihill_rep[2].REP => vdadd[1].A (UTF)
[1165] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1168] [CONN] input.I[2].O => ihill_rep[2].Vmax (15.6)
[1163] [CONN] switch[4].PROD => igenebind[0].K (umodif)
[1170] [CONN] input.V[4].O => vtoi[3].K (0.0029618)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1161] [CONN] input.V[0].O => vtoi[3].X (IPTG)
[1173] [CONN] input.I[5].O => vdadd[1].D (1)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1162] [CONN] vdadd[1].OUT => switch[4].Vmax (U)
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1172] [CONN] input.I[4].O => switch[4].Kmod (1)
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1174] [CONN] vdadd[1].OUT => output.V[0].X (U)
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1169] [CONN] input.V[3].O => switch[4].n (1000.75)
[1171] [CONN] input.I[3].O => igenebind[0].TF (1)
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1160] [CONN] input.I[0].O => ihill_rep[2].Km (K2P)

============
>> Current Goal: [1160] [CONN] input.I[0].O => ihill_rep[2].Km (K2P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>ihill_rep.REP->vdadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=43

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] found # steps: 28
[multi] found # steps: 37
[multi] # partial ids = 4
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vdadd[2] cfg-in OUT_0=0.
   [comp] vdadd[2] cfg-in OUT=U
   [comp] vdadd[2] cfg-param BSW=1
   [comp] vdadd[2] cfg-param DSW=1
   [comp] vdadd[2] cfg-in B=UTF
   [comp] vdadd[2] cfg-in D=1
   [comp] vdadd[2] cfg-in A=0
   [comp] vtoi[3] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[3] cfg-in K=0.0029618
   [comp] vtoi[3] cfg-in X=IPTG
   [comp] switch[4] cfg-in PROD=umodif
   [comp] switch[4] cfg-in n=1000.75
   [comp] switch[4] cfg-in Kmod=1
   [comp] switch[4] cfg-in Vmax=U
   [comp] switch[4] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vdadd[2].OUT = U
   [sln] add-comp vdadd[2]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[3]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] conn vtoi[3].Y->switch[4].SUB
   [sln] generate switch[4].PROD = umodif
   [sln] add-comp switch[4]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vdadd[2].OUT_0 = 0.
   [sln] route vdadd[2].B = UTF
   [sln] route vdadd[2].D = 1
   [sln] route vdadd[2].A = 0
   [sln] route vtoi[3].K = 0.0029618
   [sln] route vtoi[3].X = IPTG
   [sln] route switch[4].n = 1000.75
   [sln] route switch[4].Kmod = 1
   [sln] route switch[4].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vdadd2
   [comp] make-comp vtoi3
   [comp] make-comp switch4
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)

[multi] ==== ROUTES =====
[multi] > ihill_rep[1].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[3].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[1].S = V
[multi]    - connecting generates to routes.
[multi] > switch[4].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > vdadd[2].B = UTF
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[1].n = 2.5
[multi]    - making an input block.
[multi] > vdadd[2].A = 0
[multi]    - making an input block.
[multi] > vdadd[2].OUT_0 = 0.
[multi]    - making an input block.
[multi] > ihill_rep[1].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[4].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[3].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] > switch[4].Kmod = 1
[multi]    - making an input block.
[multi] > vdadd[2].D = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[2].OUT = U
[multi]    - making an output block.
[multi] > switch[4].PROD = umodif
[multi] > ihill_rep[1].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[3].Y = (337.632520764*IPTG)
[multi] > vtoi[3].Y = (337.632520764*IPTG)
[multi] --> Number of options 16
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 115 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vdadd[2] cfg-in OUT_0=0.
   [comp] vdadd[2] cfg-in OUT=U
   [comp] vdadd[2] cfg-param BSW=1
   [comp] vdadd[2] cfg-param DSW=1
   [comp] vdadd[2] cfg-in B=UTF
   [comp] vdadd[2] cfg-in D=1
   [comp] vdadd[2] cfg-in A=0
   [comp] vtoi[3] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[3] cfg-in K=0.0029618
   [comp] vtoi[3] cfg-in X=IPTG
   [comp] switch[4] cfg-in PROD=umodif
   [comp] switch[4] cfg-in n=1000.75
   [comp] switch[4] cfg-in Kmod=1
   [comp] switch[4] cfg-in Vmax=U
   [comp] switch[4] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vdadd[2].OUT = U
   [sln] add-comp vdadd[2]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[3]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] conn vtoi[3].Y->switch[4].SUB
   [sln] generate switch[4].PROD = umodif
   [sln] add-comp switch[4]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vdadd[2].OUT_0 = 0.
   [sln] route vdadd[2].B = UTF
   [sln] route vdadd[2].D = 1
   [sln] route vdadd[2].A = 0
   [sln] route vtoi[3].K = 0.0029618
   [sln] route vtoi[3].X = IPTG
   [sln] route switch[4].n = 1000.75
   [sln] route switch[4].Kmod = 1
   [sln] route switch[4].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vdadd2
   [comp] make-comp vtoi3
   [comp] make-comp switch4
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0.
     [comp] input.V[3] cfg-out O=0.
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[4] cfg-in X=1000.75
     [comp] input.V[4] cfg-out O=1000.75
     [comp] input.V[5] cfg-in X=0.0029618
     [comp] input.V[5] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [comp] input.I[5] cfg-in X=1
     [comp] input.I[5] cfg-out O=1
     [comp] output.V[0] cfg-in X=U
     [comp] output.V[0] cfg-out O=U
     [sln] rm-route ihill_rep[1].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[3].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route switch[4].Vmax = U
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route vdadd[2].B = UTF
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[1].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route vdadd[2].A = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[2].OUT_0 = 0.
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.
     [sln] rm-route ihill_rep[1].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[4].n = 1000.75
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 1000.75
     [sln] rm-route vtoi[3].K = 0.0029618
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0.0029618
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[4].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] rm-route vdadd[2].D = 1
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = U
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0.
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[4].X = 1000.75
     [sln] route input.V[5].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [sln] route input.I[5].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I2
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp output.V0
     add-goal [1175] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
     add-goal [1176] [CONN] input.V[0].O => vtoi[3].X (IPTG)
     add-goal [1177] [CONN] vdadd[2].OUT => switch[4].Vmax (U)
     add-goal [1178] [CONN] switch[4].PROD => igenebind[0].K (umodif)
     add-goal [1179] [CONN] ihill_rep[1].REP => vdadd[2].B (UTF)
     add-goal [1180] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [1181] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
     add-goal [1182] [CONN] input.V[2].O => vdadd[2].A (0)
     add-goal [1183] [CONN] input.V[3].O => vdadd[2].OUT_0 (0.)
     add-goal [1184] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
     add-goal [1185] [CONN] input.V[4].O => switch[4].n (1000.75)
     add-goal [1186] [CONN] input.V[5].O => vtoi[3].K (0.0029618)
     add-goal [1187] [CONN] input.I[3].O => igenebind[0].TF (1)
     add-goal [1188] [CONN] input.I[4].O => switch[4].Kmod (1)
     add-goal [1189] [CONN] input.I[5].O => vdadd[2].D (1)
     add-goal [1190] [CONN] vdadd[2].OUT => output.V[0].X (U)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1177] [CONN] vdadd[2].OUT => switch[4].Vmax (U)
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1175] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
[1176] [CONN] input.V[0].O => vtoi[3].X (IPTG)
[1182] [CONN] input.V[2].O => vdadd[2].A (0)
[1183] [CONN] input.V[3].O => vdadd[2].OUT_0 (0.)
[1187] [CONN] input.I[3].O => igenebind[0].TF (1)
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1184] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
[1186] [CONN] input.V[5].O => vtoi[3].K (0.0029618)
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1179] [CONN] ihill_rep[1].REP => vdadd[2].B (UTF)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1180] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1181] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1178] [CONN] switch[4].PROD => igenebind[0].K (umodif)
[1190] [CONN] vdadd[2].OUT => output.V[0].X (U)
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1188] [CONN] input.I[4].O => switch[4].Kmod (1)
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1189] [CONN] input.I[5].O => vdadd[2].D (1)
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1185] [CONN] input.V[4].O => switch[4].n (1000.75)

============
>> Current Goal: [1185] [CONN] input.V[4].O => switch[4].n (1000.75)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>ihill_rep.REP->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=44

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] found # steps: 28
[multi] found # steps: 37
[multi] # partial ids = 4
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vdadd[2] cfg-in OUT_0=0.
   [comp] vdadd[2] cfg-in OUT=U
   [comp] vdadd[2] cfg-param BSW=1
   [comp] vdadd[2] cfg-param DSW=1
   [comp] vdadd[2] cfg-in D=1
   [comp] vdadd[2] cfg-in A=UTF
   [comp] vdadd[2] cfg-in B=0
   [comp] vtoi[3] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[3] cfg-in K=0.0029618
   [comp] vtoi[3] cfg-in X=IPTG
   [comp] switch[4] cfg-in PROD=umodif
   [comp] switch[4] cfg-in n=1000.75
   [comp] switch[4] cfg-in Kmod=1
   [comp] switch[4] cfg-in Vmax=U
   [comp] switch[4] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vdadd[2].OUT = U
   [sln] add-comp vdadd[2]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[3]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] conn vtoi[3].Y->switch[4].SUB
   [sln] generate switch[4].PROD = umodif
   [sln] add-comp switch[4]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vdadd[2].OUT_0 = 0.
   [sln] route vdadd[2].D = 1
   [sln] route vdadd[2].A = UTF
   [sln] route vdadd[2].B = 0
   [sln] route vtoi[3].K = 0.0029618
   [sln] route vtoi[3].X = IPTG
   [sln] route switch[4].n = 1000.75
   [sln] route switch[4].Kmod = 1
   [sln] route switch[4].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vdadd2
   [comp] make-comp vtoi3
   [comp] make-comp switch4
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)

[multi] ==== ROUTES =====
[multi] > ihill_rep[1].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[3].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[1].S = V
[multi]    - connecting generates to routes.
[multi] > switch[4].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > vdadd[2].A = UTF
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[1].n = 2.5
[multi]    - making an input block.
[multi] > vdadd[2].B = 0
[multi]    - making an input block.
[multi] > vdadd[2].OUT_0 = 0.
[multi]    - making an input block.
[multi] > ihill_rep[1].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[4].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[3].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] > switch[4].Kmod = 1
[multi]    - making an input block.
[multi] > vdadd[2].D = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[2].OUT = U
[multi]    - making an output block.
[multi] > switch[4].PROD = umodif
[multi] > ihill_rep[1].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[3].Y = (337.632520764*IPTG)
[multi] > vtoi[3].Y = (337.632520764*IPTG)
[multi] --> Number of options 16
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 115 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] ihill_rep[1] cfg-in REP=UTF
   [comp] ihill_rep[1] cfg-in n=2.5
   [comp] ihill_rep[1] cfg-in S=V
   [comp] ihill_rep[1] cfg-in Vmax=15.6
   [comp] ihill_rep[1] cfg-in Km=K2P
   [comp] vdadd[2] cfg-in OUT_0=0.
   [comp] vdadd[2] cfg-in OUT=U
   [comp] vdadd[2] cfg-param BSW=1
   [comp] vdadd[2] cfg-param DSW=1
   [comp] vdadd[2] cfg-in D=1
   [comp] vdadd[2] cfg-in A=UTF
   [comp] vdadd[2] cfg-in B=0
   [comp] vtoi[3] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[3] cfg-in K=0.0029618
   [comp] vtoi[3] cfg-in X=IPTG
   [comp] switch[4] cfg-in PROD=umodif
   [comp] switch[4] cfg-in n=1000.75
   [comp] switch[4] cfg-in Kmod=1
   [comp] switch[4] cfg-in Vmax=U
   [comp] switch[4] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate ihill_rep[1].REP = UTF
   [sln] add-comp ihill_rep[1]
   [sln] generate vdadd[2].OUT = U
   [sln] add-comp vdadd[2]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[3]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] conn vtoi[3].Y->switch[4].SUB
   [sln] generate switch[4].PROD = umodif
   [sln] add-comp switch[4]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route ihill_rep[1].n = 2.5
   [sln] route ihill_rep[1].S = V
   [sln] route ihill_rep[1].Vmax = 15.6
   [sln] route ihill_rep[1].Km = K2P
   [sln] route vdadd[2].OUT_0 = 0.
   [sln] route vdadd[2].D = 1
   [sln] route vdadd[2].A = UTF
   [sln] route vdadd[2].B = 0
   [sln] route vtoi[3].K = 0.0029618
   [sln] route vtoi[3].X = IPTG
   [sln] route switch[4].n = 1000.75
   [sln] route switch[4].Kmod = 1
   [sln] route switch[4].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp ihill_rep1
   [comp] make-comp vdadd2
   [comp] make-comp vtoi3
   [comp] make-comp switch4
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0.
     [comp] input.V[3] cfg-out O=0.
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[4] cfg-in X=1000.75
     [comp] input.V[4] cfg-out O=1000.75
     [comp] input.V[5] cfg-in X=0.0029618
     [comp] input.V[5] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [comp] input.I[5] cfg-in X=1
     [comp] input.I[5] cfg-out O=1
     [comp] output.V[0] cfg-in X=U
     [comp] output.V[0] cfg-out O=U
     [sln] rm-route ihill_rep[1].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[3].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route switch[4].Vmax = U
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route vdadd[2].A = UTF
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[1].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route vdadd[2].B = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[2].OUT_0 = 0.
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.
     [sln] rm-route ihill_rep[1].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[4].n = 1000.75
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 1000.75
     [sln] rm-route vtoi[3].K = 0.0029618
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0.0029618
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route switch[4].Kmod = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] rm-route vdadd[2].D = 1
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = U
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0.
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[4].X = 1000.75
     [sln] route input.V[5].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [sln] route input.I[5].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I2
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp output.V0
     add-goal [1191] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
     add-goal [1192] [CONN] input.V[0].O => vtoi[3].X (IPTG)
     add-goal [1193] [CONN] vdadd[2].OUT => switch[4].Vmax (U)
     add-goal [1194] [CONN] switch[4].PROD => igenebind[0].K (umodif)
     add-goal [1195] [CONN] ihill_rep[1].REP => vdadd[2].A (UTF)
     add-goal [1196] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [1197] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
     add-goal [1198] [CONN] input.V[2].O => vdadd[2].B (0)
     add-goal [1199] [CONN] input.V[3].O => vdadd[2].OUT_0 (0.)
     add-goal [1200] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
     add-goal [1201] [CONN] input.V[4].O => switch[4].n (1000.75)
     add-goal [1202] [CONN] input.V[5].O => vtoi[3].K (0.0029618)
     add-goal [1203] [CONN] input.I[3].O => igenebind[0].TF (1)
     add-goal [1204] [CONN] input.I[4].O => switch[4].Kmod (1)
     add-goal [1205] [CONN] input.I[5].O => vdadd[2].D (1)
     add-goal [1206] [CONN] vdadd[2].OUT => output.V[0].X (U)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1196] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1198] [CONN] input.V[2].O => vdadd[2].B (0)
[1204] [CONN] input.I[4].O => switch[4].Kmod (1)
[1206] [CONN] vdadd[2].OUT => output.V[0].X (U)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1199] [CONN] input.V[3].O => vdadd[2].OUT_0 (0.)
[1202] [CONN] input.V[5].O => vtoi[3].K (0.0029618)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1194] [CONN] switch[4].PROD => igenebind[0].K (umodif)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1192] [CONN] input.V[0].O => vtoi[3].X (IPTG)
[1201] [CONN] input.V[4].O => switch[4].n (1000.75)
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1197] [CONN] input.V[1].O => ihill_rep[1].n (2.5)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1200] [CONN] input.I[2].O => ihill_rep[1].Vmax (15.6)
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1193] [CONN] vdadd[2].OUT => switch[4].Vmax (U)
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1203] [CONN] input.I[3].O => igenebind[0].TF (1)
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1205] [CONN] input.I[5].O => vdadd[2].D (1)
[1195] [CONN] ihill_rep[1].REP => vdadd[2].A (UTF)
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1191] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)

============
>> Current Goal: [1191] [CONN] input.I[0].O => ihill_rep[1].Km (K2P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>ihill_rep.REP->vdadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=45

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi] # Found 0, Required: 1
[multi] solving target: V
[multi] search tree is not exhausted. adding existing:V
[multi] finding new partial solution
[multi] made a partial tree with 7 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}

============
>> Current Goal: [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
vdadd.OUT -> true
mm.XY -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  2 <<<
[eqn] new: [0] <vdadd> output OUT.V
<analog-st> ((vdadd.V{A}:+(vdadd.BSW*vdadd.V{B}:))-(vdadd.DSW*vdadd.I{D}:*vdadd.V{OUT}:)) ic=OUT_0.V / std=none 0
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,12000.] {v}->[v]=@ {v}->*[v]=@


checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/26
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <mm> output XY.V
<analog-st> ((mm.I{kf}:*mm.V{X}:*mm.V{Y}:)-(mm.I{kr}:*mm.V{XY}:)) ic=XY0.V / std=gauss ((0.001*mm.V{XY}:)+0.1)
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,3200.] {v}->[v]=@ {v}->*[v]=@


[eqn] [FOUND-SOLS] ===> Found <19> solutions
[slvrsearch] > weight--: <mvar-goal>V
[eqn] -> [valid?] testing node 34
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=46

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 32
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=47

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 30
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=48

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 23
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=49

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 15
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 32 ==
[multi] == Adding Local Solution : 23 ==
[multi] == Adding Local Solution : 30 ==
[multi] == Adding Local Solution : 34 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] found # steps: 26
[multi] found # steps: 28
[multi] found # steps: 37
[multi] # partial ids = 5
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vdadd[1] cfg-in OUT_0=0.
   [comp] vdadd[1] cfg-in OUT=U
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=1
   [comp] vdadd[1] cfg-in A=UTF
   [comp] ihill_rep[2] cfg-in REP=UTF
   [comp] ihill_rep[2] cfg-in n=2.5
   [comp] ihill_rep[2] cfg-in S=V
   [comp] ihill_rep[2] cfg-in Vmax=15.6
   [comp] ihill_rep[2] cfg-in Km=K2P
   [comp] vdadd[3] cfg-in OUT_0=0.
   [comp] vdadd[3] cfg-in OUT=V
   [comp] vdadd[3] cfg-param BSW=1
   [comp] vdadd[3] cfg-param DSW=1
   [comp] vdadd[3] cfg-in B=0
   [comp] vdadd[3] cfg-in A=VTF
   [comp] vdadd[3] cfg-in D=1
   [comp] vtoi[4] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[4] cfg-in K=0.0029618
   [comp] vtoi[4] cfg-in X=IPTG
   [comp] switch[5] cfg-in PROD=umodif
   [comp] switch[5] cfg-in n=1000.75
   [comp] switch[5] cfg-in Kmod=1
   [comp] switch[5] cfg-in Vmax=U
   [comp] switch[5] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vdadd[1].OUT = U
   [sln] add-comp vdadd[1]
   [sln] generate ihill_rep[2].REP = UTF
   [sln] add-comp ihill_rep[2]
   [sln] generate vdadd[3].OUT = V
   [sln] add-comp vdadd[3]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[4]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] conn vtoi[4].Y->switch[5].SUB
   [sln] generate switch[5].PROD = umodif
   [sln] add-comp switch[5]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vdadd[1].OUT_0 = 0.
   [sln] route vdadd[1].D = 1
   [sln] route vdadd[1].A = UTF
   [sln] route ihill_rep[2].n = 2.5
   [sln] route ihill_rep[2].S = V
   [sln] route ihill_rep[2].Vmax = 15.6
   [sln] route ihill_rep[2].Km = K2P
   [sln] route vdadd[3].OUT_0 = 0.
   [sln] route vdadd[3].B = 0
   [sln] route vdadd[3].A = VTF
   [sln] route vdadd[3].D = 1
   [sln] route vtoi[4].K = 0.0029618
   [sln] route vtoi[4].X = IPTG
   [sln] route switch[5].n = 1000.75
   [sln] route switch[5].Kmod = 1
   [sln] route switch[5].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp vdadd1
   [comp] make-comp ihill_rep2
   [comp] make-comp vdadd3
   [comp] make-comp vtoi4
   [comp] make-comp switch5
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1207 to disabled
   change-goal-status 1208 to disabled
   change-goal-status 1209 to disabled
   change-goal-status 1211 to disabled
   change-goal-status 1212 to disabled
   change-goal-status 1213 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)

[multi] ==== ROUTES =====
[multi] > ihill_rep[2].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[4].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[2].S = V
[multi]    - connecting generates to routes.
[multi] > switch[5].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > vdadd[1].A = UTF
[multi]    - connecting generates to routes.
[multi] > vdadd[3].A = VTF
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[2].n = 2.5
[multi]    - making an input block.
[multi] > vdadd[3].B = 0
[multi]    - making an input block.
[multi] > vdadd[3].OUT_0 = 0.
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.
[multi]    - making an input block.
[multi] > ihill_rep[2].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[5].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[4].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] > vdadd[1].D = 1
[multi]    - making an input block.
[multi] > switch[5].Kmod = 1
[multi]    - making an input block.
[multi] > vdadd[3].D = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[3].OUT = V
[multi]    - making an output block.
[multi] > vdadd[1].OUT = U
[multi]    - making an output block.
[multi] > switch[5].PROD = umodif
[multi] > ihill_rep[2].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[4].Y = (337.632520764*IPTG)
[multi] > vtoi[4].Y = (337.632520764*IPTG)
[multi] --> Number of options 21
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 141 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vdadd[1] cfg-in OUT_0=0.
   [comp] vdadd[1] cfg-in OUT=U
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=1
   [comp] vdadd[1] cfg-in A=UTF
   [comp] ihill_rep[2] cfg-in REP=UTF
   [comp] ihill_rep[2] cfg-in n=2.5
   [comp] ihill_rep[2] cfg-in S=V
   [comp] ihill_rep[2] cfg-in Vmax=15.6
   [comp] ihill_rep[2] cfg-in Km=K2P
   [comp] vdadd[3] cfg-in OUT_0=0.
   [comp] vdadd[3] cfg-in OUT=V
   [comp] vdadd[3] cfg-param BSW=1
   [comp] vdadd[3] cfg-param DSW=1
   [comp] vdadd[3] cfg-in B=0
   [comp] vdadd[3] cfg-in A=VTF
   [comp] vdadd[3] cfg-in D=1
   [comp] vtoi[4] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[4] cfg-in K=0.0029618
   [comp] vtoi[4] cfg-in X=IPTG
   [comp] switch[5] cfg-in PROD=umodif
   [comp] switch[5] cfg-in n=1000.75
   [comp] switch[5] cfg-in Kmod=1
   [comp] switch[5] cfg-in Vmax=U
   [comp] switch[5] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vdadd[1].OUT = U
   [sln] add-comp vdadd[1]
   [sln] generate ihill_rep[2].REP = UTF
   [sln] add-comp ihill_rep[2]
   [sln] generate vdadd[3].OUT = V
   [sln] add-comp vdadd[3]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[4]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] conn vtoi[4].Y->switch[5].SUB
   [sln] generate switch[5].PROD = umodif
   [sln] add-comp switch[5]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vdadd[1].OUT_0 = 0.
   [sln] route vdadd[1].D = 1
   [sln] route vdadd[1].A = UTF
   [sln] route ihill_rep[2].n = 2.5
   [sln] route ihill_rep[2].S = V
   [sln] route ihill_rep[2].Vmax = 15.6
   [sln] route ihill_rep[2].Km = K2P
   [sln] route vdadd[3].OUT_0 = 0.
   [sln] route vdadd[3].B = 0
   [sln] route vdadd[3].A = VTF
   [sln] route vdadd[3].D = 1
   [sln] route vtoi[4].K = 0.0029618
   [sln] route vtoi[4].X = IPTG
   [sln] route switch[5].n = 1000.75
   [sln] route switch[5].Kmod = 1
   [sln] route switch[5].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp vdadd1
   [comp] make-comp ihill_rep2
   [comp] make-comp vdadd3
   [comp] make-comp vtoi4
   [comp] make-comp switch5
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1207 to disabled
   change-goal-status 1208 to disabled
   change-goal-status 1209 to disabled
   change-goal-status 1211 to disabled
   change-goal-status 1212 to disabled
   change-goal-status 1213 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0.
     [comp] input.V[3] cfg-out O=0.
     [comp] input.V[4] cfg-in X=0.
     [comp] input.V[4] cfg-out O=0.
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[5] cfg-in X=1000.75
     [comp] input.V[5] cfg-out O=1000.75
     [comp] input.V[6] cfg-in X=0.0029618
     [comp] input.V[6] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [comp] input.I[5] cfg-in X=1
     [comp] input.I[5] cfg-out O=1
     [comp] input.I[6] cfg-in X=1
     [comp] input.I[6] cfg-out O=1
     [comp] output.V[0] cfg-in X=V
     [comp] output.V[0] cfg-out O=V
     [comp] output.V[1] cfg-in X=U
     [comp] output.V[1] cfg-out O=U
     [sln] rm-route ihill_rep[2].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[4].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route ihill_rep[2].S = V
     [sln] rm-route switch[5].Vmax = U
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route vdadd[1].A = UTF
     [sln] rm-route vdadd[3].A = VTF
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[2].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route vdadd[3].B = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[3].OUT_0 = 0.
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.
     [sln] rm-route vdadd[1].OUT_0 = 0.
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0.
     [sln] rm-route ihill_rep[2].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[5].n = 1000.75
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 1000.75
     [sln] rm-route vtoi[4].K = 0.0029618
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 0.0029618
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route vdadd[1].D = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] rm-route switch[5].Kmod = 1
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 1
     [sln] rm-route vdadd[3].D = 1
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = V
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = U
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0.
     [sln] route input.V[4].X = 0.
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[5].X = 1000.75
     [sln] route input.V[6].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [sln] route input.I[5].X = 1
     [sln] route input.I[6].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp input.I2
     [comp] make-comp input.V5
     [comp] make-comp input.V6
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     add-goal [1259] [CONN] input.I[0].O => ihill_rep[2].Km (K2P)
     add-goal [1260] [CONN] input.V[0].O => vtoi[4].X (IPTG)
     add-goal [1261] [CONN] vdadd[3].OUT => ihill_rep[2].S (V)
     add-goal [1262] [CONN] vdadd[1].OUT => switch[5].Vmax (U)
     add-goal [1263] [CONN] switch[5].PROD => igenebind[0].K (umodif)
     add-goal [1264] [CONN] ihill_rep[2].REP => vdadd[1].A (UTF)
     add-goal [1265] [CONN] igenebind[0].GE => vdadd[3].A (VTF)
     add-goal [1266] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [1267] [CONN] input.V[1].O => ihill_rep[2].n (2.5)
     add-goal [1268] [CONN] input.V[2].O => vdadd[3].B (0)
     add-goal [1269] [CONN] input.V[3].O => vdadd[3].OUT_0 (0.)
     add-goal [1270] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.)
     add-goal [1271] [CONN] input.I[2].O => ihill_rep[2].Vmax (15.6)
     add-goal [1272] [CONN] input.V[5].O => switch[5].n (1000.75)
     add-goal [1273] [CONN] input.V[6].O => vtoi[4].K (0.0029618)
     add-goal [1274] [CONN] input.I[3].O => igenebind[0].TF (1)
     add-goal [1275] [CONN] input.I[4].O => vdadd[1].D (1)
     add-goal [1276] [CONN] input.I[5].O => switch[5].Kmod (1)
     add-goal [1277] [CONN] input.I[6].O => vdadd[3].D (1)
     add-goal [1278] [CONN] vdadd[3].OUT => output.V[0].X (V)
     add-goal [1279] [CONN] vdadd[1].OUT => output.V[1].X (U)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1268] [CONN] input.V[2].O => vdadd[3].B (0)
[1273] [CONN] input.V[6].O => vtoi[4].K (0.0029618)
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1276] [CONN] input.I[5].O => switch[5].Kmod (1)
[1260] [CONN] input.V[0].O => vtoi[4].X (IPTG)
[1265] [CONN] igenebind[0].GE => vdadd[3].A (VTF)
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1274] [CONN] input.I[3].O => igenebind[0].TF (1)
[1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1262] [CONN] vdadd[1].OUT => switch[5].Vmax (U)
[1278] [CONN] vdadd[3].OUT => output.V[0].X (V)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1259] [CONN] input.I[0].O => ihill_rep[2].Km (K2P)
[1270] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1272] [CONN] input.V[5].O => switch[5].n (1000.75)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1271] [CONN] input.I[2].O => ihill_rep[2].Vmax (15.6)
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1275] [CONN] input.I[4].O => vdadd[1].D (1)
[1279] [CONN] vdadd[1].OUT => output.V[1].X (U)
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1263] [CONN] switch[5].PROD => igenebind[0].K (umodif)
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1266] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[1261] [CONN] vdadd[3].OUT => ihill_rep[2].S (V)
[1264] [CONN] ihill_rep[2].REP => vdadd[1].A (UTF)
[1267] [CONN] input.V[1].O => ihill_rep[2].n (2.5)
[1269] [CONN] input.V[3].O => vdadd[3].OUT_0 (0.)
[1277] [CONN] input.I[6].O => vdadd[3].D (1)
[1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}

============
>> Current Goal: [1277] [CONN] input.I[6].O => vdadd[3].D (1)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>ihill_rep.REP->vdadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->ihill_rep.S
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>igenebind.GE->vdadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=50

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: U~23UTF~97V~32VTF~169umodif~201 :: 3
[multi] Number of Solutions: 0
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: U~23UTF~97V~32VTF~169umodif~201 :: 3
[[Z3]] ---> Executing SMT Solver prob=51

[rslvr] z32cstr.wire: switch[5].PROD
[rslvr] z32cstr.wire: igenebind[0].TF
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: switch[5].SUB
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: vtoi[4].Y
[rslvr] z32cstr.wire: vtoi[4].K
[rslvr] z32cstr.wire: ihill_rep[2].REP
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: vtoi[4].X
[rslvr] z32cstr.wire: vdadd[3].OUT
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: switch[5].Vmax
[rslvr] z32cstr.wire: vdadd[3].B
[rslvr] z32cstr.wire: vdadd[3].OUT_0
[rslvr] z32cstr.wire: ihill_rep[2].Km
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: ihill_rep[2].Vmax
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: igenebind[0].GE
[rslvr] z32cstr.wire: vdadd[3].A
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: switch[5].Kmod
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: ihill_rep[2].n
[rslvr] z32cstr.wire: switch[5].n
[rslvr] z32cstr.wire: igenebind[0].K
[rslvr] z32cstr.wire: igenebind[0].Vmax
[rslvr] z32cstr.wire: vdadd[3].D
[rslvr] z32cstr.wire: ihill_rep[2].S
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_0_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_0_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_0_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_0_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=52

[rslvr] z32cstr.wire: switch[5].PROD
[rslvr] z32cstr.wire: igenebind[0].TF
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: switch[5].SUB
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: vtoi[4].Y
[rslvr] z32cstr.wire: vtoi[4].K
[rslvr] z32cstr.wire: ihill_rep[2].REP
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: vtoi[4].X
[rslvr] z32cstr.wire: vdadd[3].OUT
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: switch[5].Vmax
[rslvr] z32cstr.wire: vdadd[3].B
[rslvr] z32cstr.wire: vdadd[3].OUT_0
[rslvr] z32cstr.wire: ihill_rep[2].Km
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: ihill_rep[2].Vmax
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: igenebind[0].GE
[rslvr] z32cstr.wire: vdadd[3].A
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: switch[5].Kmod
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: ihill_rep[2].n
[rslvr] z32cstr.wire: switch[5].n
[rslvr] z32cstr.wire: igenebind[0].K
[rslvr] z32cstr.wire: igenebind[0].Vmax
[rslvr] z32cstr.wire: vdadd[3].D
[rslvr] z32cstr.wire: ihill_rep[2].S
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[5]
->input.V[6]
->input.I[1]
->vdadd[1]
->vtoi[4]
->input.I[2]
->igenebind[0]
->input.V[2]
->output.V[0]
->ihill_rep[2]
->vdadd[3]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.I[6]
->input.I[0]
->switch[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (49) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 8
[[Z3]] ---> Executing SMT Solver prob=53

[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] found # steps: 26
[multi] found # steps: 26
[multi] found # steps: 37
[multi] # partial ids = 5
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vdadd[1] cfg-in OUT_0=0.
   [comp] vdadd[1] cfg-in OUT=U
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=1
   [comp] vdadd[1] cfg-in A=UTF
   [comp] ihill_rep[2] cfg-in REP=UTF
   [comp] ihill_rep[2] cfg-in n=2.5
   [comp] ihill_rep[2] cfg-in S=V
   [comp] ihill_rep[2] cfg-in Vmax=15.6
   [comp] ihill_rep[2] cfg-in Km=K2P
   [comp] vdadd[3] cfg-in OUT_0=0.
   [comp] vdadd[3] cfg-in OUT=V
   [comp] vdadd[3] cfg-param BSW=0
   [comp] vdadd[3] cfg-param DSW=1
   [comp] vdadd[3] cfg-in D=1
   [comp] vdadd[3] cfg-in A=VTF
   [comp] vtoi[4] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[4] cfg-in K=0.0029618
   [comp] vtoi[4] cfg-in X=IPTG
   [comp] switch[5] cfg-in PROD=umodif
   [comp] switch[5] cfg-in n=1000.75
   [comp] switch[5] cfg-in Kmod=1
   [comp] switch[5] cfg-in Vmax=U
   [comp] switch[5] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vdadd[1].OUT = U
   [sln] add-comp vdadd[1]
   [sln] generate ihill_rep[2].REP = UTF
   [sln] add-comp ihill_rep[2]
   [sln] generate vdadd[3].OUT = V
   [sln] add-comp vdadd[3]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[4]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] conn vtoi[4].Y->switch[5].SUB
   [sln] generate switch[5].PROD = umodif
   [sln] add-comp switch[5]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vdadd[1].OUT_0 = 0.
   [sln] route vdadd[1].D = 1
   [sln] route vdadd[1].A = UTF
   [sln] route ihill_rep[2].n = 2.5
   [sln] route ihill_rep[2].S = V
   [sln] route ihill_rep[2].Vmax = 15.6
   [sln] route ihill_rep[2].Km = K2P
   [sln] route vdadd[3].OUT_0 = 0.
   [sln] route vdadd[3].D = 1
   [sln] route vdadd[3].A = VTF
   [sln] route vtoi[4].K = 0.0029618
   [sln] route vtoi[4].X = IPTG
   [sln] route switch[5].n = 1000.75
   [sln] route switch[5].Kmod = 1
   [sln] route switch[5].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp vdadd1
   [comp] make-comp ihill_rep2
   [comp] make-comp vdadd3
   [comp] make-comp vtoi4
   [comp] make-comp switch5
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1207 to disabled
   change-goal-status 1208 to disabled
   change-goal-status 1209 to disabled
   change-goal-status 1211 to disabled
   change-goal-status 1212 to disabled
   change-goal-status 1213 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)

[multi] ==== ROUTES =====
[multi] > ihill_rep[2].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[4].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[2].S = V
[multi]    - connecting generates to routes.
[multi] > switch[5].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > vdadd[1].A = UTF
[multi]    - connecting generates to routes.
[multi] > vdadd[3].A = VTF
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[2].n = 2.5
[multi]    - making an input block.
[multi] > vdadd[3].OUT_0 = 0.
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.
[multi]    - making an input block.
[multi] > ihill_rep[2].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[5].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[4].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] > vdadd[1].D = 1
[multi]    - making an input block.
[multi] > switch[5].Kmod = 1
[multi]    - making an input block.
[multi] > vdadd[3].D = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[3].OUT = V
[multi]    - making an output block.
[multi] > vdadd[1].OUT = U
[multi]    - making an output block.
[multi] > switch[5].PROD = umodif
[multi] > ihill_rep[2].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[4].Y = (337.632520764*IPTG)
[multi] > vtoi[4].Y = (337.632520764*IPTG)
[multi] --> Number of options 20
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 139 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vdadd[1] cfg-in OUT_0=0.
   [comp] vdadd[1] cfg-in OUT=U
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=1
   [comp] vdadd[1] cfg-in A=UTF
   [comp] ihill_rep[2] cfg-in REP=UTF
   [comp] ihill_rep[2] cfg-in n=2.5
   [comp] ihill_rep[2] cfg-in S=V
   [comp] ihill_rep[2] cfg-in Vmax=15.6
   [comp] ihill_rep[2] cfg-in Km=K2P
   [comp] vdadd[3] cfg-in OUT_0=0.
   [comp] vdadd[3] cfg-in OUT=V
   [comp] vdadd[3] cfg-param BSW=0
   [comp] vdadd[3] cfg-param DSW=1
   [comp] vdadd[3] cfg-in D=1
   [comp] vdadd[3] cfg-in A=VTF
   [comp] vtoi[4] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[4] cfg-in K=0.0029618
   [comp] vtoi[4] cfg-in X=IPTG
   [comp] switch[5] cfg-in PROD=umodif
   [comp] switch[5] cfg-in n=1000.75
   [comp] switch[5] cfg-in Kmod=1
   [comp] switch[5] cfg-in Vmax=U
   [comp] switch[5] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vdadd[1].OUT = U
   [sln] add-comp vdadd[1]
   [sln] generate ihill_rep[2].REP = UTF
   [sln] add-comp ihill_rep[2]
   [sln] generate vdadd[3].OUT = V
   [sln] add-comp vdadd[3]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[4]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] conn vtoi[4].Y->switch[5].SUB
   [sln] generate switch[5].PROD = umodif
   [sln] add-comp switch[5]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vdadd[1].OUT_0 = 0.
   [sln] route vdadd[1].D = 1
   [sln] route vdadd[1].A = UTF
   [sln] route ihill_rep[2].n = 2.5
   [sln] route ihill_rep[2].S = V
   [sln] route ihill_rep[2].Vmax = 15.6
   [sln] route ihill_rep[2].Km = K2P
   [sln] route vdadd[3].OUT_0 = 0.
   [sln] route vdadd[3].D = 1
   [sln] route vdadd[3].A = VTF
   [sln] route vtoi[4].K = 0.0029618
   [sln] route vtoi[4].X = IPTG
   [sln] route switch[5].n = 1000.75
   [sln] route switch[5].Kmod = 1
   [sln] route switch[5].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp vdadd1
   [comp] make-comp ihill_rep2
   [comp] make-comp vdadd3
   [comp] make-comp vtoi4
   [comp] make-comp switch5
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1207 to disabled
   change-goal-status 1208 to disabled
   change-goal-status 1209 to disabled
   change-goal-status 1211 to disabled
   change-goal-status 1212 to disabled
   change-goal-status 1213 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.V[2] cfg-in X=0.
     [comp] input.V[2] cfg-out O=0.
     [comp] input.V[3] cfg-in X=0.
     [comp] input.V[3] cfg-out O=0.
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[4] cfg-in X=1000.75
     [comp] input.V[4] cfg-out O=1000.75
     [comp] input.V[5] cfg-in X=0.0029618
     [comp] input.V[5] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [comp] input.I[5] cfg-in X=1
     [comp] input.I[5] cfg-out O=1
     [comp] input.I[6] cfg-in X=1
     [comp] input.I[6] cfg-out O=1
     [comp] output.V[0] cfg-in X=V
     [comp] output.V[0] cfg-out O=V
     [comp] output.V[1] cfg-in X=U
     [comp] output.V[1] cfg-out O=U
     [sln] rm-route ihill_rep[2].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[4].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route ihill_rep[2].S = V
     [sln] rm-route switch[5].Vmax = U
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route vdadd[1].A = UTF
     [sln] rm-route vdadd[3].A = VTF
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[2].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route vdadd[3].OUT_0 = 0.
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.
     [sln] rm-route vdadd[1].OUT_0 = 0.
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.
     [sln] rm-route ihill_rep[2].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[5].n = 1000.75
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 1000.75
     [sln] rm-route vtoi[4].K = 0.0029618
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0.0029618
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route vdadd[1].D = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] rm-route switch[5].Kmod = 1
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 1
     [sln] rm-route vdadd[3].D = 1
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = V
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = U
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.V[2].X = 0.
     [sln] route input.V[3].X = 0.
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[4].X = 1000.75
     [sln] route input.V[5].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [sln] route input.I[5].X = 1
     [sln] route input.I[6].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I2
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     add-goal [1280] [CONN] input.I[0].O => ihill_rep[2].Km (K2P)
     add-goal [1281] [CONN] input.V[0].O => vtoi[4].X (IPTG)
     add-goal [1282] [CONN] vdadd[3].OUT => ihill_rep[2].S (V)
     add-goal [1283] [CONN] vdadd[1].OUT => switch[5].Vmax (U)
     add-goal [1284] [CONN] switch[5].PROD => igenebind[0].K (umodif)
     add-goal [1285] [CONN] ihill_rep[2].REP => vdadd[1].A (UTF)
     add-goal [1286] [CONN] igenebind[0].GE => vdadd[3].A (VTF)
     add-goal [1287] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [1288] [CONN] input.V[1].O => ihill_rep[2].n (2.5)
     add-goal [1289] [CONN] input.V[2].O => vdadd[3].OUT_0 (0.)
     add-goal [1290] [CONN] input.V[3].O => vdadd[1].OUT_0 (0.)
     add-goal [1291] [CONN] input.I[2].O => ihill_rep[2].Vmax (15.6)
     add-goal [1292] [CONN] input.V[4].O => switch[5].n (1000.75)
     add-goal [1293] [CONN] input.V[5].O => vtoi[4].K (0.0029618)
     add-goal [1294] [CONN] input.I[3].O => igenebind[0].TF (1)
     add-goal [1295] [CONN] input.I[4].O => vdadd[1].D (1)
     add-goal [1296] [CONN] input.I[5].O => switch[5].Kmod (1)
     add-goal [1297] [CONN] input.I[6].O => vdadd[3].D (1)
     add-goal [1298] [CONN] vdadd[3].OUT => output.V[0].X (V)
     add-goal [1299] [CONN] vdadd[1].OUT => output.V[1].X (U)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1286] [CONN] igenebind[0].GE => vdadd[3].A (VTF)
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1296] [CONN] input.I[5].O => switch[5].Kmod (1)
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1289] [CONN] input.V[2].O => vdadd[3].OUT_0 (0.)
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1285] [CONN] ihill_rep[2].REP => vdadd[1].A (UTF)
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1280] [CONN] input.I[0].O => ihill_rep[2].Km (K2P)
[1290] [CONN] input.V[3].O => vdadd[1].OUT_0 (0.)
[1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1297] [CONN] input.I[6].O => vdadd[3].D (1)
[1299] [CONN] vdadd[1].OUT => output.V[1].X (U)
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1293] [CONN] input.V[5].O => vtoi[4].K (0.0029618)
[1298] [CONN] vdadd[3].OUT => output.V[0].X (V)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1295] [CONN] input.I[4].O => vdadd[1].D (1)
[1287] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1288] [CONN] input.V[1].O => ihill_rep[2].n (2.5)
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1292] [CONN] input.V[4].O => switch[5].n (1000.75)
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1284] [CONN] switch[5].PROD => igenebind[0].K (umodif)
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1283] [CONN] vdadd[1].OUT => switch[5].Vmax (U)
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1282] [CONN] vdadd[3].OUT => ihill_rep[2].S (V)
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1281] [CONN] input.V[0].O => vtoi[4].X (IPTG)
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1294] [CONN] input.I[3].O => igenebind[0].TF (1)
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1291] [CONN] input.I[2].O => ihill_rep[2].Vmax (15.6)
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}

============
>> Current Goal: [1291] [CONN] input.I[2].O => ihill_rep[2].Vmax (15.6)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->ihill_rep.S
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>ihill_rep.REP->vdadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>igenebind.GE->vdadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=54

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: U~23UTF~97V~23VTF~169umodif~201 :: 3
[multi] Number of Solutions: 1
[multi] => Global Solution: U~23UTF~97V~32VTF~169umodif~201 :: 3
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: U~23UTF~97V~23VTF~169umodif~201 :: 3
[[Z3]] ---> Executing SMT Solver prob=55

[rslvr] z32cstr.wire: switch[5].PROD
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: vtoi[4].K
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: ihill_rep[2].S
[rslvr] z32cstr.wire: switch[5].SUB
[rslvr] z32cstr.wire: vdadd[3].OUT
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: vtoi[4].X
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: switch[5].Vmax
[rslvr] z32cstr.wire: vdadd[3].OUT_0
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: ihill_rep[2].Km
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vtoi[4].Y
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: ihill_rep[2].Vmax
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: igenebind[0].GE
[rslvr] z32cstr.wire: vdadd[3].A
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: igenebind[0].TF
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: switch[5].Kmod
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: ihill_rep[2].n
[rslvr] z32cstr.wire: switch[5].n
[rslvr] z32cstr.wire: igenebind[0].K
[rslvr] z32cstr.wire: igenebind[0].Vmax
[rslvr] z32cstr.wire: vdadd[3].D
[rslvr] z32cstr.wire: ihill_rep[2].REP
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_1_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_1_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_1_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_1_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=56

[rslvr] z32cstr.wire: switch[5].PROD
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: vtoi[4].K
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: ihill_rep[2].S
[rslvr] z32cstr.wire: switch[5].SUB
[rslvr] z32cstr.wire: vdadd[3].OUT
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: vtoi[4].X
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: switch[5].Vmax
[rslvr] z32cstr.wire: vdadd[3].OUT_0
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: ihill_rep[2].Km
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vtoi[4].Y
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: ihill_rep[2].Vmax
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: igenebind[0].GE
[rslvr] z32cstr.wire: vdadd[3].A
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: igenebind[0].TF
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: switch[5].Kmod
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: ihill_rep[2].n
[rslvr] z32cstr.wire: switch[5].n
[rslvr] z32cstr.wire: igenebind[0].K
[rslvr] z32cstr.wire: igenebind[0].Vmax
[rslvr] z32cstr.wire: vdadd[3].D
[rslvr] z32cstr.wire: ihill_rep[2].REP
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[5]
->input.I[1]
->vdadd[1]
->vtoi[4]
->input.I[2]
->igenebind[0]
->input.V[2]
->output.V[0]
->ihill_rep[2]
->vdadd[3]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.I[6]
->input.I[0]
->switch[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (48) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=57

[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] found # steps: 26
[multi] found # steps: 28
[multi] found # steps: 37
[multi] # partial ids = 5
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vdadd[1] cfg-in OUT_0=0.
   [comp] vdadd[1] cfg-in OUT=U
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=1
   [comp] vdadd[1] cfg-in A=UTF
   [comp] ihill_rep[2] cfg-in REP=UTF
   [comp] ihill_rep[2] cfg-in n=2.5
   [comp] ihill_rep[2] cfg-in S=V
   [comp] ihill_rep[2] cfg-in Vmax=15.6
   [comp] ihill_rep[2] cfg-in Km=K2P
   [comp] vdadd[3] cfg-in OUT_0=0.
   [comp] vdadd[3] cfg-in OUT=V
   [comp] vdadd[3] cfg-param BSW=1
   [comp] vdadd[3] cfg-param DSW=1
   [comp] vdadd[3] cfg-in B=VTF
   [comp] vdadd[3] cfg-in D=1
   [comp] vdadd[3] cfg-in A=0
   [comp] vtoi[4] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[4] cfg-in K=0.0029618
   [comp] vtoi[4] cfg-in X=IPTG
   [comp] switch[5] cfg-in PROD=umodif
   [comp] switch[5] cfg-in n=1000.75
   [comp] switch[5] cfg-in Kmod=1
   [comp] switch[5] cfg-in Vmax=U
   [comp] switch[5] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vdadd[1].OUT = U
   [sln] add-comp vdadd[1]
   [sln] generate ihill_rep[2].REP = UTF
   [sln] add-comp ihill_rep[2]
   [sln] generate vdadd[3].OUT = V
   [sln] add-comp vdadd[3]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[4]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] conn vtoi[4].Y->switch[5].SUB
   [sln] generate switch[5].PROD = umodif
   [sln] add-comp switch[5]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vdadd[1].OUT_0 = 0.
   [sln] route vdadd[1].D = 1
   [sln] route vdadd[1].A = UTF
   [sln] route ihill_rep[2].n = 2.5
   [sln] route ihill_rep[2].S = V
   [sln] route ihill_rep[2].Vmax = 15.6
   [sln] route ihill_rep[2].Km = K2P
   [sln] route vdadd[3].OUT_0 = 0.
   [sln] route vdadd[3].B = VTF
   [sln] route vdadd[3].D = 1
   [sln] route vdadd[3].A = 0
   [sln] route vtoi[4].K = 0.0029618
   [sln] route vtoi[4].X = IPTG
   [sln] route switch[5].n = 1000.75
   [sln] route switch[5].Kmod = 1
   [sln] route switch[5].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp vdadd1
   [comp] make-comp ihill_rep2
   [comp] make-comp vdadd3
   [comp] make-comp vtoi4
   [comp] make-comp switch5
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1207 to disabled
   change-goal-status 1208 to disabled
   change-goal-status 1209 to disabled
   change-goal-status 1211 to disabled
   change-goal-status 1212 to disabled
   change-goal-status 1213 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)

[multi] ==== ROUTES =====
[multi] > ihill_rep[2].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[4].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[2].S = V
[multi]    - connecting generates to routes.
[multi] > switch[5].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > vdadd[1].A = UTF
[multi]    - connecting generates to routes.
[multi] > vdadd[3].B = VTF
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[2].n = 2.5
[multi]    - making an input block.
[multi] > vdadd[3].A = 0
[multi]    - making an input block.
[multi] > vdadd[3].OUT_0 = 0.
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.
[multi]    - making an input block.
[multi] > ihill_rep[2].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[5].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[4].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] > vdadd[1].D = 1
[multi]    - making an input block.
[multi] > switch[5].Kmod = 1
[multi]    - making an input block.
[multi] > vdadd[3].D = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[3].OUT = V
[multi]    - making an output block.
[multi] > vdadd[1].OUT = U
[multi]    - making an output block.
[multi] > switch[5].PROD = umodif
[multi] > ihill_rep[2].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[4].Y = (337.632520764*IPTG)
[multi] > vtoi[4].Y = (337.632520764*IPTG)
[multi] --> Number of options 21
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 141 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   remove-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vdadd[1] cfg-in OUT_0=0.
   [comp] vdadd[1] cfg-in OUT=U
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=1
   [comp] vdadd[1] cfg-in A=UTF
   [comp] ihill_rep[2] cfg-in REP=UTF
   [comp] ihill_rep[2] cfg-in n=2.5
   [comp] ihill_rep[2] cfg-in S=V
   [comp] ihill_rep[2] cfg-in Vmax=15.6
   [comp] ihill_rep[2] cfg-in Km=K2P
   [comp] vdadd[3] cfg-in OUT_0=0.
   [comp] vdadd[3] cfg-in OUT=V
   [comp] vdadd[3] cfg-param BSW=1
   [comp] vdadd[3] cfg-param DSW=1
   [comp] vdadd[3] cfg-in B=VTF
   [comp] vdadd[3] cfg-in D=1
   [comp] vdadd[3] cfg-in A=0
   [comp] vtoi[4] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[4] cfg-in K=0.0029618
   [comp] vtoi[4] cfg-in X=IPTG
   [comp] switch[5] cfg-in PROD=umodif
   [comp] switch[5] cfg-in n=1000.75
   [comp] switch[5] cfg-in Kmod=1
   [comp] switch[5] cfg-in Vmax=U
   [comp] switch[5] cfg-in SUB=(337.632520764*IPTG)
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vdadd[1].OUT = U
   [sln] add-comp vdadd[1]
   [sln] generate ihill_rep[2].REP = UTF
   [sln] add-comp ihill_rep[2]
   [sln] generate vdadd[3].OUT = V
   [sln] add-comp vdadd[3]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[4]
   [sln] generate vtoi[4].Y = (337.632520764*IPTG)
   [sln] conn vtoi[4].Y->switch[5].SUB
   [sln] generate switch[5].PROD = umodif
   [sln] add-comp switch[5]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vdadd[1].OUT_0 = 0.
   [sln] route vdadd[1].D = 1
   [sln] route vdadd[1].A = UTF
   [sln] route ihill_rep[2].n = 2.5
   [sln] route ihill_rep[2].S = V
   [sln] route ihill_rep[2].Vmax = 15.6
   [sln] route ihill_rep[2].Km = K2P
   [sln] route vdadd[3].OUT_0 = 0.
   [sln] route vdadd[3].B = VTF
   [sln] route vdadd[3].D = 1
   [sln] route vdadd[3].A = 0
   [sln] route vtoi[4].K = 0.0029618
   [sln] route vtoi[4].X = IPTG
   [sln] route switch[5].n = 1000.75
   [sln] route switch[5].Kmod = 1
   [sln] route switch[5].Vmax = U
   [comp] make-comp igenebind0
   [comp] make-comp vdadd1
   [comp] make-comp ihill_rep2
   [comp] make-comp vdadd3
   [comp] make-comp vtoi4
   [comp] make-comp switch5
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 1207 to disabled
   change-goal-status 1208 to disabled
   change-goal-status 1209 to disabled
   change-goal-status 1211 to disabled
   change-goal-status 1212 to disabled
   change-goal-status 1213 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[5].SUB<I>=(337.632520764*IPTG)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0.
     [comp] input.V[3] cfg-out O=0.
     [comp] input.V[4] cfg-in X=0.
     [comp] input.V[4] cfg-out O=0.
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[5] cfg-in X=1000.75
     [comp] input.V[5] cfg-out O=1000.75
     [comp] input.V[6] cfg-in X=0.0029618
     [comp] input.V[6] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [comp] input.I[5] cfg-in X=1
     [comp] input.I[5] cfg-out O=1
     [comp] input.I[6] cfg-in X=1
     [comp] input.I[6] cfg-out O=1
     [comp] output.V[0] cfg-in X=V
     [comp] output.V[0] cfg-out O=V
     [comp] output.V[1] cfg-in X=U
     [comp] output.V[1] cfg-out O=U
     [sln] rm-route ihill_rep[2].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[4].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route ihill_rep[2].S = V
     [sln] rm-route switch[5].Vmax = U
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route vdadd[1].A = UTF
     [sln] rm-route vdadd[3].B = VTF
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[2].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route vdadd[3].A = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[3].OUT_0 = 0.
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.
     [sln] rm-route vdadd[1].OUT_0 = 0.
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0.
     [sln] rm-route ihill_rep[2].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[5].n = 1000.75
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 1000.75
     [sln] rm-route vtoi[4].K = 0.0029618
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 0.0029618
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route vdadd[1].D = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] rm-route switch[5].Kmod = 1
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 1
     [sln] rm-route vdadd[3].D = 1
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = V
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = U
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0.
     [sln] route input.V[4].X = 0.
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[5].X = 1000.75
     [sln] route input.V[6].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [sln] route input.I[5].X = 1
     [sln] route input.I[6].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp input.I2
     [comp] make-comp input.V5
     [comp] make-comp input.V6
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     add-goal [1300] [CONN] input.I[0].O => ihill_rep[2].Km (K2P)
     add-goal [1301] [CONN] input.V[0].O => vtoi[4].X (IPTG)
     add-goal [1302] [CONN] vdadd[3].OUT => ihill_rep[2].S (V)
     add-goal [1303] [CONN] vdadd[1].OUT => switch[5].Vmax (U)
     add-goal [1304] [CONN] switch[5].PROD => igenebind[0].K (umodif)
     add-goal [1305] [CONN] ihill_rep[2].REP => vdadd[1].A (UTF)
     add-goal [1306] [CONN] igenebind[0].GE => vdadd[3].B (VTF)
     add-goal [1307] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [1308] [CONN] input.V[1].O => ihill_rep[2].n (2.5)
     add-goal [1309] [CONN] input.V[2].O => vdadd[3].A (0)
     add-goal [1310] [CONN] input.V[3].O => vdadd[3].OUT_0 (0.)
     add-goal [1311] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.)
     add-goal [1312] [CONN] input.I[2].O => ihill_rep[2].Vmax (15.6)
     add-goal [1313] [CONN] input.V[5].O => switch[5].n (1000.75)
     add-goal [1314] [CONN] input.V[6].O => vtoi[4].K (0.0029618)
     add-goal [1315] [CONN] input.I[3].O => igenebind[0].TF (1)
     add-goal [1316] [CONN] input.I[4].O => vdadd[1].D (1)
     add-goal [1317] [CONN] input.I[5].O => switch[5].Kmod (1)
     add-goal [1318] [CONN] input.I[6].O => vdadd[3].D (1)
     add-goal [1319] [CONN] vdadd[3].OUT => output.V[0].X (V)
     add-goal [1320] [CONN] vdadd[1].OUT => output.V[1].X (U)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1306] [CONN] igenebind[0].GE => vdadd[3].B (VTF)
[1302] [CONN] vdadd[3].OUT => ihill_rep[2].S (V)
[1320] [CONN] vdadd[1].OUT => output.V[1].X (U)
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1310] [CONN] input.V[3].O => vdadd[3].OUT_0 (0.)
[1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1316] [CONN] input.I[4].O => vdadd[1].D (1)
[1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1300] [CONN] input.I[0].O => ihill_rep[2].Km (K2P)
[1319] [CONN] vdadd[3].OUT => output.V[0].X (V)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1313] [CONN] input.V[5].O => switch[5].n (1000.75)
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1311] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.)
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1307] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1318] [CONN] input.I[6].O => vdadd[3].D (1)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1315] [CONN] input.I[3].O => igenebind[0].TF (1)
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1303] [CONN] vdadd[1].OUT => switch[5].Vmax (U)
[1314] [CONN] input.V[6].O => vtoi[4].K (0.0029618)
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1304] [CONN] switch[5].PROD => igenebind[0].K (umodif)
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1305] [CONN] ihill_rep[2].REP => vdadd[1].A (UTF)
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1309] [CONN] input.V[2].O => vdadd[3].A (0)
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1312] [CONN] input.I[2].O => ihill_rep[2].Vmax (15.6)
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1317] [CONN] input.I[5].O => switch[5].Kmod (1)
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1308] [CONN] input.V[1].O => ihill_rep[2].n (2.5)
[1301] [CONN] input.V[0].O => vtoi[4].X (IPTG)
[1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}

============
>> Current Goal: [1301] [CONN] input.V[0].O => vtoi[4].X (IPTG)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>ihill_rep.REP->vdadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->ihill_rep.S
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>igenebind.GE->vdadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=58

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: U~23UTF~97V~30VTF~169umodif~201 :: 3
[multi] Number of Solutions: 2
[multi] => Global Solution: U~23UTF~97V~23VTF~169umodif~201 :: 3
[multi] => Global Solution: U~23UTF~97V~32VTF~169umodif~201 :: 3
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: U~23UTF~97V~30VTF~169umodif~201 :: 3
[[Z3]] ---> Executing SMT Solver prob=59

[rslvr] z32cstr.wire: switch[5].PROD
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: switch[5].n
[rslvr] z32cstr.wire: switch[5].SUB
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: vtoi[4].Y
[rslvr] z32cstr.wire: vtoi[4].K
[rslvr] z32cstr.wire: ihill_rep[2].REP
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: vtoi[4].X
[rslvr] z32cstr.wire: vdadd[3].OUT
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: switch[5].Vmax
[rslvr] z32cstr.wire: vdadd[3].OUT_0
[rslvr] z32cstr.wire: vdadd[3].A
[rslvr] z32cstr.wire: ihill_rep[2].Km
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: ihill_rep[2].Vmax
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: igenebind[0].GE
[rslvr] z32cstr.wire: vdadd[3].B
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: igenebind[0].TF
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: switch[5].Kmod
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: ihill_rep[2].n
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: igenebind[0].K
[rslvr] z32cstr.wire: igenebind[0].Vmax
[rslvr] z32cstr.wire: vdadd[3].D
[rslvr] z32cstr.wire: ihill_rep[2].S
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_2_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_2_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_2_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_2_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=60

[rslvr] z32cstr.wire: switch[5].PROD
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: switch[5].n
[rslvr] z32cstr.wire: switch[5].SUB
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: vtoi[4].Y
[rslvr] z32cstr.wire: vtoi[4].K
[rslvr] z32cstr.wire: ihill_rep[2].REP
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: vtoi[4].X
[rslvr] z32cstr.wire: vdadd[3].OUT
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: switch[5].Vmax
[rslvr] z32cstr.wire: vdadd[3].OUT_0
[rslvr] z32cstr.wire: vdadd[3].A
[rslvr] z32cstr.wire: ihill_rep[2].Km
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: ihill_rep[2].Vmax
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: igenebind[0].GE
[rslvr] z32cstr.wire: vdadd[3].B
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: igenebind[0].TF
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: switch[5].Kmod
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: ihill_rep[2].n
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: igenebind[0].K
[rslvr] z32cstr.wire: igenebind[0].Vmax
[rslvr] z32cstr.wire: vdadd[3].D
[rslvr] z32cstr.wire: ihill_rep[2].S
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[5]
->input.V[6]
->input.I[1]
->vdadd[1]
->vtoi[4]
->input.I[2]
->igenebind[0]
->input.V[2]
->output.V[0]
->ihill_rep[2]
->vdadd[3]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.I[6]
->input.I[0]
->switch[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (49) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 8
[[Z3]] ---> Executing SMT Solver prob=61

[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 24
[multi] found # steps: 26
[multi] found # steps: 26
[multi] found # steps: 37
[multi] found # steps: 28
[multi] # partial ids = 5
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vdadd[1] cfg-in OUT_0=0.
   [comp] vdadd[1] cfg-in OUT=U
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=1
   [comp] vdadd[1] cfg-in A=UTF
   [comp] ihill_rep[2] cfg-in REP=UTF
   [comp] ihill_rep[2] cfg-in n=2.5
   [comp] ihill_rep[2] cfg-in S=V
   [comp] ihill_rep[2] cfg-in Vmax=15.6
   [comp] ihill_rep[2] cfg-in Km=K2P
   [comp] vtoi[3] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[3] cfg-in K=0.0029618
   [comp] vtoi[3] cfg-in X=IPTG
   [comp] switch[4] cfg-in PROD=umodif
   [comp] switch[4] cfg-in n=1000.75
   [comp] switch[4] cfg-in Kmod=1
   [comp] switch[4] cfg-in Vmax=U
   [comp] switch[4] cfg-in SUB=(337.632520764*IPTG)
   [comp] vdadd[5] cfg-in OUT_0=0.
   [comp] vdadd[5] cfg-in OUT=V
   [comp] vdadd[5] cfg-param BSW=1
   [comp] vdadd[5] cfg-param DSW=1
   [comp] vdadd[5] cfg-in D=1
   [comp] vdadd[5] cfg-in B=0
   [comp] vdadd[5] cfg-in A=VTF
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vdadd[1].OUT = U
   [sln] add-comp vdadd[1]
   [sln] generate ihill_rep[2].REP = UTF
   [sln] add-comp ihill_rep[2]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[3]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] conn vtoi[3].Y->switch[4].SUB
   [sln] generate switch[4].PROD = umodif
   [sln] add-comp switch[4]
   [sln] generate vdadd[5].OUT = V
   [sln] add-comp vdadd[5]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vdadd[1].OUT_0 = 0.
   [sln] route vdadd[1].D = 1
   [sln] route vdadd[1].A = UTF
   [sln] route ihill_rep[2].n = 2.5
   [sln] route ihill_rep[2].S = V
   [sln] route ihill_rep[2].Vmax = 15.6
   [sln] route ihill_rep[2].Km = K2P
   [sln] route vtoi[3].K = 0.0029618
   [sln] route vtoi[3].X = IPTG
   [sln] route switch[4].n = 1000.75
   [sln] route switch[4].Kmod = 1
   [sln] route switch[4].Vmax = U
   [sln] route vdadd[5].OUT_0 = 0.
   [sln] route vdadd[5].D = 1
   [sln] route vdadd[5].B = 0
   [sln] route vdadd[5].A = VTF
   [comp] make-comp igenebind0
   [comp] make-comp vdadd1
   [comp] make-comp ihill_rep2
   [comp] make-comp vtoi3
   [comp] make-comp switch4
   [comp] make-comp vdadd5
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 1207 to disabled
   change-goal-status 1208 to disabled
   change-goal-status 1209 to disabled
   change-goal-status 1211 to disabled
   change-goal-status 1212 to disabled
   change-goal-status 1213 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   add-goal [1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ==== ROUTES =====
[multi] > ihill_rep[2].Km = K2P
[multi]    - making an input block.
[multi] > vtoi[3].X = IPTG
[multi]    - making an input block.
[multi] > ihill_rep[2].S = V
[multi]    - connecting generates to routes.
[multi] > switch[4].Vmax = U
[multi]    - connecting generates to routes.
[multi] > igenebind[0].K = umodif
[multi]    - connecting generates to routes.
[multi] > vdadd[1].A = UTF
[multi]    - connecting generates to routes.
[multi] > vdadd[5].A = VTF
[multi]    - connecting generates to routes.
[multi] > igenebind[0].Vmax = 13.32
[multi]    - making an input block.
[multi] > ihill_rep[2].n = 2.5
[multi]    - making an input block.
[multi] > vdadd[5].B = 0
[multi]    - making an input block.
[multi] > vdadd[5].OUT_0 = 0.
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.
[multi]    - making an input block.
[multi] > ihill_rep[2].Vmax = 15.6
[multi]    - making an input block.
[multi] > switch[4].n = 1000.75
[multi]    - making an input block.
[multi] > vtoi[3].K = 0.0029618
[multi]    - making an input block.
[multi] > igenebind[0].TF = 1
[multi]    - making an input block.
[multi] > vdadd[1].D = 1
[multi]    - making an input block.
[multi] > vdadd[5].D = 1
[multi]    - making an input block.
[multi] > switch[4].Kmod = 1
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[5].OUT = V
[multi]    - making an output block.
[multi] > vdadd[1].OUT = U
[multi]    - making an output block.
[multi] > switch[4].PROD = umodif
[multi] > ihill_rep[2].REP = UTF
[multi] > igenebind[0].GE = VTF
[multi] > vtoi[3].Y = (337.632520764*IPTG)
[multi] > vtoi[3].Y = (337.632520764*IPTG)
[multi] --> Number of options 21
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 141 =======
[multi]    remove-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   remove-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   remove-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   remove-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   remove-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   remove-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   [comp] igenebind[0] cfg-in GE=VTF
   [comp] igenebind[0] cfg-in TF=1
   [comp] igenebind[0] cfg-in Vmax=13.32
   [comp] igenebind[0] cfg-in K=umodif
   [comp] vdadd[1] cfg-in OUT_0=0.
   [comp] vdadd[1] cfg-in OUT=U
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=1
   [comp] vdadd[1] cfg-in A=UTF
   [comp] ihill_rep[2] cfg-in REP=UTF
   [comp] ihill_rep[2] cfg-in n=2.5
   [comp] ihill_rep[2] cfg-in S=V
   [comp] ihill_rep[2] cfg-in Vmax=15.6
   [comp] ihill_rep[2] cfg-in Km=K2P
   [comp] vtoi[3] cfg-in Y=(337.632520764*IPTG)
   [comp] vtoi[3] cfg-in K=0.0029618
   [comp] vtoi[3] cfg-in X=IPTG
   [comp] switch[4] cfg-in PROD=umodif
   [comp] switch[4] cfg-in n=1000.75
   [comp] switch[4] cfg-in Kmod=1
   [comp] switch[4] cfg-in Vmax=U
   [comp] switch[4] cfg-in SUB=(337.632520764*IPTG)
   [comp] vdadd[5] cfg-in OUT_0=0.
   [comp] vdadd[5] cfg-in OUT=V
   [comp] vdadd[5] cfg-param BSW=1
   [comp] vdadd[5] cfg-param DSW=1
   [comp] vdadd[5] cfg-in D=1
   [comp] vdadd[5] cfg-in B=0
   [comp] vdadd[5] cfg-in A=VTF
   [sln] generate igenebind[0].GE = VTF
   [sln] add-comp igenebind[0]
   [sln] generate vdadd[1].OUT = U
   [sln] add-comp vdadd[1]
   [sln] generate ihill_rep[2].REP = UTF
   [sln] add-comp ihill_rep[2]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] add-comp vtoi[3]
   [sln] generate vtoi[3].Y = (337.632520764*IPTG)
   [sln] conn vtoi[3].Y->switch[4].SUB
   [sln] generate switch[4].PROD = umodif
   [sln] add-comp switch[4]
   [sln] generate vdadd[5].OUT = V
   [sln] add-comp vdadd[5]
   [sln] route igenebind[0].TF = 1
   [sln] route igenebind[0].Vmax = 13.32
   [sln] route igenebind[0].K = umodif
   [sln] route vdadd[1].OUT_0 = 0.
   [sln] route vdadd[1].D = 1
   [sln] route vdadd[1].A = UTF
   [sln] route ihill_rep[2].n = 2.5
   [sln] route ihill_rep[2].S = V
   [sln] route ihill_rep[2].Vmax = 15.6
   [sln] route ihill_rep[2].Km = K2P
   [sln] route vtoi[3].K = 0.0029618
   [sln] route vtoi[3].X = IPTG
   [sln] route switch[4].n = 1000.75
   [sln] route switch[4].Kmod = 1
   [sln] route switch[4].Vmax = U
   [sln] route vdadd[5].OUT_0 = 0.
   [sln] route vdadd[5].D = 1
   [sln] route vdadd[5].B = 0
   [sln] route vdadd[5].A = VTF
   [comp] make-comp igenebind0
   [comp] make-comp vdadd1
   [comp] make-comp ihill_rep2
   [comp] make-comp vtoi3
   [comp] make-comp switch4
   [comp] make-comp vdadd5
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 3 to disabled
   change-goal-status 4 to disabled
   change-goal-status 5 to disabled
   change-goal-status 1092 to disabled
   change-goal-status 1093 to disabled
   change-goal-status 1094 to disabled
   change-goal-status 1095 to disabled
   change-goal-status 1097 to disabled
   change-goal-status 1098 to disabled
   change-goal-status 272 to disabled
   change-goal-status 273 to disabled
   change-goal-status 274 to disabled
   change-goal-status 275 to disabled
   change-goal-status 276 to disabled
   change-goal-status 278 to disabled
   change-goal-status 668 to disabled
   change-goal-status 669 to disabled
   change-goal-status 670 to disabled
   change-goal-status 671 to disabled
   change-goal-status 672 to disabled
   change-goal-status 673 to disabled
   change-goal-status 1207 to disabled
   change-goal-status 1208 to disabled
   change-goal-status 1209 to disabled
   change-goal-status 1211 to disabled
   change-goal-status 1212 to disabled
   change-goal-status 1213 to disabled
   add-goal [0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [6] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1096] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [277] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [667] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
   add-goal [759] [EXPR]switch[4].SUB<I>=(337.632520764*IPTG)
   add-goal [1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
   add-goal [1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
   add-goal [1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
   add-goal [1210] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
   add-goal [1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
   add-goal [1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
   add-goal [1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=K2P
     [comp] input.I[0] cfg-out O=K2P
     [comp] input.V[0] cfg-in X=IPTG
     [comp] input.V[0] cfg-out O=IPTG
     [comp] input.I[1] cfg-in X=13.32
     [comp] input.I[1] cfg-out O=13.32
     [comp] input.V[1] cfg-in X=2.5
     [comp] input.V[1] cfg-out O=2.5
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0.
     [comp] input.V[3] cfg-out O=0.
     [comp] input.V[4] cfg-in X=0.
     [comp] input.V[4] cfg-out O=0.
     [comp] input.I[2] cfg-in X=15.6
     [comp] input.I[2] cfg-out O=15.6
     [comp] input.V[5] cfg-in X=1000.75
     [comp] input.V[5] cfg-out O=1000.75
     [comp] input.V[6] cfg-in X=0.0029618
     [comp] input.V[6] cfg-out O=0.0029618
     [comp] input.I[3] cfg-in X=1
     [comp] input.I[3] cfg-out O=1
     [comp] input.I[4] cfg-in X=1
     [comp] input.I[4] cfg-out O=1
     [comp] input.I[5] cfg-in X=1
     [comp] input.I[5] cfg-out O=1
     [comp] input.I[6] cfg-in X=1
     [comp] input.I[6] cfg-out O=1
     [comp] output.V[0] cfg-in X=V
     [comp] output.V[0] cfg-out O=V
     [comp] output.V[1] cfg-in X=U
     [comp] output.V[1] cfg-out O=U
     [sln] rm-route ihill_rep[2].Km = K2P
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = K2P
     [sln] rm-route vtoi[3].X = IPTG
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = IPTG
     [sln] rm-route ihill_rep[2].S = V
     [sln] rm-route switch[4].Vmax = U
     [sln] rm-route igenebind[0].K = umodif
     [sln] rm-route vdadd[1].A = UTF
     [sln] rm-route vdadd[5].A = VTF
     [sln] rm-route igenebind[0].Vmax = 13.32
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 13.32
     [sln] rm-route ihill_rep[2].n = 2.5
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 2.5
     [sln] rm-route vdadd[5].B = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[5].OUT_0 = 0.
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0.
     [sln] rm-route vdadd[1].OUT_0 = 0.
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0.
     [sln] rm-route ihill_rep[2].Vmax = 15.6
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 15.6
     [sln] rm-route switch[4].n = 1000.75
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 1000.75
     [sln] rm-route vtoi[3].K = 0.0029618
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 0.0029618
     [sln] rm-route igenebind[0].TF = 1
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 1
     [sln] rm-route vdadd[1].D = 1
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 1
     [sln] rm-route vdadd[5].D = 1
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 1
     [sln] rm-route switch[4].Kmod = 1
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 1
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = V
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = U
     [sln] route input.I[0].X = K2P
     [sln] route input.V[0].X = IPTG
     [sln] route input.I[1].X = 13.32
     [sln] route input.V[1].X = 2.5
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0.
     [sln] route input.V[4].X = 0.
     [sln] route input.I[2].X = 15.6
     [sln] route input.V[5].X = 1000.75
     [sln] route input.V[6].X = 0.0029618
     [sln] route input.I[3].X = 1
     [sln] route input.I[4].X = 1
     [sln] route input.I[5].X = 1
     [sln] route input.I[6].X = 1
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp input.I2
     [comp] make-comp input.V5
     [comp] make-comp input.V6
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     add-goal [1321] [CONN] input.I[0].O => ihill_rep[2].Km (K2P)
     add-goal [1322] [CONN] input.V[0].O => vtoi[3].X (IPTG)
     add-goal [1323] [CONN] vdadd[5].OUT => ihill_rep[2].S (V)
     add-goal [1324] [CONN] vdadd[1].OUT => switch[4].Vmax (U)
     add-goal [1325] [CONN] switch[4].PROD => igenebind[0].K (umodif)
     add-goal [1326] [CONN] ihill_rep[2].REP => vdadd[1].A (UTF)
     add-goal [1327] [CONN] igenebind[0].GE => vdadd[5].A (VTF)
     add-goal [1328] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
     add-goal [1329] [CONN] input.V[1].O => ihill_rep[2].n (2.5)
     add-goal [1330] [CONN] input.V[2].O => vdadd[5].B (0)
     add-goal [1331] [CONN] input.V[3].O => vdadd[5].OUT_0 (0.)
     add-goal [1332] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.)
     add-goal [1333] [CONN] input.I[2].O => ihill_rep[2].Vmax (15.6)
     add-goal [1334] [CONN] input.V[5].O => switch[4].n (1000.75)
     add-goal [1335] [CONN] input.V[6].O => vtoi[3].K (0.0029618)
     add-goal [1336] [CONN] input.I[3].O => igenebind[0].TF (1)
     add-goal [1337] [CONN] input.I[4].O => vdadd[1].D (1)
     add-goal [1338] [CONN] input.I[5].O => vdadd[5].D (1)
     add-goal [1339] [CONN] input.I[6].O => switch[4].Kmod (1)
     add-goal [1340] [CONN] vdadd[5].OUT => output.V[0].X (V)
     add-goal [1341] [CONN] vdadd[1].OUT => output.V[1].X (U)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1095] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1335] [CONN] input.V[6].O => vtoi[3].K (0.0029618)
[1097] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1341] [CONN] vdadd[1].OUT => output.V[1].X (U)
[668] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[274] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[671] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1329] [CONN] input.V[1].O => ihill_rep[2].n (2.5)
[1209] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1322] [CONN] input.V[0].O => vtoi[3].X (IPTG)
[1334] [CONN] input.V[5].O => switch[4].n (1000.75)
[1336] [CONN] input.I[3].O => igenebind[0].TF (1)
[1213] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1323] [CONN] vdadd[5].OUT => ihill_rep[2].S (V)
[1331] [CONN] input.V[3].O => vdadd[5].OUT_0 (0.)
[278] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1094] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1326] [CONN] ihill_rep[2].REP => vdadd[1].A (UTF)
[0] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[275] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[669] [MATH]input IPTG :> <input> {[IPTG]=[0.,0.6]}
[1324] [CONN] vdadd[1].OUT => switch[4].Vmax (U)
[1339] [CONN] input.I[6].O => switch[4].Kmod (1)
[276] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1321] [CONN] input.I[0].O => ihill_rep[2].Km (K2P)
[1338] [CONN] input.I[5].O => vdadd[5].D (1)
[670] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1327] [CONN] igenebind[0].GE => vdadd[5].A (VTF)
[1211] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[1098] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[673] [MATH]local VTF :> VTF=((Cv*a2)*((K2^gamma)/((K2^gamma)+(umodif^gamma)))) / std(VTF) = none 0 {[VTF]=[0.802409638554,13.32]}
[1330] [CONN] input.V[2].O => vdadd[5].B (0)
[1332] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.)
[272] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[1212] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1325] [CONN] switch[4].PROD => igenebind[0].K (umodif)
[1340] [CONN] vdadd[5].OUT => output.V[0].X (V)
[3] [MATH]output V :> ddt V=((VTF/Cv)-(kdeg*V)) ic=0. / std(ddt V) = none 0 {[ddt V]=[-12.5175903614,13.32] / [V]=[0.,13.32] / max-sample = <none>min-speed = <none>}
[1093] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1208] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1337] [CONN] input.I[4].O => vdadd[1].D (1)
[1092] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}
[4] [MATH]output U :> ddt U=((UTF/Cu)-(kdeg*U)) ic=0. / std(ddt U) = none 0 {[ddt U]=[-15.575945637,15.6] / [U]=[0.,15.6] / max-sample = <none>min-speed = <none>}
[5] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[273] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[672] [MATH]local UTF :> UTF=((Cu*a1)*((K2P^beta)/((K2P^beta)+(V^beta)))) / std(UTF) = none 0 {[UTF]=[0.0240543630064,15.6]}
[1] [MATH]input K2P :> <input> {[K2P]=[1.,1.]}
[1333] [CONN] input.I[2].O => ihill_rep[2].Vmax (15.6)
[1328] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[1207] [MATH]local umodif :> umodif=(U*(1/((1+(IPTG/K))^nu))) / std(umodif) = none 0 {[umodif]=[0.,15.6]}

============
>> Current Goal: [1328] [CONN] input.I[1].O => igenebind[0].Vmax (13.32)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>switch.PROD->igenebind.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>igenebind.GE->vdadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->ihill_rep.Km
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->switch.Kmod
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->switch.Vmax
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>ihill_rep.REP->vdadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->ihill_rep.S
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->igenebind.TF
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->switch.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->ihill_rep.n
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=62

[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: U~23UTF~97V~34VTF~169umodif~201 :: 3
[multi] Number of Solutions: 3
[multi] => Global Solution: U~23UTF~97V~30VTF~169umodif~201 :: 3
[multi] => Global Solution: U~23UTF~97V~23VTF~169umodif~201 :: 3
[multi] => Global Solution: U~23UTF~97V~32VTF~169umodif~201 :: 3
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: U~23UTF~97V~34VTF~169umodif~201 :: 3
[[Z3]] ---> Executing SMT Solver prob=63

[rslvr] z32cstr.wire: switch[4].Vmax
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: ihill_rep[2].S
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: vtoi[3].K
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: switch[4].n
[rslvr] z32cstr.wire: ihill_rep[2].REP
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: igenebind[0].K
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vdadd[5].B
[rslvr] z32cstr.wire: ihill_rep[2].Vmax
[rslvr] z32cstr.wire: ihill_rep[2].Km
[rslvr] z32cstr.wire: ihill_rep[2].n
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: vdadd[5].D
[rslvr] z32cstr.wire: switch[4].PROD
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: vtoi[3].Y
[rslvr] z32cstr.wire: igenebind[0].GE
[rslvr] z32cstr.wire: vdadd[5].A
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: switch[4].SUB
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: igenebind[0].TF
[rslvr] z32cstr.wire: vdadd[5].OUT
[rslvr] z32cstr.wire: igenebind[0].Vmax
[rslvr] z32cstr.wire: vtoi[3].X
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vdadd[5].OUT_0
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: switch[4].Kmod
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_3_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_3_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_3_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_gentoggle_3_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=64

[rslvr] z32cstr.wire: switch[4].Vmax
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: ihill_rep[2].S
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: vtoi[3].K
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: switch[4].n
[rslvr] z32cstr.wire: ihill_rep[2].REP
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: igenebind[0].K
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vdadd[5].B
[rslvr] z32cstr.wire: ihill_rep[2].Vmax
[rslvr] z32cstr.wire: ihill_rep[2].Km
[rslvr] z32cstr.wire: ihill_rep[2].n
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: vdadd[5].D
[rslvr] z32cstr.wire: switch[4].PROD
[rslvr] z32cstr.wire: input.I[5].O
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: vtoi[3].Y
[rslvr] z32cstr.wire: igenebind[0].GE
[rslvr] z32cstr.wire: vdadd[5].A
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: switch[4].SUB
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: igenebind[0].TF
[rslvr] z32cstr.wire: vdadd[5].OUT
[rslvr] z32cstr.wire: igenebind[0].Vmax
[rslvr] z32cstr.wire: vtoi[3].X
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vdadd[5].OUT_0
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: switch[4].Kmod
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[5]
->input.V[6]
->input.I[1]
->vdadd[5]
->vdadd[1]
->input.I[2]
->switch[4]
->igenebind[0]
->input.V[2]
->output.V[0]
->ihill_rep[2]
->input.V[1]
->input.V[5]
->vtoi[3]
->output.V[1]
->input.V[3]
->input.I[6]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (49) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 8
[[Z3]] ---> Executing SMT Solver prob=65

[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
[WARN][to_mat_file] cannot generate mapped simulink file
[WARN][to_mat_file] cannot emit code
===== Mapping Step Finished ======
[multi] # Found 4, Required: 1
[multi] [DONE] found enough solutions
[multi] ===== Getting Solutions =====
[multi] Number of Solutions: 4
[multi] => Global Solution: U~23UTF~97V~30VTF~169umodif~201 :: 3
[multi] => Global Solution: U~23UTF~97V~23VTF~169umodif~201 :: 3
[multi] => Global Solution: U~23UTF~97V~32VTF~169umodif~201 :: 3
[multi] => Global Solution: U~23UTF~97V~34VTF~169umodif~201 :: 3
