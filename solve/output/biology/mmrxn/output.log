==== Loaded Config File (benchmarks/biology/configs/prod.cfg) ====
bool enable-jaunt true
int multi-num-global-solutions 1
bool eqn-use-map-heuristic true
int slvr-solutions 1
string multi-selector-branch solved-and-ncomps
int multi-num-global-solutions-per-partial 1
int slvr-partial-depth 15
int interactive 0
int eqn-unifications 12
int multi-num-partial-solutions 1
int map-infer-feasible-timeout 60
int slvr-global-depth 30
int debug 2
string eqn-selector-goal trivial
int z3-minimize-depth 4
int uast-depth 5
string uast-selector-branch uniform
bool _force false
string z3-minimize-strategy binary
string eqn-selector-branch goals
=================================
======== Infer Math Vars =============
derive: S -> [-1.32468e-05,0.003241]
derive: P -> [0.,0.000294]
derive: E -> [-1.32468e-05,0.003241]
derive: ES -> [-0.003535,1.32468e-05]
inference hw vars
-> derived [0.,5000.] -> P
-> derived [0.,10.] -> PROD
-> derived [0.,3300.] -> Y
-> derived [0.,10.] -> REP2
-> derived [0.,1.] -> Y
-> derived [0.,80000.] -> REP
-> derived [0.,1000000.] -> STIM
-> derived [0.,10.] -> Y
-> derived {[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } -> OUT
-> derived [0.,10.] -> Y
-> derived [-5.,10.] -> OUT
-> derived [0.,10.] -> Y
-> derived [0.,10.] -> GE
==== Units ====
==== Vars =====
> MAKE vgain
input(<vgain,X>)
cover
input(<vgain,Z>)
cover
output(<vgain,P>)
cover
=
=
offset(<vgain,X>)=0
offset(<vgain,Z>)=0
ve(scale(<vgain,P>)=scale(<vgain,X>)*scale(<vgain,Z>))
offset(<vgain,P>)=0
>>> # Partitions vgain=4
> MAKE switch
input(<switch,n>)
cover
input(<switch,SUB>)
cover
input(<switch,Kmod>)
cover
input(<switch,Vmax>)
cover
output(<switch,PROD>)
cover
=
=
offset(<switch,SUB>)=0
offset(<switch,Kmod>)=0
ee(scale(<switch,Kmod>)^-1*scale(<switch,SUB>)=scale(<switch,Kmod>)^-1*scale(<switch,SUB>))
ee(1=scale(<switch,Kmod>)^-1*scale(<switch,SUB>))
ee(scale(<switch,Kmod>)^-1*scale(<switch,SUB>)=1)
ee(1=1)
=
offset(<switch,n>)=0
valid
ec(0+0=0)
valid
ec(scale(<switch,n>)/1=1)
valid
valid
=
offset(<switch,Vmax>)=0
valid
ve(scale(<switch,PROD>)=1/1^(switch.V{n}:/500.)*scale(<switch,Vmax>))
offset(<switch,PROD>)=0
>>> # Partitions switch=7
> MAKE ihill_stim
input(<ihill_stim,n>)
cover
input(<ihill_stim,S>)
cover
input(<ihill_stim,Km>)
cover
input(<ihill_stim,Vmax>)
cover
output(<ihill_stim,STIM>)
cover
=
=
offset(<ihill_stim,S>)=0
offset(<ihill_stim,Km>)=0
=
valid
offset(<ihill_stim,n>)=0
scale(<ihill_stim,n>)=1
=
=
offset(<ihill_stim,S>)=0
offset(<ihill_stim,Km>)=0
=
valid
offset(<ihill_stim,n>)=0
scale(<ihill_stim,n>)=1
ee(scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:=scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:)
ee(1=scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:)
ee(scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:=1)
ee(1=1)
valid
ec(0+0=0)
=
ve(scale(<ihill_stim,STIM>)=scale(<ihill_stim,Vmax>)*scale(<ihill_stim,S>)/scale(<ihill_stim,Km>)^ihill_stim.V{n}:/1)
offset(<ihill_stim,STIM>)=0
>>> # Partitions ihill_stim=6
> MAKE ihill_rep
input(<ihill_rep,n>)
cover
input(<ihill_rep,S>)
cover
input(<ihill_rep,Km>)
cover
input(<ihill_rep,Vmax>)
cover
output(<ihill_rep,REP>)
cover
=
=
offset(<ihill_rep,Km>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
=
=
offset(<ihill_rep,S>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
=
=
offset(<ihill_rep,Km>)=0
offset(<ihill_rep,n>)=0
scale(<ihill_rep,n>)=1
ee(scale(<ihill_rep,Km>)^ihill_rep.V{n}:=scale(<ihill_rep,Km>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,S>)^ihill_rep.V{n}:=scale(<ihill_rep,Km>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,Km>)^ihill_rep.V{n}:=scale(<ihill_rep,S>)^ihill_rep.V{n}:)
ee(scale(<ihill_rep,S>)^ihill_rep.V{n}:=scale(<ihill_rep,S>)^ihill_rep.V{n}:)
valid
ec(0+0=0)
=
offset(<ihill_rep,Vmax>)=0
valid
ve(scale(<ihill_rep,REP>)=scale(<ihill_rep,Km>)^ihill_rep.V{n}:/scale(<ihill_rep,S>)^ihill_rep.V{n}:*scale(<ihill_rep,Vmax>))
offset(<ihill_rep,REP>)=0
>>> # Partitions ihill_rep=7
> MAKE vdadd
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
=
=
valid
offset(<vdadd,D>)=0
offset(<vdadd,OUT>)=0
=
valid
offset(<vdadd,B>)=0
=
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=3
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
=
=
valid
offset(<vdadd,D>)=0
offset(<vdadd,OUT>)=0
=
=
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=3
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
=
=
=
valid
offset(<vdadd,B>)=0
=
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=3
par(<vdadd,BSW>)
par(<vdadd,DSW>)
input(<vdadd,D>)
cover
input(<vdadd,OUT_0>)
cover
input(<vdadd,A>)
cover
input(<vdadd,B>)
cover
output(<vdadd,OUT>)
cover
OUT
=
=
=
=
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
vv(scale(<vdadd,B>)=scale(<vdadd,A>))
vv(scale(<vdadd,A>)=scale(<vdadd,B>))
vv(scale(<vdadd,B>)=scale(<vdadd,B>))
vv(scale(<vdadd,A>)=scale(<vdadd,A>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ve(scale(<vdadd,A>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
ee(scale(<vdadd,D>)*scale(<vdadd,OUT>)=scale(<vdadd,D>)*scale(<vdadd,OUT>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,A>))
offset(<vdadd,OUT>)=0
=
priority
vv(offset(<vdadd,OUT>)=offset(<vdadd,A>))
vv(scale(<vdadd,OUT>)=scale(<vdadd,OUT_0>))
vv(offset(<vdadd,OUT>)=offset(<vdadd,OUT_0>))
>>> # Partitions vdadd=3
> MAKE ihill_rep2
input(<ihill_rep2,n>)
cover
input(<ihill_rep2,S>)
cover
input(<ihill_rep2,Vmax>)
cover
output(<ihill_rep2,REP2>)
cover
=
=
offset(<ihill_rep2,S>)=0
offset(<ihill_rep2,n>)=0
scale(<ihill_rep2,n>)=1
ee(scale(<ihill_rep2,S>)^ihill_rep2.V{n}:=scale(<ihill_rep2,S>)^ihill_rep2.V{n}:)
ee(1=scale(<ihill_rep2,S>)^ihill_rep2.V{n}:)
ee(scale(<ihill_rep2,S>)^ihill_rep2.V{n}:=1)
ee(1=1)
valid
ec(0+0=0)
=
offset(<ihill_rep2,Vmax>)=0
valid
vv(scale(<ihill_rep2,REP2>)=scale(<ihill_rep2,Vmax>))
offset(<ihill_rep2,REP2>)=0
>>> # Partitions ihill_rep2=4
> MAKE input.I
input(<input.I,X>)
cover
output(<input.I,O>)
cover
=
vv(scale(<input.I,O>)=scale(<input.I,X>))
vv(offset(<input.I,O>)=offset(<input.I,X>))
>>> # Partitions input.I=2
> MAKE output.V
input(<output.V,X>)
cover
output(<output.V,O>)
cover
=
vv(scale(<output.V,O>)=scale(<output.V,X>))
vv(offset(<output.V,O>)=offset(<output.V,X>))
>>> # Partitions output.V=2
> MAKE copy.V
input(<copy.V,X>)
cover
output(<copy.V,Y>)
cover
=
vv(scale(<copy.V,Y>)=scale(<copy.V,X>))
vv(offset(<copy.V,Y>)=offset(<copy.V,X>))
>>> # Partitions copy.V=2
> MAKE vadd
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
=
valid
offset(<vadd,C>)=0
=
valid
offset(<vadd,B>)=0
=
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=2
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
=
valid
offset(<vadd,C>)=0
=
=
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=2
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
=
=
valid
offset(<vadd,B>)=0
=
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=2
par(<vadd,BSW>)
par(<vadd,CSW>)
input(<vadd,C>)
cover
input(<vadd,A>)
cover
input(<vadd,B>)
cover
output(<vadd,OUT>)
cover
=
=
=
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,B>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,B>))
vv(scale(<vadd,B>)=scale(<vadd,B>))
vv(scale(<vadd,A>)=scale(<vadd,A>))
vv(scale(<vadd,C>)=scale(<vadd,A>))
vv(scale(<vadd,A>)=scale(<vadd,C>))
vv(scale(<vadd,C>)=scale(<vadd,C>))
ec(offset(<vadd,A>)+0+0=0)
valid
vv(scale(<vadd,OUT>)=scale(<vadd,A>))
offset(<vadd,OUT>)=0
>>> # Partitions vadd=3
> MAKE vtoi_curr
input(<vtoi_curr,X>)
cover
input(<vtoi_curr,K>)
cover
output(<vtoi_curr,Y>)
cover
=
=
offset(<vtoi_curr,K>)=0
offset(<vtoi_curr,X>)=0
ve(scale(<vtoi_curr,Y>)=scale(<vtoi_curr,K>)*scale(<vtoi_curr,X>))
offset(<vtoi_curr,Y>)=0
>>> # Partitions vtoi_curr=4
> MAKE vtoi
input(<vtoi,X>)
cover
input(<vtoi,K>)
cover
output(<vtoi,Y>)
cover
=
=
valid
offset(<vtoi,K>)=0
valid
offset(<vtoi,X>)=0
ve(scale(<vtoi,Y>)=scale(<vtoi,K>)^-1*scale(<vtoi,X>))
offset(<vtoi,Y>)=0
>>> # Partitions vtoi=4
> MAKE igenebind
input(<igenebind,TF>)
cover
input(<igenebind,K>)
cover
input(<igenebind,Vmax>)
cover
output(<igenebind,GE>)
cover
=
=
offset(<igenebind,K>)=0
offset(<igenebind,TF>)=0
ee(1=1)
ee(scale(<igenebind,K>)*scale(<igenebind,TF>)=1)
ee(1=scale(<igenebind,K>)*scale(<igenebind,TF>))
ee(scale(<igenebind,K>)*scale(<igenebind,TF>)=scale(<igenebind,K>)*scale(<igenebind,TF>))
valid
ec(0+0=0)
=
offset(<igenebind,Vmax>)=0
valid
ve(scale(<igenebind,GE>)=scale(<igenebind,K>)^-1*scale(<igenebind,TF>)^-1*scale(<igenebind,Vmax>))
offset(<igenebind,GE>)=0
>>> # Partitions igenebind=6
> MAKE mm
input(<mm,kr>)
cover
input(<mm,XY0>)
cover
input(<mm,Ytot>)
cover
input(<mm,kf>)
cover
input(<mm,Xtot>)
cover
output(<mm,X>)
cover
output(<mm,XY>)
cover
XY
output(<mm,Y>)
cover
=
=
vv(scale(<mm,Xtot>)=scale(<mm,Xtot>))
vv(scale(<mm,XY>)=scale(<mm,Xtot>))
vv(scale(<mm,Xtot>)=scale(<mm,XY>))
vv(scale(<mm,XY>)=scale(<mm,XY>))
vv(scale(<mm,X>)=scale(<mm,Xtot>))
ve(offset(<mm,X>)=offset(<mm,XY>)+offset(<mm,Xtot>))
=
=
offset(<mm,kr>)=0
offset(<mm,XY>)=0
=
=
=
offset(<mm,kf>)=0
offset(<mm,X>)=0
offset(<mm,Y>)=0
ee(scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>)=scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>))
ee(scale(<mm,XY>)*scale(<mm,kr>)=scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>))
ee(scale(<mm,X>)*scale(<mm,Y>)*scale(<mm,kf>)=scale(<mm,XY>)*scale(<mm,kr>))
ee(scale(<mm,XY>)*scale(<mm,kr>)=scale(<mm,XY>)*scale(<mm,kr>))
ve(scale(<mm,XY>)=scale(<mm,XY>)*scale(<mm,kr>))
offset(<mm,XY>)=0
=
priority
offset(<mm,XY>)=0
vv(scale(<mm,XY>)=scale(<mm,XY0>))
vv(offset(<mm,XY>)=offset(<mm,XY0>))
=
=
vv(scale(<mm,Ytot>)=scale(<mm,Ytot>))
vv(scale(<mm,XY>)=scale(<mm,Ytot>))
vv(scale(<mm,Ytot>)=scale(<mm,XY>))
vv(scale(<mm,XY>)=scale(<mm,XY>))
vv(scale(<mm,Y>)=scale(<mm,Ytot>))
ve(offset(<mm,Y>)=offset(<mm,XY>)+offset(<mm,Ytot>))
>>> # Partitions mm=4
> MAKE input.V
input(<input.V,X>)
cover
output(<input.V,O>)
cover
=
vv(scale(<input.V,O>)=scale(<input.V,X>))
vv(offset(<input.V,O>)=offset(<input.V,X>))
>>> # Partitions input.V=2
> MAKE itov
input(<itov,X>)
cover
input(<itov,K>)
cover
output(<itov,Y>)
cover
=
=
offset(<itov,K>)=0
offset(<itov,X>)=0
ve(scale(<itov,Y>)=scale(<itov,K>)*scale(<itov,X>))
offset(<itov,Y>)=0
>>> # Partitions itov=4
> MAKE iadd
input(<iadd,C>)
cover
input(<iadd,A>)
cover
input(<iadd,B>)
cover
output(<iadd,OUT>)
cover
=
=
=
vv(scale(<iadd,A>)=scale(<iadd,A>))
vv(scale(<iadd,B>)=scale(<iadd,A>))
vv(scale(<iadd,A>)=scale(<iadd,B>))
vv(scale(<iadd,B>)=scale(<iadd,B>))
vv(scale(<iadd,A>)=scale(<iadd,A>))
vv(scale(<iadd,C>)=scale(<iadd,A>))
vv(scale(<iadd,A>)=scale(<iadd,C>))
vv(scale(<iadd,C>)=scale(<iadd,C>))
vv(scale(<iadd,OUT>)=scale(<iadd,A>))
ve(offset(<iadd,OUT>)=offset(<iadd,A>)+offset(<iadd,B>)+offset(<iadd,C>))
>>> # Partitions iadd=3
> MAKE output.I
input(<output.I,X>)
cover
output(<output.I,O>)
cover
=
vv(scale(<output.I,O>)=scale(<output.I,X>))
vv(offset(<output.I,O>)=offset(<output.I,X>))
>>> # Partitions output.I=2
> MAKE copy.I
input(<copy.I,X>)
cover
output(<copy.I,Y>)
cover
=
vv(scale(<copy.I,Y>)=scale(<copy.I,X>))
vv(offset(<copy.I,Y>)=offset(<copy.I,X>))
>>> # Partitions copy.I=2
=== mm ===
 = 
 = ====== #0 ======
v(2) = exprs=v(2)+v(2)=v(2)+v(2)
cstrs==
value=0
mems=offset(<mm,Ytot>),offset(<mm,XY0>),offset(<mm,Y>),offset(<mm,kf>),offset(<mm,XY>),offset(<mm,kr>),offset(<mm,X>),offset(<mm,Xtot>)

v(0) = exprs=
cstrs=
value=<none>
mems=scale(<mm,kf>)

v(3) = exprs=v(3)*v(3)*v(0)=v(3)*v(1)
cstrs=
value=<none>
mems=scale(<mm,Ytot>),scale(<mm,Y>),scale(<mm,XY>),scale(<mm,XY0>),scale(<mm,Xtot>),scale(<mm,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<mm,kr>)


kr = string_of_map_port: unimpl
XY0 = string_of_map_port: unimpl
Ytot = string_of_map_port: unimpl
Xtot = string_of_map_port: unimpl
kf = string_of_map_port: unimpl

X = string_of_map_port: unimpl
XY = string_of_map_port: unimpl
Y = string_of_map_port: unimpl



=== vgain ===
 = 
 = ====== #0 ======
v(2) = exprs=v(0)*v(1)
cstrs=
value=<none>
mems=scale(<vgain,P>)

v(0) = exprs=
cstrs=
value=<none>
mems=scale(<vgain,X>)

v(3) = exprs=
cstrs==
value=0
mems=offset(<vgain,P>),offset(<vgain,Z>),offset(<vgain,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<vgain,Z>)


X = string_of_map_port: unimpl
Z = string_of_map_port: unimpl

P = string_of_map_port: unimpl



=== vdadd ===
 = 
 = ====== #2 ======
v(2) = exprs=
cstrs==
value=0
mems=offset(<vdadd,D>),offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>),offset(<vdadd,B>)

v(0) = exprs=v(1)*v(0)
cstrs=
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<vdadd,D>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #0 ======
v(2) = exprs=
cstrs==
value=0
mems=offset(<vdadd,D>),offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>),offset(<vdadd,B>)

v(0) = exprs=v(1)*v(0)
cstrs=
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<vdadd,D>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #3 ======
v(2) = exprs=
cstrs==
value=0
mems=offset(<vdadd,D>),offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>),offset(<vdadd,B>)

v(0) = exprs=v(1)*v(0)
cstrs=
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<vdadd,D>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #1 ======
v(2) = exprs=
cstrs==
value=0
mems=offset(<vdadd,D>),offset(<vdadd,A>),offset(<vdadd,OUT_0>),offset(<vdadd,OUT>),offset(<vdadd,B>)

v(0) = exprs=v(1)*v(0)
cstrs=
value=<none>
mems=scale(<vdadd,OUT_0>),scale(<vdadd,B>),scale(<vdadd,A>),scale(<vdadd,OUT>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<vdadd,D>)


D = string_of_map_port: unimpl
A = string_of_map_port: unimpl
OUT_0 = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== switch ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=scale(<switch,SUB>)

v(0) = exprs=v(1)/1=v(3)^-1*v(2)
cstrs=
value=1
mems=

v(6) = exprs=0+0
cstrs==
value=0
mems=offset(<switch,SUB>),offset(<switch,n>),offset(<switch,Kmod>),offset(<switch,PROD>),offset(<switch,Vmax>)

v(3) = exprs=
cstrs=
value=<none>
mems=scale(<switch,Kmod>)

v(5) = exprs=1/1^(switch.V{n}:/500.)*v(4)
cstrs=
value=<none>
mems=scale(<switch,PROD>)

v(4) = exprs=
cstrs=
value=<none>
mems=scale(<switch,Vmax>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<switch,n>)


SUB = string_of_map_port: unimpl
n = string_of_map_port: unimpl
Kmod = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

PROD = string_of_map_port: unimpl



=== itov ===
 = 
 = ====== #0 ======
v(2) = exprs=v(1)*v(0)
cstrs=
value=<none>
mems=scale(<itov,Y>)

v(0) = exprs=
cstrs=
value=<none>
mems=scale(<itov,X>)

v(3) = exprs=
cstrs==
value=0
mems=offset(<itov,K>),offset(<itov,X>),offset(<itov,Y>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<itov,K>)


X = string_of_map_port: unimpl
K = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== output.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=
value=<none>
mems=scale(<output.I,O>),scale(<output.I,X>)

v(1) = exprs=
cstrs==
value=<none>
mems=offset(<output.I,X>),offset(<output.I,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== input.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=
value=<none>
mems=scale(<input.V,X>),scale(<input.V,O>)

v(1) = exprs=
cstrs==
value=<none>
mems=offset(<input.V,X>),offset(<input.V,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== output.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=
value=<none>
mems=scale(<output.V,X>),scale(<output.V,O>)

v(1) = exprs=
cstrs==
value=<none>
mems=offset(<output.V,O>),offset(<output.V,X>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== ihill_rep2 ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=scale(<ihill_rep2,S>)

v(0) = exprs=
cstrs=
value=<none>
mems=scale(<ihill_rep2,REP2>),scale(<ihill_rep2,Vmax>)

v(3) = exprs=0+0
cstrs==
value=0
mems=offset(<ihill_rep2,Vmax>),offset(<ihill_rep2,S>),offset(<ihill_rep2,REP2>),offset(<ihill_rep2,n>)

v(1) = exprs=v(2)^ihill_rep2.V{n}:=1
cstrs=
value=<none>
mems=scale(<ihill_rep2,n>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

REP2 = string_of_map_port: unimpl



=== copy.V ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=
value=<none>
mems=scale(<copy.V,Y>),scale(<copy.V,X>)

v(1) = exprs=
cstrs==
value=<none>
mems=offset(<copy.V,X>),offset(<copy.V,Y>)


X = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== ihill_rep ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=scale(<ihill_rep,Km>)

v(0) = exprs=
cstrs=
value=1
mems=scale(<ihill_rep,n>)

v(6) = exprs=0+0
cstrs==
value=0
mems=offset(<ihill_rep,n>),offset(<ihill_rep,REP>),offset(<ihill_rep,Km>),offset(<ihill_rep,Vmax>),offset(<ihill_rep,S>)

v(3) = exprs=
cstrs=
value=<none>
mems=scale(<ihill_rep,Vmax>)

v(5) = exprs=v(1)^ihill_rep.V{n}:=v(2)^ihill_rep.V{n}:
cstrs=
value=<none>
mems=

v(4) = exprs=v(2)^ihill_rep.V{n}:/v(1)^ihill_rep.V{n}:*v(3)
cstrs=
value=<none>
mems=scale(<ihill_rep,REP>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<ihill_rep,S>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Km = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

REP = string_of_map_port: unimpl



=== ihill_stim ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=scale(<ihill_stim,Km>)

v(0) = exprs=v(1)*v(3)/v(2)^ihill_stim.V{n}:/1
cstrs=
value=<none>
mems=scale(<ihill_stim,STIM>)

v(3) = exprs=
cstrs=
value=<none>
mems=scale(<ihill_stim,S>)

v(5) = exprs=0+0
cstrs==
value=0
mems=offset(<ihill_stim,STIM>),offset(<ihill_stim,n>),offset(<ihill_stim,Vmax>),offset(<ihill_stim,S>),offset(<ihill_stim,Km>)

v(4) = exprs=v(3)/v(2)^ihill_stim.V{n}:=1
cstrs=
value=<none>
mems=scale(<ihill_stim,n>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<ihill_stim,Vmax>)


n = string_of_map_port: unimpl
S = string_of_map_port: unimpl
Km = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

STIM = string_of_map_port: unimpl



=== vtoi ===
 = 
 = ====== #0 ======
v(2) = exprs=v(1)^-1*v(0)
cstrs=
value=<none>
mems=scale(<vtoi,Y>)

v(0) = exprs=
cstrs=
value=<none>
mems=scale(<vtoi,X>)

v(3) = exprs=
cstrs==
value=0
mems=offset(<vtoi,X>),offset(<vtoi,Y>),offset(<vtoi,K>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<vtoi,K>)


X = string_of_map_port: unimpl
K = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== vadd ===
 = 
 = ====== #2 ======
v(0) = exprs=
cstrs=
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(1) = exprs=
cstrs==
value=0
mems=offset(<vadd,B>),offset(<vadd,C>),offset(<vadd,OUT>),offset(<vadd,A>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #0 ======
v(2) = exprs=v(1)+0+0
cstrs=
value=0
mems=offset(<vadd,OUT>)

v(0) = exprs=
cstrs=
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(1) = exprs=
cstrs==
value=<none>
mems=offset(<vadd,B>),offset(<vadd,C>),offset(<vadd,A>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #3 ======
v(0) = exprs=
cstrs=
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(1) = exprs=v(1)+0+0
cstrs==
value=0
mems=offset(<vadd,B>),offset(<vadd,C>),offset(<vadd,OUT>),offset(<vadd,A>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



 = ====== #1 ======
v(0) = exprs=
cstrs=
value=<none>
mems=scale(<vadd,C>),scale(<vadd,B>),scale(<vadd,OUT>),scale(<vadd,A>)

v(1) = exprs=v(1)+0+0
cstrs==
value=0
mems=offset(<vadd,B>),offset(<vadd,C>),offset(<vadd,OUT>),offset(<vadd,A>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== copy.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=
value=<none>
mems=scale(<copy.I,Y>),scale(<copy.I,X>)

v(1) = exprs=
cstrs==
value=<none>
mems=offset(<copy.I,X>),offset(<copy.I,Y>)


X = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== iadd ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=scale(<iadd,OUT>),scale(<iadd,A>),scale(<iadd,B>),scale(<iadd,C>)

v(0) = exprs=
cstrs==
value=<none>
mems=offset(<iadd,A>),offset(<iadd,C>),offset(<iadd,B>)

v(1) = exprs=v(0)+v(0)+v(0)
cstrs=
value=<none>
mems=offset(<iadd,OUT>)


C = string_of_map_port: unimpl
A = string_of_map_port: unimpl
B = string_of_map_port: unimpl

OUT = string_of_map_port: unimpl



=== input.I ===
 = 
 = ====== #0 ======
v(0) = exprs=
cstrs=
value=<none>
mems=scale(<input.I,O>),scale(<input.I,X>)

v(1) = exprs=
cstrs==
value=<none>
mems=offset(<input.I,X>),offset(<input.I,O>)


X = string_of_map_port: unimpl

O = string_of_map_port: unimpl



=== vtoi_curr ===
 = 
 = ====== #0 ======
v(2) = exprs=v(1)*v(0)
cstrs=
value=<none>
mems=scale(<vtoi_curr,Y>)

v(0) = exprs=
cstrs=
value=<none>
mems=scale(<vtoi_curr,X>)

v(3) = exprs=
cstrs==
value=0
mems=offset(<vtoi_curr,K>),offset(<vtoi_curr,Y>),offset(<vtoi_curr,X>)

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<vtoi_curr,K>)


X = string_of_map_port: unimpl
K = string_of_map_port: unimpl

Y = string_of_map_port: unimpl



=== igenebind ===
 = 
 = ====== #0 ======
v(2) = exprs=
cstrs=
value=<none>
mems=scale(<igenebind,K>)

v(0) = exprs=v(2)^-1*v(3)^-1*v(1)
cstrs=
value=<none>
mems=scale(<igenebind,GE>)

v(3) = exprs=
cstrs=
value=<none>
mems=scale(<igenebind,TF>)

v(5) = exprs=0+0
cstrs==
value=0
mems=offset(<igenebind,GE>),offset(<igenebind,K>),offset(<igenebind,Vmax>),offset(<igenebind,TF>)

v(4) = exprs=1=v(2)*v(3)
cstrs=
value=<none>
mems=

v(1) = exprs=
cstrs=
value=<none>
mems=scale(<igenebind,Vmax>)


TF = string_of_map_port: unimpl
K = string_of_map_port: unimpl
Vmax = string_of_map_port: unimpl

GE = string_of_map_port: unimpl



[multi] # Found 0, Required: 1
[multi] solving target: ES
[multi] search tree is not exhausted. adding existing:ES
[multi] finding new partial solution
[multi] made a partial tree with 4 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
vdadd.OUT -> true
mm.XY -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  2 <<<
[eqn] new: [0] <vdadd> output OUT.V
<analog-st> ((vdadd.V{A}:+(vdadd.BSW*vdadd.V{B}:))-(vdadd.DSW*vdadd.I{D}:*vdadd.V{OUT}:)) ic=OUT_0.V / std=none 0
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,12000.] {v}->[v]=@ {v}->*[v]=@


checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
[eqn] new: [0] <mm> output XY.V
<analog-st> ((mm.I{kf}:*mm.V{X}:*mm.V{Y}:)-(mm.I{kr}:*mm.V{XY}:)) ic=XY0.V / std=gauss ((0.001*mm.V{XY}:)+0.1)
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,3200.] {v}->[v]=@ {v}->*[v]=@


[eqn] [FOUND-SOLS] ===> Found <21> solutions
[slvrsearch] > weight--: <mvar-goal>ES
[eqn] -> [valid?] testing node 42
->vdadd[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (3) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 3
[[Z3]] ---> Executing SMT Solver prob=0

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
vgain.P -> true
vadd.OUT -> true
mm.X -> true
mm.Y -> true
itov.Y -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  5 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <vadd> output OUT.V
<analog>:(((vadd.V{A}:+(vadd.BSW*vadd.V{B}:))-(vadd.CSW*vadd.V{C}:))*0.25) / std=gauss ((0.001*vadd.V{OUT}:)+0.1)
<analog> [v]={[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } {v}->[v]=@


[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn] new: [0] <mm> output Y.V
<analog>:(mm.V{Ytot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <mm> output X.V
<analog>:(mm.V{Xtot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <itov> output Y.V
<analog>:(itov.V{K}:*itov.I{X}:) / std=gauss 0.1
<analog> [v]=[0.,3300.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] [FOUND-SOLS] ===> Found <52> solutions
[slvrsearch] > weight--: (3.154*E*S)
[eqn] -> [valid?] testing node 146
->vdadd[1]
->itov[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (7) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 4
[[Z3]] ---> Executing SMT Solver prob=1

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[220] [EXPR]itov[1].K<V>=(3.154*E)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [220] [EXPR]itov[1].K<V>=(3.154*E)
vgain.P -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] [FOUND-SOLS] ===> Found <5> solutions
[slvrsearch] > weight--: (3.154*E)
[eqn] -> [valid?] testing node 157
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=2

->vdadd[1]
->itov[1]
->vgain[3]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=3

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 155
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=4

->vdadd[1]
->itov[1]
->vgain[3]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=5

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 153
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=6

->vdadd[1]
->itov[1]
->vgain[3]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=7

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 152
->vgain[2]
->vdadd[1]
->itov[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 6
[[Z3]] ---> Executing SMT Solver prob=8

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 155 ==
[multi] == Adding Local Solution : 157 ==
[multi] == Adding Local Solution : 153 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] # partial ids = 1
[multi]    remove-goal [220] [EXPR]itov[2].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(3.154*E)
   [comp] vgain[0] cfg-in X=E
   [comp] vgain[0] cfg-in Z=3.154
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=ES
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=2.525
   [comp] vdadd[1] cfg-in A=(3.154*E*S)
   [comp] itov[2] cfg-in Y=(3.154*E*S)
   [comp] itov[2] cfg-in X=S
   [comp] itov[2] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (3.154*E)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (3.154*E)
   [sln] conn vgain[0].P->itov[2].K
   [sln] generate vdadd[1].OUT = ES
   [sln] add-comp vdadd[1]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] add-comp itov[2]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] conn itov[2].Y->vdadd[1].A
   [sln] route vgain[0].X = E
   [sln] route vgain[0].Z = 3.154
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].D = 2.525
   [sln] route itov[2].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp itov2
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[2].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = E
[multi]    - connecting generates to routes.
[multi] > vgain[0].Z = 3.154
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].D = 2.525
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = ES
[multi]    - making an output block.
[multi] > vgain[0].P = (3.154*E)
[multi] > vgain[0].P = (3.154*E)
[multi] > itov[2].Y = (3.154*E*S)
[multi] > itov[2].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 42 =======
[multi]    remove-goal [220] [EXPR]itov[2].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(3.154*E)
   [comp] vgain[0] cfg-in X=E
   [comp] vgain[0] cfg-in Z=3.154
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=ES
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=2.525
   [comp] vdadd[1] cfg-in A=(3.154*E*S)
   [comp] itov[2] cfg-in Y=(3.154*E*S)
   [comp] itov[2] cfg-in X=S
   [comp] itov[2] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (3.154*E)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (3.154*E)
   [sln] conn vgain[0].P->itov[2].K
   [sln] generate vdadd[1].OUT = ES
   [sln] add-comp vdadd[1]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] add-comp itov[2]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] conn itov[2].Y->vdadd[1].A
   [sln] route vgain[0].X = E
   [sln] route vgain[0].Z = 3.154
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].D = 2.525
   [sln] route itov[2].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp itov2
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[2].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0
     [comp] input.V[0] cfg-out O=0
     [comp] input.I[1] cfg-in X=2.525
     [comp] input.I[1] cfg-out O=2.525
     [comp] output.V[0] cfg-in X=ES
     [comp] output.V[0] cfg-out O=ES
     [sln] rm-route vgain[0].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vdadd[1].OUT_0 = 0
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0
     [sln] rm-route vdadd[1].D = 2.525
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 2.525
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0
     [sln] route input.I[1].X = 2.525
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp output.V0
     add-goal [229] [CONN] input.I[0].O => vgain[0].Z (3.154)
     add-goal [230] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
     add-goal [231] [CONN] input.I[1].O => vdadd[1].D (2.525)
     add-goal [232] [CONN] vdadd[1].OUT => output.V[0].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[229] [CONN] input.I[0].O => vgain[0].Z (3.154)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[232] [CONN] vdadd[1].OUT => output.V[0].X (ES)
[231] [CONN] input.I[1].O => vdadd[1].D (2.525)
[230] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [230] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (19) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 7
[[Z3]] ---> Executing SMT Solver prob=9

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[229] [CONN] input.I[0].O => vgain[0].Z (3.154)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [229] [CONN] input.I[0].O => vgain[0].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (22) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 8
[[Z3]] ---> Executing SMT Solver prob=10

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[234] [CONN] input.I[0].O => iadd[0].B (3.154)

============
>> Current Goal: [234] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=11

->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (22) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 6
[[Z3]] ---> Executing SMT Solver prob=12

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (22) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 8
[[Z3]] ---> Executing SMT Solver prob=13

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = E
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[0].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (3.154*E)
[multi] > vgain[0].P = (3.154*E)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[2].Y = (3.154*E*S)
[multi] > itov[2].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[2] cfg-in X=0
     [comp] input.I[2] cfg-out O=0
     [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] route input.I[2].X = 0
     [sln] route input.I[3].X = 0
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     add-goal [235] [CONN] input.I[2].O => iadd[0].C (0)
     add-goal [236] [CONN] input.I[3].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[233] [CONN] input.I[0].O => iadd[0].A (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [233] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=14

->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (22) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 6
[[Z3]] ---> Executing SMT Solver prob=15

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[1]
->vdadd[1]
->input.I[2]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (26) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=16

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = E
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[0].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (3.154*E)
[multi] > vgain[0].P = (3.154*E)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[2].Y = (3.154*E*S)
[multi] > itov[2].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     add-goal [237] [CONN] input.I[4].O => iadd[0].C (0)
     add-goal [238] [CONN] input.I[5].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[238] [CONN] input.I[5].O => iadd[0].B (0)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[237] [CONN] input.I[4].O => iadd[0].C (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [237] [CONN] input.I[4].O => iadd[0].C (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=17

->input.I[4]
->input.I[5]
->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (26) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 6
[[Z3]] ---> Executing SMT Solver prob=18

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[1]
->vdadd[1]
->input.I[2]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (26) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=19

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] # partial ids = 1
[multi]    remove-goal [220] [EXPR]itov[2].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(3.154*E)
   [comp] vgain[0] cfg-in Z=E
   [comp] vgain[0] cfg-in X=3.154
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=ES
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=2.525
   [comp] vdadd[1] cfg-in A=(3.154*E*S)
   [comp] itov[2] cfg-in Y=(3.154*E*S)
   [comp] itov[2] cfg-in X=S
   [comp] itov[2] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (3.154*E)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (3.154*E)
   [sln] conn vgain[0].P->itov[2].K
   [sln] generate vdadd[1].OUT = ES
   [sln] add-comp vdadd[1]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] add-comp itov[2]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] conn itov[2].Y->vdadd[1].A
   [sln] route vgain[0].Z = E
   [sln] route vgain[0].X = 3.154
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].D = 2.525
   [sln] route itov[2].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp itov2
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[2].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[0].Z = E
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = 3.154
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].D = 2.525
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = ES
[multi]    - making an output block.
[multi] > vgain[0].P = (3.154*E)
[multi] > vgain[0].P = (3.154*E)
[multi] > itov[2].Y = (3.154*E*S)
[multi] > itov[2].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 42 =======
[multi]    remove-goal [220] [EXPR]itov[2].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(3.154*E)
   [comp] vgain[0] cfg-in Z=E
   [comp] vgain[0] cfg-in X=3.154
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=ES
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=2.525
   [comp] vdadd[1] cfg-in A=(3.154*E*S)
   [comp] itov[2] cfg-in Y=(3.154*E*S)
   [comp] itov[2] cfg-in X=S
   [comp] itov[2] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (3.154*E)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (3.154*E)
   [sln] conn vgain[0].P->itov[2].K
   [sln] generate vdadd[1].OUT = ES
   [sln] add-comp vdadd[1]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] add-comp itov[2]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] conn itov[2].Y->vdadd[1].A
   [sln] route vgain[0].Z = E
   [sln] route vgain[0].X = 3.154
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].D = 2.525
   [sln] route itov[2].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp itov2
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[2].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.V[0] cfg-in X=3.154
     [comp] input.V[0] cfg-out O=3.154
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.I[0] cfg-in X=2.525
     [comp] input.I[0] cfg-out O=2.525
     [comp] output.V[0] cfg-in X=ES
     [comp] output.V[0] cfg-out O=ES
     [sln] rm-route vgain[0].X = 3.154
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 3.154
     [sln] rm-route vdadd[1].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].D = 2.525
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 2.525
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = ES
     [sln] route input.V[0].X = 3.154
     [sln] route input.V[1].X = 0
     [sln] route input.I[0].X = 2.525
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.I0
     [comp] make-comp output.V0
     add-goal [239] [CONN] input.V[0].O => vgain[0].X (3.154)
     add-goal [240] [CONN] input.V[1].O => vdadd[1].OUT_0 (0)
     add-goal [241] [CONN] input.I[0].O => vdadd[1].D (2.525)
     add-goal [242] [CONN] vdadd[1].OUT => output.V[0].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[241] [CONN] input.I[0].O => vdadd[1].D (2.525)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[242] [CONN] vdadd[1].OUT => output.V[0].X (ES)
[240] [CONN] input.V[1].O => vdadd[1].OUT_0 (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[239] [CONN] input.V[0].O => vgain[0].X (3.154)

============
>> Current Goal: [239] [CONN] input.V[0].O => vgain[0].X (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=20

->vdadd[1]
->output.V[0]
->vgain[0]
->input.V[1]
->itov[2]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (19) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=21

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] [TERMINATE] found 0 / 1
[eqn] [TERMINATE] could not find another node
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] # partial ids = 1
[multi]    remove-goal [220] [EXPR]itov[2].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(3.154*E)
   [comp] vgain[0] cfg-in Z=3.154
   [comp] vgain[0] cfg-in X=E
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=ES
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=2.525
   [comp] vdadd[1] cfg-in A=(3.154*E*S)
   [comp] itov[2] cfg-in Y=(3.154*E*S)
   [comp] itov[2] cfg-in X=S
   [comp] itov[2] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (3.154*E)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (3.154*E)
   [sln] conn vgain[0].P->itov[2].K
   [sln] generate vdadd[1].OUT = ES
   [sln] add-comp vdadd[1]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] add-comp itov[2]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] conn itov[2].Y->vdadd[1].A
   [sln] route vgain[0].Z = 3.154
   [sln] route vgain[0].X = E
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].D = 2.525
   [sln] route itov[2].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp itov2
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[2].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = E
[multi]    - connecting generates to routes.
[multi] > vgain[0].Z = 3.154
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].D = 2.525
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = ES
[multi]    - making an output block.
[multi] > vgain[0].P = (3.154*E)
[multi] > vgain[0].P = (3.154*E)
[multi] > itov[2].Y = (3.154*E*S)
[multi] > itov[2].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 42 =======
[multi]    remove-goal [220] [EXPR]itov[2].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(3.154*E)
   [comp] vgain[0] cfg-in Z=3.154
   [comp] vgain[0] cfg-in X=E
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=ES
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=2.525
   [comp] vdadd[1] cfg-in A=(3.154*E*S)
   [comp] itov[2] cfg-in Y=(3.154*E*S)
   [comp] itov[2] cfg-in X=S
   [comp] itov[2] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (3.154*E)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (3.154*E)
   [sln] conn vgain[0].P->itov[2].K
   [sln] generate vdadd[1].OUT = ES
   [sln] add-comp vdadd[1]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] add-comp itov[2]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] conn itov[2].Y->vdadd[1].A
   [sln] route vgain[0].Z = 3.154
   [sln] route vgain[0].X = E
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].D = 2.525
   [sln] route itov[2].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp itov2
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[2].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0
     [comp] input.V[0] cfg-out O=0
     [comp] input.I[1] cfg-in X=2.525
     [comp] input.I[1] cfg-out O=2.525
     [comp] output.V[0] cfg-in X=ES
     [comp] output.V[0] cfg-out O=ES
     [sln] rm-route vgain[0].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vdadd[1].OUT_0 = 0
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0
     [sln] rm-route vdadd[1].D = 2.525
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 2.525
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0
     [sln] route input.I[1].X = 2.525
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.I1
     [comp] make-comp output.V0
     add-goal [243] [CONN] input.I[0].O => vgain[0].Z (3.154)
     add-goal [244] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
     add-goal [245] [CONN] input.I[1].O => vdadd[1].D (2.525)
     add-goal [246] [CONN] vdadd[1].OUT => output.V[0].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[246] [CONN] vdadd[1].OUT => output.V[0].X (ES)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[243] [CONN] input.I[0].O => vgain[0].Z (3.154)
[245] [CONN] input.I[1].O => vdadd[1].D (2.525)
[244] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [244] [CONN] input.V[0].O => vdadd[1].OUT_0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (19) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 7
[[Z3]] ---> Executing SMT Solver prob=22

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[243] [CONN] input.I[0].O => vgain[0].Z (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [243] [CONN] input.I[0].O => vgain[0].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (22) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 8
[[Z3]] ---> Executing SMT Solver prob=23

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[248] [CONN] input.I[0].O => iadd[0].B (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [248] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=24

->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (22) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 6
[[Z3]] ---> Executing SMT Solver prob=25

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (22) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 8
[[Z3]] ---> Executing SMT Solver prob=26

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = E
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[0].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (3.154*E)
[multi] > vgain[0].P = (3.154*E)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[2].Y = (3.154*E*S)
[multi] > itov[2].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[2] cfg-in X=0
     [comp] input.I[2] cfg-out O=0
     [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] route input.I[2].X = 0
     [sln] route input.I[3].X = 0
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     add-goal [249] [CONN] input.I[2].O => iadd[0].C (0)
     add-goal [250] [CONN] input.I[3].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[247] [CONN] input.I[0].O => iadd[0].A (3.154)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [247] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=27

->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (22) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 6
[[Z3]] ---> Executing SMT Solver prob=28

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[1]
->vdadd[1]
->input.I[2]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (26) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=29

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = E
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[0].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[0].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (3.154*E)
[multi] > vgain[0].P = (3.154*E)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[2].Y = (3.154*E*S)
[multi] > itov[2].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     add-goal [251] [CONN] input.I[4].O => iadd[0].C (0)
     add-goal [252] [CONN] input.I[5].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[251] [CONN] input.I[4].O => iadd[0].C (0)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[252] [CONN] input.I[5].O => iadd[0].B (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [252] [CONN] input.I[5].O => iadd[0].B (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=30

->input.I[4]
->input.I[5]
->input.I[1]
->vdadd[1]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (26) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 6
[[Z3]] ---> Executing SMT Solver prob=31

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[1]
->vdadd[1]
->input.I[2]
->output.V[0]
->vgain[0]
->itov[2]
->iadd[0]
->input.I[0]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (26) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=32

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi] # Found 0, Required: 1
[multi] solving target: E
[multi] search tree is not exhausted. adding existing:E
[multi] finding new partial solution
[multi] made a partial tree with 4 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
vdadd.OUT -> true
mm.XY -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  2 <<<
[eqn] new: [0] <vdadd> output OUT.V
<analog-st> ((vdadd.V{A}:+(vdadd.BSW*vdadd.V{B}:))-(vdadd.DSW*vdadd.I{D}:*vdadd.V{OUT}:)) ic=OUT_0.V / std=none 0
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,12000.] {v}->[v]=@ {v}->*[v]=@


checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
[eqn] new: [0] <mm> output XY.V
<analog-st> ((mm.I{kf}:*mm.V{X}:*mm.V{Y}:)-(mm.I{kr}:*mm.V{XY}:)) ic=XY0.V / std=gauss ((0.001*mm.V{XY}:)+0.1)
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,3200.] {v}->[v]=@ {v}->*[v]=@


[eqn] [FOUND-SOLS] ===> Found <21> solutions
[slvrsearch] > weight--: <mvar-goal>E
[eqn] -> [valid?] testing node 42
->vdadd[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (3) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 3
[[Z3]] ---> Executing SMT Solver prob=33

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[338] [EXPR]vdadd[1].A<V>=(2.315*ES)
[339] [EXPR]vdadd[1].D<I>=(3.154*S)

============
>> Current Goal: [339] [EXPR]vdadd[1].D<I>=(3.154*S)
switch.PROD -> true
ihill_stim.STIM -> true
ihill_rep.REP -> true
ihill_rep2.REP2 -> true
vtoi.Y -> true
igenebind.GE -> true
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  7 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <ihill_rep2> output REP2.I
<analog>:(ihill_rep2.I{Vmax}:*(1/((ihill_rep2.I{S}:^ihill_rep2.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <igenebind> output GE.I
<analog>:(igenebind.I{Vmax}:*(1/(1+(igenebind.I{K}:*igenebind.I{TF}:)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn] [FOUND-SOLS] ===> Found <47> solutions
[slvrsearch] > weight--: (3.154*S)
[eqn] -> [valid?] testing node 110
->vdadd[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (7) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 4
[[Z3]] ---> Executing SMT Solver prob=34

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[338] [EXPR]vdadd[1].A<V>=(2.315*ES)

============
>> Current Goal: [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
vgain.P -> true
vadd.OUT -> true
mm.X -> true
mm.Y -> true
itov.Y -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  5 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <vadd> output OUT.V
<analog>:(((vadd.V{A}:+(vadd.BSW*vadd.V{B}:))-(vadd.CSW*vadd.V{C}:))*0.25) / std=gauss ((0.001*vadd.V{OUT}:)+0.1)
<analog> [v]={[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } {v}->[v]=@


[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn] new: [0] <mm> output Y.V
<analog>:(mm.V{Ytot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <mm> output X.V
<analog>:(mm.V{Xtot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <itov> output Y.V
<analog>:(itov.V{K}:*itov.I{X}:) / std=gauss 0.1
<analog> [v]=[0.,3300.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] [FOUND-SOLS] ===> Found <38> solutions
[slvrsearch] > weight--: (2.315*ES)
[eqn] -> [valid?] testing node 213
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=35

->vdadd[1]
->itov[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=36

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 211
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=37

->vdadd[1]
->itov[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=38

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 209
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=39

->vdadd[1]
->itov[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=40

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 147
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=41

->vdadd[1]
->vgain[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=42

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 145
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=43

->vdadd[1]
->vgain[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=44

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 143
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=45

->vdadd[1]
->vgain[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=46

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 208
->itov[0]
->vdadd[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 6
[[Z3]] ---> Executing SMT Solver prob=47

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 143 ==
[multi] == Adding Local Solution : 145 ==
[multi] == Adding Local Solution : 213 ==
[multi] == Adding Local Solution : 209 ==
[multi] == Adding Local Solution : 211 ==
[multi] == Adding Local Solution : 147 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 42
[multi] # partial ids = 2
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [220] [EXPR]itov[5].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(2.315*ES)
   [comp] vgain[0] cfg-in Z=2.315
   [comp] vgain[0] cfg-in X=ES
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(3.154*E)
   [comp] vgain[3] cfg-in Z=3.154
   [comp] vgain[3] cfg-in X=E
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=ES
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=2.525
   [comp] vdadd[4] cfg-in A=(3.154*E*S)
   [comp] itov[5] cfg-in Y=(3.154*E*S)
   [comp] itov[5] cfg-in X=S
   [comp] itov[5] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (3.154*E)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (3.154*E)
   [sln] conn vgain[3].P->itov[5].K
   [sln] generate vdadd[4].OUT = ES
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] conn itov[5].Y->vdadd[4].A
   [sln] route vgain[0].Z = 2.315
   [sln] route vgain[0].X = ES
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 3.154
   [sln] route vgain[3].X = E
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].D = 2.525
   [sln] route itov[5].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[5].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[3].X = E
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = ES
[multi]    - connecting generates to routes.
[multi] > vgain[3].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vdadd[4].D = 2.525
[multi]    - making an input block.
[multi] > vgain[0].Z = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[4].OUT = ES
[multi]    - making an output block.
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 84 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [220] [EXPR]itov[5].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(2.315*ES)
   [comp] vgain[0] cfg-in Z=2.315
   [comp] vgain[0] cfg-in X=ES
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(3.154*E)
   [comp] vgain[3] cfg-in Z=3.154
   [comp] vgain[3] cfg-in X=E
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=ES
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=2.525
   [comp] vdadd[4] cfg-in A=(3.154*E*S)
   [comp] itov[5] cfg-in Y=(3.154*E*S)
   [comp] itov[5] cfg-in X=S
   [comp] itov[5] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (3.154*E)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (3.154*E)
   [sln] conn vgain[3].P->itov[5].K
   [sln] generate vdadd[4].OUT = ES
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] conn itov[5].Y->vdadd[4].A
   [sln] route vgain[0].Z = 2.315
   [sln] route vgain[0].X = ES
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 3.154
   [sln] route vgain[3].X = E
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].D = 2.525
   [sln] route itov[5].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[5].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0.00124
     [comp] input.V[2] cfg-out O=0.00124
     [comp] input.I[1] cfg-in X=2.525
     [comp] input.I[1] cfg-out O=2.525
     [comp] input.I[2] cfg-in X=2.315
     [comp] input.I[2] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=E
     [comp] output.V[0] cfg-out O=E
     [comp] output.V[1] cfg-in X=ES
     [comp] output.V[1] cfg-out O=ES
     [sln] rm-route vgain[3].X = E
     [sln] rm-route vgain[0].X = ES
     [sln] rm-route vgain[3].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.00124
     [sln] rm-route vdadd[4].D = 2.525
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 2.525
     [sln] rm-route vgain[0].Z = 2.315
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = E
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0.00124
     [sln] route input.I[1].X = 2.525
     [sln] route input.I[2].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.I1
     [comp] make-comp input.I2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     add-goal [541] [CONN] vdadd[1].OUT => vgain[3].X (E)
     add-goal [542] [CONN] vdadd[4].OUT => vgain[0].X (ES)
     add-goal [543] [CONN] input.I[0].O => vgain[3].Z (3.154)
     add-goal [544] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
     add-goal [545] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
     add-goal [546] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.00124)
     add-goal [547] [CONN] input.I[1].O => vdadd[4].D (2.525)
     add-goal [548] [CONN] input.I[2].O => vgain[0].Z (2.315)
     add-goal [549] [CONN] vdadd[1].OUT => output.V[0].X (E)
     add-goal [550] [CONN] vdadd[4].OUT => output.V[1].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[548] [CONN] input.I[2].O => vgain[0].Z (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[549] [CONN] vdadd[1].OUT => output.V[0].X (E)
[547] [CONN] input.I[1].O => vdadd[4].D (2.525)
[543] [CONN] input.I[0].O => vgain[3].Z (3.154)
[550] [CONN] vdadd[4].OUT => output.V[1].X (ES)
[544] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
[541] [CONN] vdadd[1].OUT => vgain[3].X (E)
[546] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.00124)
[545] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[542] [CONN] vdadd[4].OUT => vgain[0].X (ES)

============
>> Current Goal: [542] [CONN] vdadd[4].OUT => vgain[0].X (ES)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (38) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=48

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[548] [CONN] input.I[2].O => vgain[0].Z (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[543] [CONN] input.I[0].O => vgain[3].Z (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [543] [CONN] input.I[0].O => vgain[3].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=49

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[552] [CONN] input.I[0].O => iadd[0].B (3.154)
[548] [CONN] input.I[2].O => vgain[0].Z (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [548] [CONN] input.I[2].O => vgain[0].Z (2.315)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=50

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[548] [CONN] input.I[2].O => vgain[0].Z (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [548] [CONN] input.I[2].O => vgain[0].Z (2.315)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 8
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=51

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[554] [CONN] input.I[2].O => iadd[1].B (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [554] [CONN] input.I[2].O => iadd[1].B (2.315)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 9
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=52

->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=53

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=54

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[1].C = 0
[multi]    - making an input block.
[multi] > iadd[1].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[0].P = (2.315*ES)
[multi] > iadd[1].OUT = 2.315
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [sln] rm-route iadd[1].C = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] rm-route iadd[1].A = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] route input.I[3].X = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     add-goal [555] [CONN] input.I[3].O => iadd[1].C (0)
     add-goal [556] [CONN] input.I[4].O => iadd[1].A (0)
     add-goal [557] [CONN] input.I[5].O => iadd[0].C (0)
     add-goal [558] [CONN] input.I[6].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[548] [CONN] input.I[2].O => vgain[0].Z (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[551] [CONN] input.I[0].O => iadd[0].A (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [551] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 11
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=55

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[548] [CONN] input.I[2].O => vgain[0].Z (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [548] [CONN] input.I[2].O => vgain[0].Z (2.315)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 13
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=56

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[560] [CONN] input.I[2].O => iadd[2].B (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [560] [CONN] input.I[2].O => iadd[2].B (2.315)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 14
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=57

->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=58

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=59

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[2].C = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[0].P = (2.315*ES)
[multi] > iadd[2].OUT = 2.315
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [comp] input.I[9] cfg-in X=0
     [comp] input.I[9] cfg-out O=0
     [comp] input.I[10] cfg-in X=0
     [comp] input.I[10] cfg-out O=0
     [sln] rm-route iadd[2].C = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[9]
     [sln] generate input.I[9].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[10]
     [sln] generate input.I[10].O = 0
     [sln] route input.I[7].X = 0
     [sln] route input.I[8].X = 0
     [sln] route input.I[9].X = 0
     [sln] route input.I[10].X = 0
     [comp] make-comp input.I7
     [comp] make-comp input.I8
     [comp] make-comp input.I9
     [comp] make-comp input.I10
     add-goal [561] [CONN] input.I[7].O => iadd[2].C (0)
     add-goal [562] [CONN] input.I[8].O => iadd[2].A (0)
     add-goal [563] [CONN] input.I[9].O => iadd[0].C (0)
     add-goal [564] [CONN] input.I[10].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[561] [CONN] input.I[7].O => iadd[2].C (0)
[562] [CONN] input.I[8].O => iadd[2].A (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[563] [CONN] input.I[9].O => iadd[0].C (0)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[564] [CONN] input.I[10].O => iadd[0].B (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [564] [CONN] input.I[10].O => iadd[0].B (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 16
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=60

->input.I[8]
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[7]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.I[10]
->input.V[1]
->input.I[9]
->output.V[1]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (52) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=61

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=62

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 42
[multi] # partial ids = 2
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [220] [EXPR]itov[5].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(2.315*ES)
   [comp] vgain[0] cfg-in X=ES
   [comp] vgain[0] cfg-in Z=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(3.154*E)
   [comp] vgain[3] cfg-in Z=3.154
   [comp] vgain[3] cfg-in X=E
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=ES
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=2.525
   [comp] vdadd[4] cfg-in A=(3.154*E*S)
   [comp] itov[5] cfg-in Y=(3.154*E*S)
   [comp] itov[5] cfg-in X=S
   [comp] itov[5] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (3.154*E)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (3.154*E)
   [sln] conn vgain[3].P->itov[5].K
   [sln] generate vdadd[4].OUT = ES
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] conn itov[5].Y->vdadd[4].A
   [sln] route vgain[0].X = ES
   [sln] route vgain[0].Z = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 3.154
   [sln] route vgain[3].X = E
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].D = 2.525
   [sln] route itov[5].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[5].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[3].X = E
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = ES
[multi]    - connecting generates to routes.
[multi] > vgain[3].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vdadd[4].D = 2.525
[multi]    - making an input block.
[multi] > vgain[0].Z = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[4].OUT = ES
[multi]    - making an output block.
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 84 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [220] [EXPR]itov[5].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(2.315*ES)
   [comp] vgain[0] cfg-in X=ES
   [comp] vgain[0] cfg-in Z=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(3.154*E)
   [comp] vgain[3] cfg-in Z=3.154
   [comp] vgain[3] cfg-in X=E
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=ES
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=2.525
   [comp] vdadd[4] cfg-in A=(3.154*E*S)
   [comp] itov[5] cfg-in Y=(3.154*E*S)
   [comp] itov[5] cfg-in X=S
   [comp] itov[5] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (3.154*E)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (3.154*E)
   [sln] conn vgain[3].P->itov[5].K
   [sln] generate vdadd[4].OUT = ES
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] conn itov[5].Y->vdadd[4].A
   [sln] route vgain[0].X = ES
   [sln] route vgain[0].Z = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 3.154
   [sln] route vgain[3].X = E
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].D = 2.525
   [sln] route itov[5].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[5].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0.00124
     [comp] input.V[2] cfg-out O=0.00124
     [comp] input.I[1] cfg-in X=2.525
     [comp] input.I[1] cfg-out O=2.525
     [comp] input.I[2] cfg-in X=2.315
     [comp] input.I[2] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=E
     [comp] output.V[0] cfg-out O=E
     [comp] output.V[1] cfg-in X=ES
     [comp] output.V[1] cfg-out O=ES
     [sln] rm-route vgain[3].X = E
     [sln] rm-route vgain[0].X = ES
     [sln] rm-route vgain[3].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.00124
     [sln] rm-route vdadd[4].D = 2.525
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 2.525
     [sln] rm-route vgain[0].Z = 2.315
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = E
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0.00124
     [sln] route input.I[1].X = 2.525
     [sln] route input.I[2].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.I1
     [comp] make-comp input.I2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     add-goal [565] [CONN] vdadd[1].OUT => vgain[3].X (E)
     add-goal [566] [CONN] vdadd[4].OUT => vgain[0].X (ES)
     add-goal [567] [CONN] input.I[0].O => vgain[3].Z (3.154)
     add-goal [568] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
     add-goal [569] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
     add-goal [570] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.00124)
     add-goal [571] [CONN] input.I[1].O => vdadd[4].D (2.525)
     add-goal [572] [CONN] input.I[2].O => vgain[0].Z (2.315)
     add-goal [573] [CONN] vdadd[1].OUT => output.V[0].X (E)
     add-goal [574] [CONN] vdadd[4].OUT => output.V[1].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[569] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[570] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.00124)
[574] [CONN] vdadd[4].OUT => output.V[1].X (ES)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[571] [CONN] input.I[1].O => vdadd[4].D (2.525)
[573] [CONN] vdadd[1].OUT => output.V[0].X (E)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[566] [CONN] vdadd[4].OUT => vgain[0].X (ES)
[567] [CONN] input.I[0].O => vgain[3].Z (3.154)
[565] [CONN] vdadd[1].OUT => vgain[3].X (E)
[568] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
[572] [CONN] input.I[2].O => vgain[0].Z (2.315)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [572] [CONN] input.I[2].O => vgain[0].Z (2.315)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (38) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=63

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[567] [CONN] input.I[0].O => vgain[3].Z (3.154)
[572] [CONN] input.I[2].O => vgain[0].Z (2.315)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [572] [CONN] input.I[2].O => vgain[0].Z (2.315)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=64

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[567] [CONN] input.I[0].O => vgain[3].Z (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[576] [CONN] input.I[2].O => iadd[0].B (2.315)

============
>> Current Goal: [576] [CONN] input.I[2].O => iadd[0].B (2.315)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=65

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[567] [CONN] input.I[0].O => vgain[3].Z (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [567] [CONN] input.I[0].O => vgain[3].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 8
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=66

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[578] [CONN] input.I[0].O => iadd[1].B (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [578] [CONN] input.I[0].O => iadd[1].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 9
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=67

->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=68

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=69

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[1].C = 0
[multi]    - making an input block.
[multi] > iadd[1].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[0].P = (2.315*ES)
[multi] > iadd[0].OUT = 2.315
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[1].OUT = 3.154
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [sln] rm-route iadd[1].C = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] rm-route iadd[1].A = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] route input.I[3].X = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     add-goal [579] [CONN] input.I[3].O => iadd[1].C (0)
     add-goal [580] [CONN] input.I[4].O => iadd[1].A (0)
     add-goal [581] [CONN] input.I[5].O => iadd[0].C (0)
     add-goal [582] [CONN] input.I[6].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[575] [CONN] input.I[2].O => iadd[0].A (2.315)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[567] [CONN] input.I[0].O => vgain[3].Z (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [567] [CONN] input.I[0].O => vgain[3].Z (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 11
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=70

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[567] [CONN] input.I[0].O => vgain[3].Z (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [567] [CONN] input.I[0].O => vgain[3].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 13
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=71

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[584] [CONN] input.I[0].O => iadd[2].B (3.154)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [584] [CONN] input.I[0].O => iadd[2].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 14
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=72

->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=73

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=74

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[2].C = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[0].P = (2.315*ES)
[multi] > iadd[0].OUT = 2.315
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[2].OUT = 3.154
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [comp] input.I[9] cfg-in X=0
     [comp] input.I[9] cfg-out O=0
     [comp] input.I[10] cfg-in X=0
     [comp] input.I[10] cfg-out O=0
     [sln] rm-route iadd[2].C = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[9]
     [sln] generate input.I[9].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[10]
     [sln] generate input.I[10].O = 0
     [sln] route input.I[7].X = 0
     [sln] route input.I[8].X = 0
     [sln] route input.I[9].X = 0
     [sln] route input.I[10].X = 0
     [comp] make-comp input.I7
     [comp] make-comp input.I8
     [comp] make-comp input.I9
     [comp] make-comp input.I10
     add-goal [585] [CONN] input.I[7].O => iadd[2].C (0)
     add-goal [586] [CONN] input.I[8].O => iadd[2].A (0)
     add-goal [587] [CONN] input.I[9].O => iadd[0].C (0)
     add-goal [588] [CONN] input.I[10].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[585] [CONN] input.I[7].O => iadd[2].C (0)
[587] [CONN] input.I[9].O => iadd[0].C (0)
[586] [CONN] input.I[8].O => iadd[2].A (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[588] [CONN] input.I[10].O => iadd[0].B (0)

============
>> Current Goal: [588] [CONN] input.I[10].O => iadd[0].B (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 16
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=75

->input.I[8]
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[7]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.I[10]
->input.V[1]
->input.I[9]
->output.V[1]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (52) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=76

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (44) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=77

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 42
[multi] # partial ids = 2
[multi]    remove-goal [220] [EXPR]itov[2].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   remove-goal [338] [EXPR]vdadd[4].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[4].D<I>=(3.154*S)
   [comp] vgain[0] cfg-in P=(3.154*E)
   [comp] vgain[0] cfg-in Z=3.154
   [comp] vgain[0] cfg-in X=E
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=ES
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=2.525
   [comp] vdadd[1] cfg-in A=(3.154*E*S)
   [comp] itov[2] cfg-in Y=(3.154*E*S)
   [comp] itov[2] cfg-in X=S
   [comp] itov[2] cfg-in K=(3.154*E)
   [comp] itov[3] cfg-in Y=(2.315*ES)
   [comp] itov[3] cfg-in X=ES
   [comp] itov[3] cfg-in K=2.315
   [comp] vdadd[4] cfg-in OUT_0=0.00124
   [comp] vdadd[4] cfg-in OUT=E
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=(3.154*S)
   [comp] vdadd[4] cfg-in A=(2.315*ES)
   [comp] vtoi[5] cfg-in Y=(3.154*S)
   [comp] vtoi[5] cfg-in X=S
   [comp] vtoi[5] cfg-in K=0.317057704502
   [sln] generate vgain[0].P = (3.154*E)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (3.154*E)
   [sln] conn vgain[0].P->itov[2].K
   [sln] generate vdadd[1].OUT = ES
   [sln] add-comp vdadd[1]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] add-comp itov[2]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] conn itov[2].Y->vdadd[1].A
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = E
   [sln] add-comp vdadd[4]
   [sln] generate vtoi[5].Y = (3.154*S)
   [sln] add-comp vtoi[5]
   [sln] generate vtoi[5].Y = (3.154*S)
   [sln] conn vtoi[5].Y->vdadd[4].D
   [sln] route vgain[0].Z = 3.154
   [sln] route vgain[0].X = E
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].D = 2.525
   [sln] route itov[2].X = S
   [sln] route itov[3].X = ES
   [sln] route itov[3].K = 2.315
   [sln] route vdadd[4].OUT_0 = 0.00124
   [sln] route vtoi[5].X = S
   [sln] route vtoi[5].K = 0.317057704502
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp itov2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vtoi5
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[2].K<V>=(3.154*E)
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[4].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[4].A<V>=(2.315*ES)

[multi] ==== ROUTES =====
[multi] > vtoi[5].X = S
[multi]    - connecting generates to routes.
[multi] > itov[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[0].X = E
[multi]    - connecting generates to routes.
[multi] > itov[3].X = ES
[multi]    - connecting generates to routes.
[multi] > vgain[0].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[5].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vdadd[1].D = 2.525
[multi]    - making an input block.
[multi] > itov[3].K = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = E
[multi]    - making an output block.
[multi] > vdadd[1].OUT = ES
[multi]    - making an output block.
[multi] > itov[3].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > vgain[0].P = (3.154*E)
[multi] > vgain[0].P = (3.154*E)
[multi] > vtoi[5].Y = (3.154*S)
[multi] > vtoi[5].Y = (3.154*S)
[multi] > itov[2].Y = (3.154*E*S)
[multi] > itov[2].Y = (3.154*E*S)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 84 =======
[multi]    remove-goal [220] [EXPR]itov[2].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   remove-goal [338] [EXPR]vdadd[4].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[4].D<I>=(3.154*S)
   [comp] vgain[0] cfg-in P=(3.154*E)
   [comp] vgain[0] cfg-in Z=3.154
   [comp] vgain[0] cfg-in X=E
   [comp] vdadd[1] cfg-in OUT_0=0
   [comp] vdadd[1] cfg-in OUT=ES
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=2.525
   [comp] vdadd[1] cfg-in A=(3.154*E*S)
   [comp] itov[2] cfg-in Y=(3.154*E*S)
   [comp] itov[2] cfg-in X=S
   [comp] itov[2] cfg-in K=(3.154*E)
   [comp] itov[3] cfg-in Y=(2.315*ES)
   [comp] itov[3] cfg-in X=ES
   [comp] itov[3] cfg-in K=2.315
   [comp] vdadd[4] cfg-in OUT_0=0.00124
   [comp] vdadd[4] cfg-in OUT=E
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=(3.154*S)
   [comp] vdadd[4] cfg-in A=(2.315*ES)
   [comp] vtoi[5] cfg-in Y=(3.154*S)
   [comp] vtoi[5] cfg-in X=S
   [comp] vtoi[5] cfg-in K=0.317057704502
   [sln] generate vgain[0].P = (3.154*E)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (3.154*E)
   [sln] conn vgain[0].P->itov[2].K
   [sln] generate vdadd[1].OUT = ES
   [sln] add-comp vdadd[1]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] add-comp itov[2]
   [sln] generate itov[2].Y = (3.154*E*S)
   [sln] conn itov[2].Y->vdadd[1].A
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = E
   [sln] add-comp vdadd[4]
   [sln] generate vtoi[5].Y = (3.154*S)
   [sln] add-comp vtoi[5]
   [sln] generate vtoi[5].Y = (3.154*S)
   [sln] conn vtoi[5].Y->vdadd[4].D
   [sln] route vgain[0].Z = 3.154
   [sln] route vgain[0].X = E
   [sln] route vdadd[1].OUT_0 = 0
   [sln] route vdadd[1].D = 2.525
   [sln] route itov[2].X = S
   [sln] route itov[3].X = ES
   [sln] route itov[3].K = 2.315
   [sln] route vdadd[4].OUT_0 = 0.00124
   [sln] route vtoi[5].X = S
   [sln] route vtoi[5].K = 0.317057704502
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp itov2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vtoi5
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[1].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[2].K<V>=(3.154*E)
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[4].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[4].A<V>=(2.315*ES)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0.00124
     [comp] input.V[2] cfg-out O=0.00124
     [comp] input.I[1] cfg-in X=2.525
     [comp] input.I[1] cfg-out O=2.525
     [comp] input.V[3] cfg-in X=2.315
     [comp] input.V[3] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=E
     [comp] output.V[0] cfg-out O=E
     [comp] output.V[1] cfg-in X=ES
     [comp] output.V[1] cfg-out O=ES
     [sln] rm-route vgain[0].X = E
     [sln] rm-route itov[3].X = ES
     [sln] rm-route vgain[0].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[5].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[1].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[4].OUT_0 = 0.00124
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.00124
     [sln] rm-route vdadd[1].D = 2.525
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 2.525
     [sln] rm-route itov[3].K = 2.315
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = E
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0.00124
     [sln] route input.I[1].X = 2.525
     [sln] route input.V[3].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.I1
     [comp] make-comp input.V3
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     add-goal [589] [CONN] vdadd[4].OUT => vgain[0].X (E)
     add-goal [590] [CONN] vdadd[1].OUT => itov[3].X (ES)
     add-goal [591] [CONN] input.I[0].O => vgain[0].Z (3.154)
     add-goal [592] [CONN] input.V[0].O => vtoi[5].K (0.317057704502)
     add-goal [593] [CONN] input.V[1].O => vdadd[1].OUT_0 (0)
     add-goal [594] [CONN] input.V[2].O => vdadd[4].OUT_0 (0.00124)
     add-goal [595] [CONN] input.I[1].O => vdadd[1].D (2.525)
     add-goal [596] [CONN] input.V[3].O => itov[3].K (2.315)
     add-goal [597] [CONN] vdadd[4].OUT => output.V[0].X (E)
     add-goal [598] [CONN] vdadd[1].OUT => output.V[1].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[591] [CONN] input.I[0].O => vgain[0].Z (3.154)
[590] [CONN] vdadd[1].OUT => itov[3].X (ES)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[595] [CONN] input.I[1].O => vdadd[1].D (2.525)
[597] [CONN] vdadd[4].OUT => output.V[0].X (E)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[592] [CONN] input.V[0].O => vtoi[5].K (0.317057704502)
[593] [CONN] input.V[1].O => vdadd[1].OUT_0 (0)
[594] [CONN] input.V[2].O => vdadd[4].OUT_0 (0.00124)
[596] [CONN] input.V[3].O => itov[3].K (2.315)
[598] [CONN] vdadd[1].OUT => output.V[1].X (ES)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[589] [CONN] vdadd[4].OUT => vgain[0].X (E)

============
>> Current Goal: [589] [CONN] vdadd[4].OUT => vgain[0].X (E)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[1]
->vdadd[1]
->vtoi[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->itov[3]
->output.V[1]
->input.V[3]
->itov[2]
->input.I[0]
->vdadd[4]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (38) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=78

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[591] [CONN] input.I[0].O => vgain[0].Z (3.154)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [591] [CONN] input.I[0].O => vgain[0].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[1]
->vdadd[1]
->vtoi[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->itov[3]
->output.V[1]
->input.V[3]
->itov[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=79

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[600] [CONN] input.I[0].O => iadd[0].B (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [600] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=80

->input.I[1]
->vdadd[1]
->vtoi[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->itov[3]
->output.V[1]
->input.V[3]
->itov[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=81

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[1]
->vdadd[1]
->vtoi[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->itov[3]
->output.V[1]
->input.V[3]
->itov[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=82

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > vtoi[5].X = S
[multi]    - connecting generates to routes.
[multi] > itov[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[3].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > vgain[0].P = (3.154*E)
[multi] > vgain[0].P = (3.154*E)
[multi] > vtoi[5].Y = (3.154*S)
[multi] > vtoi[5].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[2].Y = (3.154*E*S)
[multi] > itov[2].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[2] cfg-in X=0
     [comp] input.I[2] cfg-out O=0
     [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] route input.I[2].X = 0
     [sln] route input.I[3].X = 0
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     add-goal [601] [CONN] input.I[2].O => iadd[0].C (0)
     add-goal [602] [CONN] input.I[3].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[599] [CONN] input.I[0].O => iadd[0].A (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [599] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=83

->input.I[1]
->vdadd[1]
->vtoi[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->itov[3]
->output.V[1]
->input.V[3]
->itov[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=84

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[1]
->vdadd[1]
->input.I[2]
->vtoi[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->itov[3]
->output.V[1]
->input.V[3]
->itov[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=85

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > vtoi[5].X = S
[multi]    - connecting generates to routes.
[multi] > itov[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[3].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > vgain[0].P = (3.154*E)
[multi] > vgain[0].P = (3.154*E)
[multi] > vtoi[5].Y = (3.154*S)
[multi] > vtoi[5].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[2].Y = (3.154*E*S)
[multi] > itov[2].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     add-goal [603] [CONN] input.I[4].O => iadd[0].C (0)
     add-goal [604] [CONN] input.I[5].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[603] [CONN] input.I[4].O => iadd[0].C (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[604] [CONN] input.I[5].O => iadd[0].B (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [604] [CONN] input.I[5].O => iadd[0].B (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=86

->input.I[4]
->input.I[5]
->input.I[1]
->vdadd[1]
->vtoi[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->itov[3]
->output.V[1]
->input.V[3]
->itov[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=87

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[1]
->vdadd[1]
->input.I[2]
->vtoi[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->itov[3]
->output.V[1]
->input.V[3]
->itov[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=88

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 42
[multi] # partial ids = 2
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [220] [EXPR]itov[5].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(3.154*E)
   [comp] vgain[3] cfg-in Z=3.154
   [comp] vgain[3] cfg-in X=E
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=ES
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=2.525
   [comp] vdadd[4] cfg-in A=(3.154*E*S)
   [comp] itov[5] cfg-in Y=(3.154*E*S)
   [comp] itov[5] cfg-in X=S
   [comp] itov[5] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (3.154*E)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (3.154*E)
   [sln] conn vgain[3].P->itov[5].K
   [sln] generate vdadd[4].OUT = ES
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] conn itov[5].Y->vdadd[4].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 3.154
   [sln] route vgain[3].X = E
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].D = 2.525
   [sln] route itov[5].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[5].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[3].X = E
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[3].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vdadd[4].D = 2.525
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[4].OUT = ES
[multi]    - making an output block.
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 84 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [220] [EXPR]itov[5].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(3.154*E)
   [comp] vgain[3] cfg-in Z=3.154
   [comp] vgain[3] cfg-in X=E
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=ES
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=2.525
   [comp] vdadd[4] cfg-in A=(3.154*E*S)
   [comp] itov[5] cfg-in Y=(3.154*E*S)
   [comp] itov[5] cfg-in X=S
   [comp] itov[5] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (3.154*E)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (3.154*E)
   [sln] conn vgain[3].P->itov[5].K
   [sln] generate vdadd[4].OUT = ES
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] conn itov[5].Y->vdadd[4].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 3.154
   [sln] route vgain[3].X = E
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].D = 2.525
   [sln] route itov[5].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[5].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0.00124
     [comp] input.V[2] cfg-out O=0.00124
     [comp] input.I[1] cfg-in X=2.525
     [comp] input.I[1] cfg-out O=2.525
     [comp] input.I[2] cfg-in X=2.315
     [comp] input.I[2] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=E
     [comp] output.V[0] cfg-out O=E
     [comp] output.V[1] cfg-in X=ES
     [comp] output.V[1] cfg-out O=ES
     [sln] rm-route vgain[3].X = E
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[3].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.00124
     [sln] rm-route vdadd[4].D = 2.525
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 2.525
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = E
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0.00124
     [sln] route input.I[1].X = 2.525
     [sln] route input.I[2].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.I1
     [comp] make-comp input.I2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     add-goal [605] [CONN] vdadd[1].OUT => vgain[3].X (E)
     add-goal [606] [CONN] vdadd[4].OUT => itov[0].K (ES)
     add-goal [607] [CONN] input.I[0].O => vgain[3].Z (3.154)
     add-goal [608] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
     add-goal [609] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
     add-goal [610] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.00124)
     add-goal [611] [CONN] input.I[1].O => vdadd[4].D (2.525)
     add-goal [612] [CONN] input.I[2].O => itov[0].X (2.315)
     add-goal [613] [CONN] vdadd[1].OUT => output.V[0].X (E)
     add-goal [614] [CONN] vdadd[4].OUT => output.V[1].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[614] [CONN] vdadd[4].OUT => output.V[1].X (ES)
[605] [CONN] vdadd[1].OUT => vgain[3].X (E)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[609] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
[610] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.00124)
[607] [CONN] input.I[0].O => vgain[3].Z (3.154)
[608] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
[613] [CONN] vdadd[1].OUT => output.V[0].X (E)
[606] [CONN] vdadd[4].OUT => itov[0].K (ES)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[611] [CONN] input.I[1].O => vdadd[4].D (2.525)
[612] [CONN] input.I[2].O => itov[0].X (2.315)

============
>> Current Goal: [612] [CONN] input.I[2].O => itov[0].X (2.315)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (38) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=89

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[607] [CONN] input.I[0].O => vgain[3].Z (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [607] [CONN] input.I[0].O => vgain[3].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=90

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[616] [CONN] input.I[0].O => iadd[0].B (3.154)

============
>> Current Goal: [616] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=91

->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=92

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=93

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] route input.I[3].X = 0
     [sln] route input.I[4].X = 0
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [617] [CONN] input.I[3].O => iadd[0].C (0)
     add-goal [618] [CONN] input.I[4].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[615] [CONN] input.I[0].O => iadd[0].A (3.154)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [615] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=94

->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=95

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=96

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     add-goal [619] [CONN] input.I[5].O => iadd[0].C (0)
     add-goal [620] [CONN] input.I[6].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[620] [CONN] input.I[6].O => iadd[0].B (0)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[619] [CONN] input.I[5].O => iadd[0].C (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [619] [CONN] input.I[5].O => iadd[0].C (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=97

->input.I[5]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->input.I[6]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=98

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=99

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 42
[multi] # partial ids = 2
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [220] [EXPR]itov[5].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(3.154*E)
   [comp] vgain[3] cfg-in Z=3.154
   [comp] vgain[3] cfg-in X=E
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=ES
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=2.525
   [comp] vdadd[4] cfg-in A=(3.154*E*S)
   [comp] itov[5] cfg-in Y=(3.154*E*S)
   [comp] itov[5] cfg-in X=S
   [comp] itov[5] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (3.154*E)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (3.154*E)
   [sln] conn vgain[3].P->itov[5].K
   [sln] generate vdadd[4].OUT = ES
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] conn itov[5].Y->vdadd[4].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 3.154
   [sln] route vgain[3].X = E
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].D = 2.525
   [sln] route itov[5].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[5].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[3].X = E
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[3].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vdadd[4].D = 2.525
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[4].OUT = ES
[multi]    - making an output block.
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 84 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [220] [EXPR]itov[5].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(3.154*E)
   [comp] vgain[3] cfg-in Z=3.154
   [comp] vgain[3] cfg-in X=E
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=ES
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=2.525
   [comp] vdadd[4] cfg-in A=(3.154*E*S)
   [comp] itov[5] cfg-in Y=(3.154*E*S)
   [comp] itov[5] cfg-in X=S
   [comp] itov[5] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (3.154*E)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (3.154*E)
   [sln] conn vgain[3].P->itov[5].K
   [sln] generate vdadd[4].OUT = ES
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] conn itov[5].Y->vdadd[4].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 3.154
   [sln] route vgain[3].X = E
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].D = 2.525
   [sln] route itov[5].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[5].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0.00124
     [comp] input.V[2] cfg-out O=0.00124
     [comp] input.I[1] cfg-in X=2.525
     [comp] input.I[1] cfg-out O=2.525
     [comp] input.I[2] cfg-in X=2.315
     [comp] input.I[2] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=E
     [comp] output.V[0] cfg-out O=E
     [comp] output.V[1] cfg-in X=ES
     [comp] output.V[1] cfg-out O=ES
     [sln] rm-route vgain[3].X = E
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[3].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.00124
     [sln] rm-route vdadd[4].D = 2.525
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 2.525
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = E
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0.00124
     [sln] route input.I[1].X = 2.525
     [sln] route input.I[2].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.I1
     [comp] make-comp input.I2
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     add-goal [621] [CONN] vdadd[1].OUT => vgain[3].X (E)
     add-goal [622] [CONN] vdadd[4].OUT => itov[0].K (ES)
     add-goal [623] [CONN] input.I[0].O => vgain[3].Z (3.154)
     add-goal [624] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
     add-goal [625] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
     add-goal [626] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.00124)
     add-goal [627] [CONN] input.I[1].O => vdadd[4].D (2.525)
     add-goal [628] [CONN] input.I[2].O => itov[0].X (2.315)
     add-goal [629] [CONN] vdadd[1].OUT => output.V[0].X (E)
     add-goal [630] [CONN] vdadd[4].OUT => output.V[1].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[621] [CONN] vdadd[1].OUT => vgain[3].X (E)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[630] [CONN] vdadd[4].OUT => output.V[1].X (ES)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[629] [CONN] vdadd[1].OUT => output.V[0].X (E)
[624] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
[626] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.00124)
[623] [CONN] input.I[0].O => vgain[3].Z (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[628] [CONN] input.I[2].O => itov[0].X (2.315)
[622] [CONN] vdadd[4].OUT => itov[0].K (ES)
[625] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
[627] [CONN] input.I[1].O => vdadd[4].D (2.525)

============
>> Current Goal: [627] [CONN] input.I[1].O => vdadd[4].D (2.525)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (38) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=100

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[623] [CONN] input.I[0].O => vgain[3].Z (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [623] [CONN] input.I[0].O => vgain[3].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=101

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[632] [CONN] input.I[0].O => iadd[0].B (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [632] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=102

->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=103

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=104

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] route input.I[3].X = 0
     [sln] route input.I[4].X = 0
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     add-goal [633] [CONN] input.I[3].O => iadd[0].C (0)
     add-goal [634] [CONN] input.I[4].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[631] [CONN] input.I[0].O => iadd[0].A (3.154)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [631] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=105

->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=106

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=107

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     add-goal [635] [CONN] input.I[5].O => iadd[0].C (0)
     add-goal [636] [CONN] input.I[6].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[635] [CONN] input.I[5].O => iadd[0].C (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[636] [CONN] input.I[6].O => iadd[0].B (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [636] [CONN] input.I[6].O => iadd[0].B (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=108

->input.I[5]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->input.I[6]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=109

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=110

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 42
[multi] # partial ids = 2
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [220] [EXPR]itov[5].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(2.315*ES)
   [comp] vgain[0] cfg-in Z=ES
   [comp] vgain[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(3.154*E)
   [comp] vgain[3] cfg-in Z=3.154
   [comp] vgain[3] cfg-in X=E
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=ES
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=2.525
   [comp] vdadd[4] cfg-in A=(3.154*E*S)
   [comp] itov[5] cfg-in Y=(3.154*E*S)
   [comp] itov[5] cfg-in X=S
   [comp] itov[5] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (3.154*E)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (3.154*E)
   [sln] conn vgain[3].P->itov[5].K
   [sln] generate vdadd[4].OUT = ES
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] conn itov[5].Y->vdadd[4].A
   [sln] route vgain[0].Z = ES
   [sln] route vgain[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 3.154
   [sln] route vgain[3].X = E
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].D = 2.525
   [sln] route itov[5].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[5].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[3].X = E
[multi]    - connecting generates to routes.
[multi] > vgain[0].Z = ES
[multi]    - connecting generates to routes.
[multi] > vgain[3].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vdadd[4].D = 2.525
[multi]    - making an input block.
[multi] > vgain[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[4].OUT = ES
[multi]    - making an output block.
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 10
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 84 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [220] [EXPR]itov[5].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   [comp] vgain[0] cfg-in P=(2.315*ES)
   [comp] vgain[0] cfg-in Z=ES
   [comp] vgain[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(3.154*E)
   [comp] vgain[3] cfg-in Z=3.154
   [comp] vgain[3] cfg-in X=E
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=ES
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=2.525
   [comp] vdadd[4] cfg-in A=(3.154*E*S)
   [comp] itov[5] cfg-in Y=(3.154*E*S)
   [comp] itov[5] cfg-in X=S
   [comp] itov[5] cfg-in K=(3.154*E)
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] add-comp vgain[0]
   [sln] generate vgain[0].P = (2.315*ES)
   [sln] conn vgain[0].P->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (3.154*E)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (3.154*E)
   [sln] conn vgain[3].P->itov[5].K
   [sln] generate vdadd[4].OUT = ES
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (3.154*E*S)
   [sln] conn itov[5].Y->vdadd[4].A
   [sln] route vgain[0].Z = ES
   [sln] route vgain[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 3.154
   [sln] route vgain[3].X = E
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].D = 2.525
   [sln] route itov[5].X = S
   [comp] make-comp vgain0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[4].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[5].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0.00124
     [comp] input.V[2] cfg-out O=0.00124
     [comp] input.I[1] cfg-in X=2.525
     [comp] input.I[1] cfg-out O=2.525
     [comp] input.V[3] cfg-in X=2.315
     [comp] input.V[3] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=E
     [comp] output.V[0] cfg-out O=E
     [comp] output.V[1] cfg-in X=ES
     [comp] output.V[1] cfg-out O=ES
     [sln] rm-route vgain[3].X = E
     [sln] rm-route vgain[0].Z = ES
     [sln] rm-route vgain[3].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.00124
     [sln] rm-route vdadd[4].D = 2.525
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 2.525
     [sln] rm-route vgain[0].X = 2.315
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = E
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0.00124
     [sln] route input.I[1].X = 2.525
     [sln] route input.V[3].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.I1
     [comp] make-comp input.V3
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     add-goal [637] [CONN] vdadd[1].OUT => vgain[3].X (E)
     add-goal [638] [CONN] vdadd[4].OUT => vgain[0].Z (ES)
     add-goal [639] [CONN] input.I[0].O => vgain[3].Z (3.154)
     add-goal [640] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
     add-goal [641] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
     add-goal [642] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.00124)
     add-goal [643] [CONN] input.I[1].O => vdadd[4].D (2.525)
     add-goal [644] [CONN] input.V[3].O => vgain[0].X (2.315)
     add-goal [645] [CONN] vdadd[1].OUT => output.V[0].X (E)
     add-goal [646] [CONN] vdadd[4].OUT => output.V[1].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[637] [CONN] vdadd[1].OUT => vgain[3].X (E)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[639] [CONN] input.I[0].O => vgain[3].Z (3.154)
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[645] [CONN] vdadd[1].OUT => output.V[0].X (E)
[638] [CONN] vdadd[4].OUT => vgain[0].Z (ES)
[641] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
[643] [CONN] input.I[1].O => vdadd[4].D (2.525)
[644] [CONN] input.V[3].O => vgain[0].X (2.315)
[646] [CONN] vdadd[4].OUT => output.V[1].X (ES)
[640] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[642] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.00124)

============
>> Current Goal: [642] [CONN] input.V[2].O => vdadd[1].OUT_0 (0.00124)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.Z
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->input.V[3]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (38) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 10
[[Z3]] ---> Executing SMT Solver prob=111

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[639] [CONN] input.I[0].O => vgain[3].Z (3.154)
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [639] [CONN] input.I[0].O => vgain[3].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=112

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[648] [CONN] input.I[0].O => iadd[0].B (3.154)

============
>> Current Goal: [648] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=113

->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=114

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=115

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[2] cfg-in X=0
     [comp] input.I[2] cfg-out O=0
     [comp] input.I[3] cfg-in X=0
     [comp] input.I[3] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 0
     [sln] route input.I[2].X = 0
     [sln] route input.I[3].X = 0
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     add-goal [649] [CONN] input.I[2].O => iadd[0].C (0)
     add-goal [650] [CONN] input.I[3].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[647] [CONN] input.I[0].O => iadd[0].A (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [647] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=116

->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (41) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=117

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=118

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[5].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[2].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[0].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[1].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[0].P = (2.315*ES)
[multi] > vgain[3].P = (3.154*E)
[multi] > vgain[3].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[5].Y = (3.154*E*S)
[multi] > itov[5].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     add-goal [651] [CONN] input.I[4].O => iadd[0].C (0)
     add-goal [652] [CONN] input.I[5].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[651] [CONN] input.I[4].O => iadd[0].C (0)
[652] [CONN] input.I[5].O => iadd[0].B (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [652] [CONN] input.I[5].O => iadd[0].B (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=119

->input.I[4]
->input.I[5]
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 9
[[Z3]] ---> Executing SMT Solver prob=120

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[1]
->vtoi[2]
->vdadd[1]
->itov[5]
->input.I[2]
->input.V[2]
->output.V[0]
->vgain[0]
->input.V[1]
->output.V[1]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (45) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=121

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi] # Found 0, Required: 1
[multi] solving target: P
[multi] search tree is not exhausted. adding existing:P
[multi] finding new partial solution
[multi] made a partial tree with 4 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
vdadd.OUT -> true
mm.XY -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  2 <<<
[eqn] new: [0] <vdadd> output OUT.V
<analog-st> ((vdadd.V{A}:+(vdadd.BSW*vdadd.V{B}:))-(vdadd.DSW*vdadd.I{D}:*vdadd.V{OUT}:)) ic=OUT_0.V / std=none 0
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,12000.] {v}->[v]=@ {v}->*[v]=@


checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
[eqn] new: [0] <mm> output XY.V
<analog-st> ((mm.I{kf}:*mm.V{X}:*mm.V{Y}:)-(mm.I{kr}:*mm.V{XY}:)) ic=XY0.V / std=gauss ((0.001*mm.V{XY}:)+0.1)
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,3200.] {v}->[v]=@ {v}->*[v]=@


[eqn] [FOUND-SOLS] ===> Found <8> solutions
[slvrsearch] > weight--: <mvar-goal>P
[eqn] -> [valid?] testing node 17
->vdadd[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (3) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 3
[[Z3]] ---> Executing SMT Solver prob=122

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[672] [EXPR]vdadd[1].A<V>=(0.21*ES)
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [672] [EXPR]vdadd[1].A<V>=(0.21*ES)
vgain.P -> true
vadd.OUT -> true
mm.X -> true
mm.Y -> true
itov.Y -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  5 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <vadd> output OUT.V
<analog>:(((vadd.V{A}:+(vadd.BSW*vadd.V{B}:))-(vadd.CSW*vadd.V{C}:))*0.25) / std=gauss ((0.001*vadd.V{OUT}:)+0.1)
<analog> [v]={[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } {v}->[v]=@


[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <mm> output Y.V
<analog>:(mm.V{Ytot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <mm> output X.V
<analog>:(mm.V{Xtot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <itov> output Y.V
<analog>:(itov.V{K}:*itov.I{X}:) / std=gauss 0.1
<analog> [v]=[0.,3300.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] [FOUND-SOLS] ===> Found <23> solutions
[slvrsearch] > weight--: (0.21*ES)
[eqn] -> [valid?] testing node 63
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=123

->vdadd[1]
->itov[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (7) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 4
[[Z3]] ---> Executing SMT Solver prob=124

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 61
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=125

->vdadd[1]
->itov[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (7) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 4
[[Z3]] ---> Executing SMT Solver prob=126

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 59
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=127

->vdadd[1]
->itov[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (7) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 4
[[Z3]] ---> Executing SMT Solver prob=128

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 27
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=129

->vdadd[1]
->vgain[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (7) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 4
[[Z3]] ---> Executing SMT Solver prob=130

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 25
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=131

->vdadd[1]
->vgain[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (7) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 4
[[Z3]] ---> Executing SMT Solver prob=132

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 23
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=133

->vdadd[1]
->vgain[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (7) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 4
[[Z3]] ---> Executing SMT Solver prob=134

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 58
->itov[0]
->vdadd[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (7) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=135

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 25 ==
[multi] == Adding Local Solution : 23 ==
[multi] == Adding Local Solution : 59 ==
[multi] == Adding Local Solution : 27 ==
[multi] == Adding Local Solution : 61 ==
[multi] == Adding Local Solution : 63 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] # partial ids = 3
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(0.21*ES)
   [comp] vgain[3] cfg-in X=ES
   [comp] vgain[3] cfg-in Z=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].X = ES
   [sln] route vgain[3].Z = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[5].X = E
[multi]    - connecting generates to routes.
[multi] > vgain[3].X = ES
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[5].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].B = 0
[multi]    - making an input block.
[multi] > vdadd[6].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vgain[3].Z = 0.21
[multi]    - making an input block.
[multi] > vdadd[6].D = 2.525
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[6].OUT = ES
[multi]    - making an output block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 16
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(0.21*ES)
   [comp] vgain[3] cfg-in X=ES
   [comp] vgain[3] cfg-in Z=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].X = ES
   [sln] route vgain[3].Z = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[4] cfg-in X=0.00124
     [comp] input.V[4] cfg-out O=0.00124
     [comp] input.I[2] cfg-in X=0.21
     [comp] input.I[2] cfg-out O=0.21
     [comp] input.I[3] cfg-in X=2.525
     [comp] input.I[3] cfg-out O=2.525
     [comp] input.I[4] cfg-in X=2.315
     [comp] input.I[4] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=P
     [comp] output.V[0] cfg-out O=P
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route vgain[5].X = E
     [sln] rm-route vgain[3].X = ES
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[5].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[4].B = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[6].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[4].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0.00124
     [sln] rm-route vgain[3].Z = 0.21
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 0.21
     [sln] rm-route vdadd[6].D = 2.525
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.525
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = P
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[4].X = 0.00124
     [sln] route input.I[2].X = 0.21
     [sln] route input.I[3].X = 2.525
     [sln] route input.I[4].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I1
     [comp] make-comp input.V4
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [713] [CONN] vdadd[1].OUT => vgain[5].X (E)
     add-goal [714] [CONN] vdadd[6].OUT => vgain[3].X (ES)
     add-goal [715] [CONN] vdadd[6].OUT => itov[0].K (ES)
     add-goal [716] [CONN] input.I[0].O => vgain[5].Z (3.154)
     add-goal [717] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
     add-goal [718] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
     add-goal [719] [CONN] input.V[2].O => vdadd[4].B (0)
     add-goal [720] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
     add-goal [721] [CONN] input.I[1].O => vdadd[4].D (0)
     add-goal [722] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
     add-goal [723] [CONN] input.I[2].O => vgain[3].Z (0.21)
     add-goal [724] [CONN] input.I[3].O => vdadd[6].D (2.525)
     add-goal [725] [CONN] input.I[4].O => itov[0].X (2.315)
     add-goal [726] [CONN] vdadd[4].OUT => output.V[0].X (P)
     add-goal [727] [CONN] vdadd[1].OUT => output.V[1].X (E)
     add-goal [728] [CONN] vdadd[6].OUT => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[724] [CONN] input.I[3].O => vdadd[6].D (2.525)
[725] [CONN] input.I[4].O => itov[0].X (2.315)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[721] [CONN] input.I[1].O => vdadd[4].D (0)
[715] [CONN] vdadd[6].OUT => itov[0].K (ES)
[719] [CONN] input.V[2].O => vdadd[4].B (0)
[727] [CONN] vdadd[1].OUT => output.V[1].X (E)
[718] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[714] [CONN] vdadd[6].OUT => vgain[3].X (ES)
[716] [CONN] input.I[0].O => vgain[5].Z (3.154)
[728] [CONN] vdadd[6].OUT => output.V[2].X (ES)
[717] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
[723] [CONN] input.I[2].O => vgain[3].Z (0.21)
[726] [CONN] vdadd[4].OUT => output.V[0].X (P)
[720] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[722] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[713] [CONN] vdadd[1].OUT => vgain[5].X (E)

============
>> Current Goal: [713] [CONN] vdadd[1].OUT => vgain[5].X (E)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (55) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=136

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[716] [CONN] input.I[0].O => vgain[5].Z (3.154)
[723] [CONN] input.I[2].O => vgain[3].Z (0.21)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [723] [CONN] input.I[2].O => vgain[3].Z (0.21)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=137

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[730] [CONN] input.I[2].O => iadd[0].B (0.21)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[716] [CONN] input.I[0].O => vgain[5].Z (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [716] [CONN] input.I[0].O => vgain[5].Z (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=138

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[716] [CONN] input.I[0].O => vgain[5].Z (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [716] [CONN] input.I[0].O => vgain[5].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 8
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=139

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[732] [CONN] input.I[0].O => iadd[1].B (3.154)
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [732] [CONN] input.I[0].O => iadd[1].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 9
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=140

->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=141

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=142

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[1].C = 0
[multi]    - making an input block.
[multi] > iadd[1].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > iadd[0].OUT = 0.21
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[1].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [sln] rm-route iadd[1].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[1].A = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [sln] route input.I[7].X = 0
     [sln] route input.I[8].X = 0
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     [comp] make-comp input.I8
     add-goal [733] [CONN] input.I[5].O => iadd[1].C (0)
     add-goal [734] [CONN] input.I[6].O => iadd[1].A (0)
     add-goal [735] [CONN] input.I[7].O => iadd[0].C (0)
     add-goal [736] [CONN] input.I[8].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[716] [CONN] input.I[0].O => vgain[5].Z (3.154)
[729] [CONN] input.I[2].O => iadd[0].A (0.21)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [729] [CONN] input.I[2].O => iadd[0].A (0.21)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 11
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=143

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[716] [CONN] input.I[0].O => vgain[5].Z (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [716] [CONN] input.I[0].O => vgain[5].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 13
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=144

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[738] [CONN] input.I[0].O => iadd[2].B (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [738] [CONN] input.I[0].O => iadd[2].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 14
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=145

->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=146

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=147

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[2].C = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > iadd[0].OUT = 0.21
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[2].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[9] cfg-in X=0
     [comp] input.I[9] cfg-out O=0
     [comp] input.I[10] cfg-in X=0
     [comp] input.I[10] cfg-out O=0
     [comp] input.I[11] cfg-in X=0
     [comp] input.I[11] cfg-out O=0
     [comp] input.I[12] cfg-in X=0
     [comp] input.I[12] cfg-out O=0
     [sln] rm-route iadd[2].C = 0
     [sln] add-comp input.I[9]
     [sln] generate input.I[9].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[10]
     [sln] generate input.I[10].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[11]
     [sln] generate input.I[11].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[12]
     [sln] generate input.I[12].O = 0
     [sln] route input.I[9].X = 0
     [sln] route input.I[10].X = 0
     [sln] route input.I[11].X = 0
     [sln] route input.I[12].X = 0
     [comp] make-comp input.I9
     [comp] make-comp input.I10
     [comp] make-comp input.I11
     [comp] make-comp input.I12
     add-goal [739] [CONN] input.I[9].O => iadd[2].C (0)
     add-goal [740] [CONN] input.I[10].O => iadd[2].A (0)
     add-goal [741] [CONN] input.I[11].O => iadd[0].C (0)
     add-goal [742] [CONN] input.I[12].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[740] [CONN] input.I[10].O => iadd[2].A (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[741] [CONN] input.I[11].O => iadd[0].C (0)
[742] [CONN] input.I[12].O => iadd[0].B (0)
[739] [CONN] input.I[9].O => iadd[2].C (0)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [739] [CONN] input.I[9].O => iadd[2].C (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 16
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=148

->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.I[12]
->input.I[10]
->input.V[1]
->input.I[9]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[11]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (69) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=149

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=150

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] # partial ids = 3
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(0.21*ES)
   [comp] vgain[3] cfg-in Z=0.21
   [comp] vgain[3] cfg-in X=ES
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 0.21
   [sln] route vgain[3].X = ES
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[5].X = E
[multi]    - connecting generates to routes.
[multi] > vgain[3].X = ES
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[5].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].B = 0
[multi]    - making an input block.
[multi] > vdadd[6].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vgain[3].Z = 0.21
[multi]    - making an input block.
[multi] > vdadd[6].D = 2.525
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[6].OUT = ES
[multi]    - making an output block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 16
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(0.21*ES)
   [comp] vgain[3] cfg-in Z=0.21
   [comp] vgain[3] cfg-in X=ES
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = 0.21
   [sln] route vgain[3].X = ES
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[4] cfg-in X=0.00124
     [comp] input.V[4] cfg-out O=0.00124
     [comp] input.I[2] cfg-in X=0.21
     [comp] input.I[2] cfg-out O=0.21
     [comp] input.I[3] cfg-in X=2.525
     [comp] input.I[3] cfg-out O=2.525
     [comp] input.I[4] cfg-in X=2.315
     [comp] input.I[4] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=P
     [comp] output.V[0] cfg-out O=P
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route vgain[5].X = E
     [sln] rm-route vgain[3].X = ES
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[5].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[4].B = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[6].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[4].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0.00124
     [sln] rm-route vgain[3].Z = 0.21
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 0.21
     [sln] rm-route vdadd[6].D = 2.525
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.525
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = P
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[4].X = 0.00124
     [sln] route input.I[2].X = 0.21
     [sln] route input.I[3].X = 2.525
     [sln] route input.I[4].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I1
     [comp] make-comp input.V4
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [743] [CONN] vdadd[1].OUT => vgain[5].X (E)
     add-goal [744] [CONN] vdadd[6].OUT => vgain[3].X (ES)
     add-goal [745] [CONN] vdadd[6].OUT => itov[0].K (ES)
     add-goal [746] [CONN] input.I[0].O => vgain[5].Z (3.154)
     add-goal [747] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
     add-goal [748] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
     add-goal [749] [CONN] input.V[2].O => vdadd[4].B (0)
     add-goal [750] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
     add-goal [751] [CONN] input.I[1].O => vdadd[4].D (0)
     add-goal [752] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
     add-goal [753] [CONN] input.I[2].O => vgain[3].Z (0.21)
     add-goal [754] [CONN] input.I[3].O => vdadd[6].D (2.525)
     add-goal [755] [CONN] input.I[4].O => itov[0].X (2.315)
     add-goal [756] [CONN] vdadd[4].OUT => output.V[0].X (P)
     add-goal [757] [CONN] vdadd[1].OUT => output.V[1].X (E)
     add-goal [758] [CONN] vdadd[6].OUT => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[748] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[745] [CONN] vdadd[6].OUT => itov[0].K (ES)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[751] [CONN] input.I[1].O => vdadd[4].D (0)
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[747] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[746] [CONN] input.I[0].O => vgain[5].Z (3.154)
[743] [CONN] vdadd[1].OUT => vgain[5].X (E)
[755] [CONN] input.I[4].O => itov[0].X (2.315)
[744] [CONN] vdadd[6].OUT => vgain[3].X (ES)
[750] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
[753] [CONN] input.I[2].O => vgain[3].Z (0.21)
[754] [CONN] input.I[3].O => vdadd[6].D (2.525)
[749] [CONN] input.V[2].O => vdadd[4].B (0)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[752] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
[758] [CONN] vdadd[6].OUT => output.V[2].X (ES)
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[757] [CONN] vdadd[1].OUT => output.V[1].X (E)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[756] [CONN] vdadd[4].OUT => output.V[0].X (P)

============
>> Current Goal: [756] [CONN] vdadd[4].OUT => output.V[0].X (P)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (55) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=151

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[746] [CONN] input.I[0].O => vgain[5].Z (3.154)
[753] [CONN] input.I[2].O => vgain[3].Z (0.21)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [753] [CONN] input.I[2].O => vgain[3].Z (0.21)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=152

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[746] [CONN] input.I[0].O => vgain[5].Z (3.154)
[760] [CONN] input.I[2].O => iadd[0].B (0.21)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [760] [CONN] input.I[2].O => iadd[0].B (0.21)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=153

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[746] [CONN] input.I[0].O => vgain[5].Z (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [746] [CONN] input.I[0].O => vgain[5].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 8
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=154

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[762] [CONN] input.I[0].O => iadd[1].B (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [762] [CONN] input.I[0].O => iadd[1].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 9
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=155

->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=156

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=157

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[1].C = 0
[multi]    - making an input block.
[multi] > iadd[1].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > iadd[0].OUT = 0.21
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[1].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [sln] rm-route iadd[1].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[1].A = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [sln] route input.I[7].X = 0
     [sln] route input.I[8].X = 0
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     [comp] make-comp input.I8
     add-goal [763] [CONN] input.I[5].O => iadd[1].C (0)
     add-goal [764] [CONN] input.I[6].O => iadd[1].A (0)
     add-goal [765] [CONN] input.I[7].O => iadd[0].C (0)
     add-goal [766] [CONN] input.I[8].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[746] [CONN] input.I[0].O => vgain[5].Z (3.154)
[759] [CONN] input.I[2].O => iadd[0].A (0.21)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [759] [CONN] input.I[2].O => iadd[0].A (0.21)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 11
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=158

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[746] [CONN] input.I[0].O => vgain[5].Z (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [746] [CONN] input.I[0].O => vgain[5].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 13
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=159

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[768] [CONN] input.I[0].O => iadd[2].B (3.154)
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [768] [CONN] input.I[0].O => iadd[2].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 14
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=160

->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=161

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=162

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[2].C = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > iadd[0].OUT = 0.21
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[2].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[9] cfg-in X=0
     [comp] input.I[9] cfg-out O=0
     [comp] input.I[10] cfg-in X=0
     [comp] input.I[10] cfg-out O=0
     [comp] input.I[11] cfg-in X=0
     [comp] input.I[11] cfg-out O=0
     [comp] input.I[12] cfg-in X=0
     [comp] input.I[12] cfg-out O=0
     [sln] rm-route iadd[2].C = 0
     [sln] add-comp input.I[9]
     [sln] generate input.I[9].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[10]
     [sln] generate input.I[10].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[11]
     [sln] generate input.I[11].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[12]
     [sln] generate input.I[12].O = 0
     [sln] route input.I[9].X = 0
     [sln] route input.I[10].X = 0
     [sln] route input.I[11].X = 0
     [sln] route input.I[12].X = 0
     [comp] make-comp input.I9
     [comp] make-comp input.I10
     [comp] make-comp input.I11
     [comp] make-comp input.I12
     add-goal [769] [CONN] input.I[9].O => iadd[2].C (0)
     add-goal [770] [CONN] input.I[10].O => iadd[2].A (0)
     add-goal [771] [CONN] input.I[11].O => iadd[0].C (0)
     add-goal [772] [CONN] input.I[12].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[772] [CONN] input.I[12].O => iadd[0].B (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[769] [CONN] input.I[9].O => iadd[2].C (0)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[770] [CONN] input.I[10].O => iadd[2].A (0)
[771] [CONN] input.I[11].O => iadd[0].C (0)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [771] [CONN] input.I[11].O => iadd[0].C (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 16
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=163

->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.I[12]
->input.I[10]
->input.V[1]
->input.I[9]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[11]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (69) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=164

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (61) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=165

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] # partial ids = 3
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] itov[3] cfg-in Y=(0.21*ES)
   [comp] itov[3] cfg-in K=ES
   [comp] itov[3] cfg-in X=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route itov[3].K = ES
   [sln] route itov[3].X = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[5].X = E
[multi]    - connecting generates to routes.
[multi] > itov[3].K = ES
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[5].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].B = 0
[multi]    - making an input block.
[multi] > vdadd[6].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > itov[3].X = 0.21
[multi]    - making an input block.
[multi] > vdadd[6].D = 2.525
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[6].OUT = ES
[multi]    - making an output block.
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 16
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] itov[3] cfg-in Y=(0.21*ES)
   [comp] itov[3] cfg-in K=ES
   [comp] itov[3] cfg-in X=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route itov[3].K = ES
   [sln] route itov[3].X = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[4] cfg-in X=0.00124
     [comp] input.V[4] cfg-out O=0.00124
     [comp] input.I[2] cfg-in X=0.21
     [comp] input.I[2] cfg-out O=0.21
     [comp] input.I[3] cfg-in X=2.525
     [comp] input.I[3] cfg-out O=2.525
     [comp] input.I[4] cfg-in X=2.315
     [comp] input.I[4] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=P
     [comp] output.V[0] cfg-out O=P
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route vgain[5].X = E
     [sln] rm-route itov[3].K = ES
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[5].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[4].B = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[6].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[4].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0.00124
     [sln] rm-route itov[3].X = 0.21
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 0.21
     [sln] rm-route vdadd[6].D = 2.525
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.525
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = P
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[4].X = 0.00124
     [sln] route input.I[2].X = 0.21
     [sln] route input.I[3].X = 2.525
     [sln] route input.I[4].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I1
     [comp] make-comp input.V4
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [773] [CONN] vdadd[1].OUT => vgain[5].X (E)
     add-goal [774] [CONN] vdadd[6].OUT => itov[3].K (ES)
     add-goal [775] [CONN] vdadd[6].OUT => itov[0].K (ES)
     add-goal [776] [CONN] input.I[0].O => vgain[5].Z (3.154)
     add-goal [777] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
     add-goal [778] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
     add-goal [779] [CONN] input.V[2].O => vdadd[4].B (0)
     add-goal [780] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
     add-goal [781] [CONN] input.I[1].O => vdadd[4].D (0)
     add-goal [782] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
     add-goal [783] [CONN] input.I[2].O => itov[3].X (0.21)
     add-goal [784] [CONN] input.I[3].O => vdadd[6].D (2.525)
     add-goal [785] [CONN] input.I[4].O => itov[0].X (2.315)
     add-goal [786] [CONN] vdadd[4].OUT => output.V[0].X (P)
     add-goal [787] [CONN] vdadd[1].OUT => output.V[1].X (E)
     add-goal [788] [CONN] vdadd[6].OUT => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[784] [CONN] input.I[3].O => vdadd[6].D (2.525)
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[786] [CONN] vdadd[4].OUT => output.V[0].X (P)
[774] [CONN] vdadd[6].OUT => itov[3].K (ES)
[776] [CONN] input.I[0].O => vgain[5].Z (3.154)
[780] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[782] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
[779] [CONN] input.V[2].O => vdadd[4].B (0)
[783] [CONN] input.I[2].O => itov[3].X (0.21)
[787] [CONN] vdadd[1].OUT => output.V[1].X (E)
[781] [CONN] input.I[1].O => vdadd[4].D (0)
[777] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
[785] [CONN] input.I[4].O => itov[0].X (2.315)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[773] [CONN] vdadd[1].OUT => vgain[5].X (E)
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[775] [CONN] vdadd[6].OUT => itov[0].K (ES)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[778] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
[788] [CONN] vdadd[6].OUT => output.V[2].X (ES)

============
>> Current Goal: [788] [CONN] vdadd[6].OUT => output.V[2].X (ES)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (55) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=166

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[776] [CONN] input.I[0].O => vgain[5].Z (3.154)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [776] [CONN] input.I[0].O => vgain[5].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=167

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[790] [CONN] input.I[0].O => iadd[0].B (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [790] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=168

->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=169

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=170

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     add-goal [791] [CONN] input.I[5].O => iadd[0].C (0)
     add-goal [792] [CONN] input.I[6].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[789] [CONN] input.I[0].O => iadd[0].A (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [789] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=171

->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=172

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->input.I[5]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[6]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=173

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] route input.I[7].X = 0
     [sln] route input.I[8].X = 0
     [comp] make-comp input.I7
     [comp] make-comp input.I8
     add-goal [793] [CONN] input.I[7].O => iadd[0].C (0)
     add-goal [794] [CONN] input.I[8].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[793] [CONN] input.I[7].O => iadd[0].C (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[794] [CONN] input.I[8].O => iadd[0].B (0)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [794] [CONN] input.I[8].O => iadd[0].B (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=174

->input.I[3]
->input.I[4]
->input.I[8]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[7]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=175

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->input.I[5]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[6]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=176

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] # partial ids = 3
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(0.21*ES)
   [comp] vgain[3] cfg-in Z=ES
   [comp] vgain[3] cfg-in X=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = ES
   [sln] route vgain[3].X = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[5].X = E
[multi]    - connecting generates to routes.
[multi] > vgain[3].Z = ES
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[5].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].B = 0
[multi]    - making an input block.
[multi] > vdadd[6].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vgain[3].X = 0.21
[multi]    - making an input block.
[multi] > vdadd[6].D = 2.525
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[6].OUT = ES
[multi]    - making an output block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 16
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(0.21*ES)
   [comp] vgain[3] cfg-in Z=ES
   [comp] vgain[3] cfg-in X=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = ES
   [sln] route vgain[3].X = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[4] cfg-in X=0.00124
     [comp] input.V[4] cfg-out O=0.00124
     [comp] input.V[5] cfg-in X=0.21
     [comp] input.V[5] cfg-out O=0.21
     [comp] input.I[2] cfg-in X=2.525
     [comp] input.I[2] cfg-out O=2.525
     [comp] input.I[3] cfg-in X=2.315
     [comp] input.I[3] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=P
     [comp] output.V[0] cfg-out O=P
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route vgain[5].X = E
     [sln] rm-route vgain[3].Z = ES
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[5].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[4].B = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[6].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[4].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0.00124
     [sln] rm-route vgain[3].X = 0.21
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0.21
     [sln] rm-route vdadd[6].D = 2.525
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.525
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = P
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[4].X = 0.00124
     [sln] route input.V[5].X = 0.21
     [sln] route input.I[2].X = 2.525
     [sln] route input.I[3].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I1
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [795] [CONN] vdadd[1].OUT => vgain[5].X (E)
     add-goal [796] [CONN] vdadd[6].OUT => vgain[3].Z (ES)
     add-goal [797] [CONN] vdadd[6].OUT => itov[0].K (ES)
     add-goal [798] [CONN] input.I[0].O => vgain[5].Z (3.154)
     add-goal [799] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
     add-goal [800] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
     add-goal [801] [CONN] input.V[2].O => vdadd[4].B (0)
     add-goal [802] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
     add-goal [803] [CONN] input.I[1].O => vdadd[4].D (0)
     add-goal [804] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
     add-goal [805] [CONN] input.V[5].O => vgain[3].X (0.21)
     add-goal [806] [CONN] input.I[2].O => vdadd[6].D (2.525)
     add-goal [807] [CONN] input.I[3].O => itov[0].X (2.315)
     add-goal [808] [CONN] vdadd[4].OUT => output.V[0].X (P)
     add-goal [809] [CONN] vdadd[1].OUT => output.V[1].X (E)
     add-goal [810] [CONN] vdadd[6].OUT => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[795] [CONN] vdadd[1].OUT => vgain[5].X (E)
[805] [CONN] input.V[5].O => vgain[3].X (0.21)
[807] [CONN] input.I[3].O => itov[0].X (2.315)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[800] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
[801] [CONN] input.V[2].O => vdadd[4].B (0)
[804] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[810] [CONN] vdadd[6].OUT => output.V[2].X (ES)
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[796] [CONN] vdadd[6].OUT => vgain[3].Z (ES)
[808] [CONN] vdadd[4].OUT => output.V[0].X (P)
[798] [CONN] input.I[0].O => vgain[5].Z (3.154)
[809] [CONN] vdadd[1].OUT => output.V[1].X (E)
[799] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
[797] [CONN] vdadd[6].OUT => itov[0].K (ES)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[802] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[803] [CONN] input.I[1].O => vdadd[4].D (0)
[806] [CONN] input.I[2].O => vdadd[6].D (2.525)

============
>> Current Goal: [806] [CONN] input.I[2].O => vdadd[6].D (2.525)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.Z
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (55) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=177

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[798] [CONN] input.I[0].O => vgain[5].Z (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [798] [CONN] input.I[0].O => vgain[5].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=178

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[812] [CONN] input.I[0].O => iadd[0].B (3.154)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [812] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=179

->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=180

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=181

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     add-goal [813] [CONN] input.I[4].O => iadd[0].C (0)
     add-goal [814] [CONN] input.I[5].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[811] [CONN] input.I[0].O => iadd[0].A (3.154)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [811] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=182

->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=183

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[4]
->input.I[3]
->input.I[5]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=184

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] route input.I[6].X = 0
     [sln] route input.I[7].X = 0
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     add-goal [815] [CONN] input.I[6].O => iadd[0].C (0)
     add-goal [816] [CONN] input.I[7].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[815] [CONN] input.I[6].O => iadd[0].C (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[816] [CONN] input.I[7].O => iadd[0].B (0)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [816] [CONN] input.I[7].O => iadd[0].B (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=185

->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[7]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[6]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=186

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[4]
->input.I[3]
->input.I[5]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=187

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] # partial ids = 3
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] itov[3] cfg-in Y=(0.21*ES)
   [comp] itov[3] cfg-in K=ES
   [comp] itov[3] cfg-in X=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route itov[3].K = ES
   [sln] route itov[3].X = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[5].X = E
[multi]    - connecting generates to routes.
[multi] > itov[3].K = ES
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[5].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].B = 0
[multi]    - making an input block.
[multi] > vdadd[6].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > itov[3].X = 0.21
[multi]    - making an input block.
[multi] > vdadd[6].D = 2.525
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[6].OUT = ES
[multi]    - making an output block.
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 16
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] itov[3] cfg-in Y=(0.21*ES)
   [comp] itov[3] cfg-in K=ES
   [comp] itov[3] cfg-in X=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route itov[3].K = ES
   [sln] route itov[3].X = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[4] cfg-in X=0.00124
     [comp] input.V[4] cfg-out O=0.00124
     [comp] input.I[2] cfg-in X=0.21
     [comp] input.I[2] cfg-out O=0.21
     [comp] input.I[3] cfg-in X=2.525
     [comp] input.I[3] cfg-out O=2.525
     [comp] input.I[4] cfg-in X=2.315
     [comp] input.I[4] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=P
     [comp] output.V[0] cfg-out O=P
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route vgain[5].X = E
     [sln] rm-route itov[3].K = ES
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[5].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[4].B = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[6].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[4].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0.00124
     [sln] rm-route itov[3].X = 0.21
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 0.21
     [sln] rm-route vdadd[6].D = 2.525
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.525
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = P
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[4].X = 0.00124
     [sln] route input.I[2].X = 0.21
     [sln] route input.I[3].X = 2.525
     [sln] route input.I[4].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I1
     [comp] make-comp input.V4
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [817] [CONN] vdadd[1].OUT => vgain[5].X (E)
     add-goal [818] [CONN] vdadd[6].OUT => itov[3].K (ES)
     add-goal [819] [CONN] vdadd[6].OUT => itov[0].K (ES)
     add-goal [820] [CONN] input.I[0].O => vgain[5].Z (3.154)
     add-goal [821] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
     add-goal [822] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
     add-goal [823] [CONN] input.V[2].O => vdadd[4].B (0)
     add-goal [824] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
     add-goal [825] [CONN] input.I[1].O => vdadd[4].D (0)
     add-goal [826] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
     add-goal [827] [CONN] input.I[2].O => itov[3].X (0.21)
     add-goal [828] [CONN] input.I[3].O => vdadd[6].D (2.525)
     add-goal [829] [CONN] input.I[4].O => itov[0].X (2.315)
     add-goal [830] [CONN] vdadd[4].OUT => output.V[0].X (P)
     add-goal [831] [CONN] vdadd[1].OUT => output.V[1].X (E)
     add-goal [832] [CONN] vdadd[6].OUT => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[821] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
[828] [CONN] input.I[3].O => vdadd[6].D (2.525)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[831] [CONN] vdadd[1].OUT => output.V[1].X (E)
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[826] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
[819] [CONN] vdadd[6].OUT => itov[0].K (ES)
[817] [CONN] vdadd[1].OUT => vgain[5].X (E)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[818] [CONN] vdadd[6].OUT => itov[3].K (ES)
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[832] [CONN] vdadd[6].OUT => output.V[2].X (ES)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[825] [CONN] input.I[1].O => vdadd[4].D (0)
[830] [CONN] vdadd[4].OUT => output.V[0].X (P)
[827] [CONN] input.I[2].O => itov[3].X (0.21)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[829] [CONN] input.I[4].O => itov[0].X (2.315)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[820] [CONN] input.I[0].O => vgain[5].Z (3.154)
[822] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
[823] [CONN] input.V[2].O => vdadd[4].B (0)
[824] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)

============
>> Current Goal: [824] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (55) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=188

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[820] [CONN] input.I[0].O => vgain[5].Z (3.154)

============
>> Current Goal: [820] [CONN] input.I[0].O => vgain[5].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=189

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[834] [CONN] input.I[0].O => iadd[0].B (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [834] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=190

->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=191

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=192

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     add-goal [835] [CONN] input.I[5].O => iadd[0].C (0)
     add-goal [836] [CONN] input.I[6].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[833] [CONN] input.I[0].O => iadd[0].A (3.154)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [833] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=193

->input.I[3]
->input.I[4]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=194

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->input.I[5]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[6]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=195

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] route input.I[7].X = 0
     [sln] route input.I[8].X = 0
     [comp] make-comp input.I7
     [comp] make-comp input.I8
     add-goal [837] [CONN] input.I[7].O => iadd[0].C (0)
     add-goal [838] [CONN] input.I[8].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[838] [CONN] input.I[8].O => iadd[0].B (0)
[837] [CONN] input.I[7].O => iadd[0].C (0)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [837] [CONN] input.I[7].O => iadd[0].C (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=196

->input.I[3]
->input.I[4]
->input.I[8]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[7]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=197

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->input.I[5]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[6]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=198

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] # partial ids = 3
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] itov[3] cfg-in Y=(0.21*ES)
   [comp] itov[3] cfg-in X=ES
   [comp] itov[3] cfg-in K=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route itov[3].X = ES
   [sln] route itov[3].K = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[5].X = E
[multi]    - connecting generates to routes.
[multi] > itov[3].X = ES
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[5].Z = 3.154
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].B = 0
[multi]    - making an input block.
[multi] > vdadd[6].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > itov[3].K = 0.21
[multi]    - making an input block.
[multi] > vdadd[6].D = 2.525
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[6].OUT = ES
[multi]    - making an output block.
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 16
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 117 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[7].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] itov[3] cfg-in Y=(0.21*ES)
   [comp] itov[3] cfg-in X=ES
   [comp] itov[3] cfg-in K=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(3.154*E)
   [comp] vgain[5] cfg-in Z=3.154
   [comp] vgain[5] cfg-in X=E
   [comp] vdadd[6] cfg-in OUT_0=0
   [comp] vdadd[6] cfg-in OUT=ES
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=2.525
   [comp] vdadd[6] cfg-in A=(3.154*E*S)
   [comp] itov[7] cfg-in Y=(3.154*E*S)
   [comp] itov[7] cfg-in X=S
   [comp] itov[7] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (0.21*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (3.154*E)
   [sln] conn vgain[5].P->itov[7].K
   [sln] generate vdadd[6].OUT = ES
   [sln] add-comp vdadd[6]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] add-comp itov[7]
   [sln] generate itov[7].Y = (3.154*E*S)
   [sln] conn itov[7].Y->vdadd[6].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route itov[3].X = ES
   [sln] route itov[3].K = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 3.154
   [sln] route vgain[5].X = E
   [sln] route vdadd[6].OUT_0 = 0
   [sln] route vdadd[6].D = 2.525
   [sln] route itov[7].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp itov7
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[6].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[7].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.317057704502
     [comp] input.V[0] cfg-out O=0.317057704502
     [comp] input.V[1] cfg-in X=0
     [comp] input.V[1] cfg-out O=0
     [comp] input.V[2] cfg-in X=0
     [comp] input.V[2] cfg-out O=0
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[4] cfg-in X=0.00124
     [comp] input.V[4] cfg-out O=0.00124
     [comp] input.V[5] cfg-in X=0.21
     [comp] input.V[5] cfg-out O=0.21
     [comp] input.I[2] cfg-in X=2.525
     [comp] input.I[2] cfg-out O=2.525
     [comp] input.I[3] cfg-in X=2.315
     [comp] input.I[3] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=P
     [comp] output.V[0] cfg-out O=P
     [comp] output.V[1] cfg-in X=E
     [comp] output.V[1] cfg-out O=E
     [comp] output.V[2] cfg-in X=ES
     [comp] output.V[2] cfg-out O=ES
     [sln] rm-route vgain[5].X = E
     [sln] rm-route itov[3].X = ES
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[5].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0
     [sln] rm-route vdadd[4].B = 0
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0
     [sln] rm-route vdadd[6].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[4].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0.00124
     [sln] rm-route itov[3].K = 0.21
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0.21
     [sln] rm-route vdadd[6].D = 2.525
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.525
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = P
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = E
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.317057704502
     [sln] route input.V[1].X = 0
     [sln] route input.V[2].X = 0
     [sln] route input.V[3].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[4].X = 0.00124
     [sln] route input.V[5].X = 0.21
     [sln] route input.I[2].X = 2.525
     [sln] route input.I[3].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.I1
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     add-goal [839] [CONN] vdadd[1].OUT => vgain[5].X (E)
     add-goal [840] [CONN] vdadd[6].OUT => itov[3].X (ES)
     add-goal [841] [CONN] vdadd[6].OUT => itov[0].K (ES)
     add-goal [842] [CONN] input.I[0].O => vgain[5].Z (3.154)
     add-goal [843] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
     add-goal [844] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
     add-goal [845] [CONN] input.V[2].O => vdadd[4].B (0)
     add-goal [846] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
     add-goal [847] [CONN] input.I[1].O => vdadd[4].D (0)
     add-goal [848] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
     add-goal [849] [CONN] input.V[5].O => itov[3].K (0.21)
     add-goal [850] [CONN] input.I[2].O => vdadd[6].D (2.525)
     add-goal [851] [CONN] input.I[3].O => itov[0].X (2.315)
     add-goal [852] [CONN] vdadd[4].OUT => output.V[0].X (P)
     add-goal [853] [CONN] vdadd[1].OUT => output.V[1].X (E)
     add-goal [854] [CONN] vdadd[6].OUT => output.V[2].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[844] [CONN] input.V[1].O => vdadd[4].OUT_0 (0)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[852] [CONN] vdadd[4].OUT => output.V[0].X (P)
[849] [CONN] input.V[5].O => itov[3].K (0.21)
[840] [CONN] vdadd[6].OUT => itov[3].X (ES)
[850] [CONN] input.I[2].O => vdadd[6].D (2.525)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[846] [CONN] input.V[3].O => vdadd[6].OUT_0 (0)
[853] [CONN] vdadd[1].OUT => output.V[1].X (E)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[839] [CONN] vdadd[1].OUT => vgain[5].X (E)
[841] [CONN] vdadd[6].OUT => itov[0].K (ES)
[847] [CONN] input.I[1].O => vdadd[4].D (0)
[854] [CONN] vdadd[6].OUT => output.V[2].X (ES)
[842] [CONN] input.I[0].O => vgain[5].Z (3.154)
[843] [CONN] input.V[0].O => vtoi[2].K (0.317057704502)
[845] [CONN] input.V[2].O => vdadd[4].B (0)
[851] [CONN] input.I[3].O => itov[0].X (2.315)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[848] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)

============
>> Current Goal: [848] [CONN] input.V[4].O => vdadd[1].OUT_0 (0.00124)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (55) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 12
[[Z3]] ---> Executing SMT Solver prob=199

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[842] [CONN] input.I[0].O => vgain[5].Z (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [842] [CONN] input.I[0].O => vgain[5].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=200

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[856] [CONN] input.I[0].O => iadd[0].B (3.154)
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [856] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=201

->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=202

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 13
[[Z3]] ---> Executing SMT Solver prob=203

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     add-goal [857] [CONN] input.I[4].O => iadd[0].C (0)
     add-goal [858] [CONN] input.I[5].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[855] [CONN] input.I[0].O => iadd[0].A (3.154)
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [855] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=204

->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (58) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=205

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[4]
->input.I[3]
->input.I[5]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=206

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > itov[7].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[0].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[1].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[6].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[2].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[3].Y = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (3.154*E)
[multi] > vgain[5].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[7].Y = (3.154*E*S)
[multi] > itov[7].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] route input.I[6].X = 0
     [sln] route input.I[7].X = 0
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     add-goal [859] [CONN] input.I[6].O => iadd[0].C (0)
     add-goal [860] [CONN] input.I[7].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[860] [CONN] input.I[7].O => iadd[0].B (0)
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[859] [CONN] input.I[6].O => iadd[0].C (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [859] [CONN] input.I[6].O => iadd[0].C (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=207

->input.I[3]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[7]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->input.I[6]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 11
[[Z3]] ---> Executing SMT Solver prob=208

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[4]
->input.I[3]
->input.I[5]
->input.V[4]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->itov[7]
->input.V[3]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (62) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=209

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] >>>SOLUTION IS UNFINISHED <<<
[multi] # Found 0, Required: 1
[multi] solving target: S
[multi] search tree is not exhausted. adding existing:S
[multi] finding new partial solution
[multi] made a partial tree with 4 goals
[multi] find a partial solution
[multi] == Finding Local Solution ==
[multi] == Current # Solutions: 0
[multi] == # New Solutions To Find: 1
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
vdadd.OUT -> true
mm.XY -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  2 <<<
[eqn] new: [0] <vdadd> output OUT.V
<analog-st> ((vdadd.V{A}:+(vdadd.BSW*vdadd.V{B}:))-(vdadd.DSW*vdadd.I{D}:*vdadd.V{OUT}:)) ic=OUT_0.V / std=none 0
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,12000.] {v}->[v]=@ {v}->*[v]=@


checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[0].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 11 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 13 ssteps
checking reachability of vdadd[1].OUT to output block.
number reachable output blocks 1/28
[eqn]     -> converted to 15 ssteps
[eqn] new: [0] <mm> output XY.V
<analog-st> ((mm.I{kf}:*mm.V{X}:*mm.V{Y}:)-(mm.I{kr}:*mm.V{XY}:)) ic=XY0.V / std=gauss ((0.001*mm.V{XY}:)+0.1)
<analog-st> [ddt v]=?? {ddt v}->[ddt v]=@
<analog-st> [v]=[0.,3200.] {v}->[v]=@ {v}->*[v]=@


[eqn] [FOUND-SOLS] ===> Found <21> solutions
[slvrsearch] > weight--: <mvar-goal>S
[eqn] -> [valid?] testing node 42
->vdadd[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (3) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 3
[[Z3]] ---> Executing SMT Solver prob=210

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[946] [EXPR]vdadd[1].A<V>=(2.315*ES)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[947] [EXPR]vdadd[1].D<I>=(3.154*E)

============
>> Current Goal: [947] [EXPR]vdadd[1].D<I>=(3.154*E)
switch.PROD -> true
ihill_stim.STIM -> true
ihill_rep.REP -> true
ihill_rep2.REP2 -> true
vtoi.Y -> true
igenebind.GE -> true
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  7 <<<
[eqn] new: [0] <switch> output PROD.I
<analog>:(switch.I{Vmax}:*(1/(((switch.I{SUB}:/switch.I{Kmod}:)+1)^(switch.V{n}:/500.)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn] new: [0] <ihill_stim> output STIM.I
<analog>:(ihill_stim.I{Vmax}:*(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)/(((ihill_stim.I{S}:/ihill_stim.I{Km}:)^ihill_stim.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,1000000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn] new: [0] <ihill_rep> output REP.I
<analog>:(ihill_rep.I{Vmax}:*((ihill_rep.I{Km}:^ihill_rep.V{n}:)/((ihill_rep.I{Km}:^ihill_rep.V{n}:)+(ihill_rep.I{S}:^ihill_rep.V{n}:)))) / std=none 0
<analog> [v]=[0.,80000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <ihill_rep2> output REP2.I
<analog>:(ihill_rep2.I{Vmax}:*(1/((ihill_rep2.I{S}:^ihill_rep2.V{n}:)+1))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] new: [0] <vtoi> output Y.I
<analog>:((1/vtoi.V{K}:)*vtoi.V{X}:) / std=gauss 1e-06
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <igenebind> output GE.I
<analog>:(igenebind.I{Vmax}:*(1/(1+(igenebind.I{K}:*igenebind.I{TF}:)))) / std=none 0
<analog> [v]=[0.,10.] {v}->[v]=@


[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn] [FOUND-SOLS] ===> Found <47> solutions
[slvrsearch] > weight--: (3.154*E)
[eqn] -> [valid?] testing node 110
->vdadd[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (7) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 4
[[Z3]] ---> Executing SMT Solver prob=211

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[946] [EXPR]vdadd[1].A<V>=(2.315*ES)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [946] [EXPR]vdadd[1].A<V>=(2.315*ES)
vgain.P -> true
vadd.OUT -> true
mm.X -> true
mm.Y -> true
itov.Y -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  5 <<<
[eqn] new: [0] <vgain> output P.V
<analog>:(vgain.V{X}:*vgain.I{Z}:) / std=none 0
<analog> [v]=[0.,5000.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] new: [0] <vadd> output OUT.V
<analog>:(((vadd.V{A}:+(vadd.BSW*vadd.V{B}:))-(vadd.CSW*vadd.V{C}:))*0.25) / std=gauss ((0.001*vadd.V{OUT}:)+0.1)
<analog> [v]={[-825.,1650.] [0.,1650.] [-825.,825.] [0.,825.] } {v}->[v]=@


[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn]     -> converted to 15 ssteps
[eqn]     -> converted to 13 ssteps
[eqn] new: [0] <mm> output Y.V
<analog>:(mm.V{Ytot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <mm> output X.V
<analog>:(mm.V{Xtot}:-mm.V{XY}:) / std=none 0
<analog> [v]=[0.,1600.] {v}->[v]=@


[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[WARN][unify_math_expr] cannot unify math expression with analog state variable
[eqn] new: [0] <itov> output Y.V
<analog>:(itov.V{K}:*itov.I{X}:) / std=gauss 0.1
<analog> [v]=[0.,3300.] {v}->[v]=@


[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn]     -> converted to 11 ssteps
[eqn] [FOUND-SOLS] ===> Found <38> solutions
[slvrsearch] > weight--: (2.315*ES)
[eqn] -> [valid?] testing node 213
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=212

->vdadd[1]
->itov[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=213

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 211
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=214

->vdadd[1]
->itov[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=215

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 209
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=216

->vdadd[1]
->itov[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=217

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 147
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=218

->vdadd[1]
->vgain[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=219

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 145
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=220

->vdadd[1]
->vgain[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=221

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 143
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=222

->vdadd[1]
->vgain[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 5
[[Z3]] ---> Executing SMT Solver prob=223

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 208
->itov[0]
->vdadd[1]
->vtoi[1]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (11) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 6
[[Z3]] ---> Executing SMT Solver prob=224

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] === returned from partial search ===
[multi] >>> Partial Results Found <<<
[multi] done with search
[multi] found some partial solutions. Will add partial solution node and global
[multi] == Adding Local Solution : 143 ==
[multi] == Adding Local Solution : 145 ==
[multi] == Adding Local Solution : 213 ==
[multi] == Adding Local Solution : 209 ==
[multi] == Adding Local Solution : 211 ==
[multi] == Adding Local Solution : 147 ==
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] found # steps: 42
[multi] # partial ids = 4
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [946] [EXPR]vdadd[6].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[6].D<I>=(3.154*E)
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(0.21*ES)
   [comp] vgain[3] cfg-in Z=ES
   [comp] vgain[3] cfg-in X=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(2.315*ES)
   [comp] vgain[5] cfg-in Z=2.315
   [comp] vgain[5] cfg-in X=ES
   [comp] vdadd[6] cfg-in OUT_0=0.00256
   [comp] vdadd[6] cfg-in OUT=S
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=(3.154*E)
   [comp] vdadd[6] cfg-in A=(2.315*ES)
   [comp] vtoi[7] cfg-in Y=(3.154*E)
   [comp] vtoi[7] cfg-in K=0.317057704502
   [comp] vtoi[7] cfg-in X=E
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (2.315*ES)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (2.315*ES)
   [sln] conn vgain[5].P->vdadd[6].A
   [sln] generate vdadd[6].OUT = S
   [sln] add-comp vdadd[6]
   [sln] generate vtoi[7].Y = (3.154*E)
   [sln] add-comp vtoi[7]
   [sln] generate vtoi[7].Y = (3.154*E)
   [sln] conn vtoi[7].Y->vdadd[6].D
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = ES
   [sln] route vgain[3].X = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 2.315
   [sln] route vgain[5].X = ES
   [sln] route vdadd[6].OUT_0 = 0.00256
   [sln] route vtoi[7].K = 0.317057704502
   [sln] route vtoi[7].X = E
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp vtoi7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[6].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[6].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[10].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[8].X = E
[multi]    - connecting generates to routes.
[multi] > vtoi[7].X = E
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[5].X = ES
[multi]    - connecting generates to routes.
[multi] > vgain[3].Z = ES
[multi]    - connecting generates to routes.
[multi] > vgain[8].Z = 3.154
[multi]    - making an input block.
[multi] > vdadd[6].OUT_0 = 0.00256
[multi]    - making an input block.
[multi] > vtoi[7].K = 0.317057704502
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].B = 0
[multi]    - making an input block.
[multi] > vdadd[9].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vgain[3].X = 0.21
[multi]    - making an input block.
[multi] > vdadd[9].D = 2.525
[multi]    - making an input block.
[multi] > vgain[5].Z = 2.315
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[6].OUT = S
[multi]    - making an output block.
[multi] > vdadd[4].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[9].OUT = ES
[multi]    - making an output block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (2.315*ES)
[multi] > vgain[5].P = (2.315*ES)
[multi] > vtoi[7].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 24
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 159 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [946] [EXPR]vdadd[6].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[6].D<I>=(3.154*E)
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(0.21*ES)
   [comp] vgain[3] cfg-in Z=ES
   [comp] vgain[3] cfg-in X=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] vgain[5] cfg-in P=(2.315*ES)
   [comp] vgain[5] cfg-in Z=2.315
   [comp] vgain[5] cfg-in X=ES
   [comp] vdadd[6] cfg-in OUT_0=0.00256
   [comp] vdadd[6] cfg-in OUT=S
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=(3.154*E)
   [comp] vdadd[6] cfg-in A=(2.315*ES)
   [comp] vtoi[7] cfg-in Y=(3.154*E)
   [comp] vtoi[7] cfg-in K=0.317057704502
   [comp] vtoi[7] cfg-in X=E
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate vgain[5].P = (2.315*ES)
   [sln] add-comp vgain[5]
   [sln] generate vgain[5].P = (2.315*ES)
   [sln] conn vgain[5].P->vdadd[6].A
   [sln] generate vdadd[6].OUT = S
   [sln] add-comp vdadd[6]
   [sln] generate vtoi[7].Y = (3.154*E)
   [sln] add-comp vtoi[7]
   [sln] generate vtoi[7].Y = (3.154*E)
   [sln] conn vtoi[7].Y->vdadd[6].D
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = ES
   [sln] route vgain[3].X = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route vgain[5].Z = 2.315
   [sln] route vgain[5].X = ES
   [sln] route vdadd[6].OUT_0 = 0.00256
   [sln] route vtoi[7].K = 0.317057704502
   [sln] route vtoi[7].X = E
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vgain5
   [comp] make-comp vdadd6
   [comp] make-comp vtoi7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[6].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[6].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.00256
     [comp] input.V[0] cfg-out O=0.00256
     [comp] input.V[1] cfg-in X=0.317057704502
     [comp] input.V[1] cfg-out O=0.317057704502
     [comp] input.V[2] cfg-in X=0.317057704502
     [comp] input.V[2] cfg-out O=0.317057704502
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.V[4] cfg-in X=0
     [comp] input.V[4] cfg-out O=0
     [comp] input.V[5] cfg-in X=0
     [comp] input.V[5] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[6] cfg-in X=0.00124
     [comp] input.V[6] cfg-out O=0.00124
     [comp] input.V[7] cfg-in X=0.21
     [comp] input.V[7] cfg-out O=0.21
     [comp] input.I[2] cfg-in X=2.525
     [comp] input.I[2] cfg-out O=2.525
     [comp] input.I[3] cfg-in X=2.315
     [comp] input.I[3] cfg-out O=2.315
     [comp] input.I[4] cfg-in X=2.315
     [comp] input.I[4] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route itov[10].X = S
     [sln] rm-route vtoi[2].X = S
     [sln] rm-route vgain[8].X = E
     [sln] rm-route vtoi[7].X = E
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[5].X = ES
     [sln] rm-route vgain[3].Z = ES
     [sln] rm-route vgain[8].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vdadd[6].OUT_0 = 0.00256
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.00256
     [sln] rm-route vtoi[7].K = 0.317057704502
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0.317057704502
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[4].B = 0
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0
     [sln] rm-route vdadd[9].OUT_0 = 0
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0
     [sln] rm-route vdadd[4].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 0.00124
     [sln] rm-route vgain[3].X = 0.21
     [sln] add-comp input.V[7]
     [sln] generate input.V[7].O = 0.21
     [sln] rm-route vdadd[9].D = 2.525
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.525
     [sln] rm-route vgain[5].Z = 2.315
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.315
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.00256
     [sln] route input.V[1].X = 0.317057704502
     [sln] route input.V[2].X = 0.317057704502
     [sln] route input.V[3].X = 0
     [sln] route input.V[4].X = 0
     [sln] route input.V[5].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[6].X = 0.00124
     [sln] route input.V[7].X = 0.21
     [sln] route input.I[2].X = 2.525
     [sln] route input.I[3].X = 2.315
     [sln] route input.I[4].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I1
     [comp] make-comp input.V6
     [comp] make-comp input.V7
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [1149] [CONN] vdadd[6].OUT => itov[10].X (S)
     add-goal [1150] [CONN] vdadd[6].OUT => vtoi[2].X (S)
     add-goal [1151] [CONN] vdadd[1].OUT => vgain[8].X (E)
     add-goal [1152] [CONN] vdadd[1].OUT => vtoi[7].X (E)
     add-goal [1153] [CONN] vdadd[9].OUT => itov[0].K (ES)
     add-goal [1154] [CONN] vdadd[9].OUT => vgain[5].X (ES)
     add-goal [1155] [CONN] vdadd[9].OUT => vgain[3].Z (ES)
     add-goal [1156] [CONN] input.I[0].O => vgain[8].Z (3.154)
     add-goal [1157] [CONN] input.V[0].O => vdadd[6].OUT_0 (0.00256)
     add-goal [1158] [CONN] input.V[1].O => vtoi[7].K (0.317057704502)
     add-goal [1159] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
     add-goal [1160] [CONN] input.V[3].O => vdadd[4].OUT_0 (0)
     add-goal [1161] [CONN] input.V[4].O => vdadd[4].B (0)
     add-goal [1162] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
     add-goal [1163] [CONN] input.I[1].O => vdadd[4].D (0)
     add-goal [1164] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
     add-goal [1165] [CONN] input.V[7].O => vgain[3].X (0.21)
     add-goal [1166] [CONN] input.I[2].O => vdadd[9].D (2.525)
     add-goal [1167] [CONN] input.I[3].O => vgain[5].Z (2.315)
     add-goal [1168] [CONN] input.I[4].O => itov[0].X (2.315)
     add-goal [1169] [CONN] vdadd[6].OUT => output.V[0].X (S)
     add-goal [1170] [CONN] vdadd[4].OUT => output.V[1].X (P)
     add-goal [1171] [CONN] vdadd[1].OUT => output.V[2].X (E)
     add-goal [1172] [CONN] vdadd[9].OUT => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1167] [CONN] input.I[3].O => vgain[5].Z (2.315)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1157] [CONN] input.V[0].O => vdadd[6].OUT_0 (0.00256)
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1166] [CONN] input.I[2].O => vdadd[9].D (2.525)
[1164] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
[1165] [CONN] input.V[7].O => vgain[3].X (0.21)
[1150] [CONN] vdadd[6].OUT => vtoi[2].X (S)
[1152] [CONN] vdadd[1].OUT => vtoi[7].X (E)
[1168] [CONN] input.I[4].O => itov[0].X (2.315)
[1163] [CONN] input.I[1].O => vdadd[4].D (0)
[1170] [CONN] vdadd[4].OUT => output.V[1].X (P)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1161] [CONN] input.V[4].O => vdadd[4].B (0)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1154] [CONN] vdadd[9].OUT => vgain[5].X (ES)
[1162] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1151] [CONN] vdadd[1].OUT => vgain[8].X (E)
[1153] [CONN] vdadd[9].OUT => itov[0].K (ES)
[1172] [CONN] vdadd[9].OUT => output.V[3].X (ES)
[1159] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
[1149] [CONN] vdadd[6].OUT => itov[10].X (S)
[1155] [CONN] vdadd[9].OUT => vgain[3].Z (ES)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1156] [CONN] input.I[0].O => vgain[8].Z (3.154)
[1169] [CONN] vdadd[6].OUT => output.V[0].X (S)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1171] [CONN] vdadd[1].OUT => output.V[2].X (E)
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1158] [CONN] input.V[1].O => vtoi[7].K (0.317057704502)
[1160] [CONN] input.V[3].O => vdadd[4].OUT_0 (0)

============
>> Current Goal: [1160] [CONN] input.V[3].O => vdadd[4].OUT_0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.Z
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (74) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=225

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[1167] [CONN] input.I[3].O => vgain[5].Z (2.315)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1156] [CONN] input.I[0].O => vgain[8].Z (3.154)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1156] [CONN] input.I[0].O => vgain[8].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 18
[[Z3]] ---> Executing SMT Solver prob=226

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[1167] [CONN] input.I[3].O => vgain[5].Z (2.315)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1174] [CONN] input.I[0].O => iadd[0].B (3.154)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1174] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=227

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[1167] [CONN] input.I[3].O => vgain[5].Z (2.315)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1167] [CONN] input.I[3].O => vgain[5].Z (2.315)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 8
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->iadd[1]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=228

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1176] [CONN] input.I[3].O => iadd[1].B (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1176] [CONN] input.I[3].O => iadd[1].B (2.315)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 9
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=229

->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->iadd[1]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=230

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->iadd[1]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=231

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[1].C = 0
[multi]    - making an input block.
[multi] > iadd[1].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[6].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (2.315*ES)
[multi] > vgain[5].P = (2.315*ES)
[multi] > iadd[1].OUT = 2.315
[multi] > vtoi[7].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [sln] rm-route iadd[1].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[1].A = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [sln] route input.I[7].X = 0
     [sln] route input.I[8].X = 0
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     [comp] make-comp input.I8
     add-goal [1177] [CONN] input.I[5].O => iadd[1].C (0)
     add-goal [1178] [CONN] input.I[6].O => iadd[1].A (0)
     add-goal [1179] [CONN] input.I[7].O => iadd[0].C (0)
     add-goal [1180] [CONN] input.I[8].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1167] [CONN] input.I[3].O => vgain[5].Z (2.315)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1173] [CONN] input.I[0].O => iadd[0].A (3.154)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1173] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 11
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=232

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[1167] [CONN] input.I[3].O => vgain[5].Z (2.315)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1167] [CONN] input.I[3].O => vgain[5].Z (2.315)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 13
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=233

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1182] [CONN] input.I[3].O => iadd[2].B (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1182] [CONN] input.I[3].O => iadd[2].B (2.315)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 14
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=234

->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=235

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=236

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[2].C = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[6].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[5].P = (2.315*ES)
[multi] > vgain[5].P = (2.315*ES)
[multi] > iadd[2].OUT = 2.315
[multi] > vtoi[7].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[9] cfg-in X=0
     [comp] input.I[9] cfg-out O=0
     [comp] input.I[10] cfg-in X=0
     [comp] input.I[10] cfg-out O=0
     [comp] input.I[11] cfg-in X=0
     [comp] input.I[11] cfg-out O=0
     [comp] input.I[12] cfg-in X=0
     [comp] input.I[12] cfg-out O=0
     [sln] rm-route iadd[2].C = 0
     [sln] add-comp input.I[9]
     [sln] generate input.I[9].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[10]
     [sln] generate input.I[10].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[11]
     [sln] generate input.I[11].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[12]
     [sln] generate input.I[12].O = 0
     [sln] route input.I[9].X = 0
     [sln] route input.I[10].X = 0
     [sln] route input.I[11].X = 0
     [sln] route input.I[12].X = 0
     [comp] make-comp input.I9
     [comp] make-comp input.I10
     [comp] make-comp input.I11
     [comp] make-comp input.I12
     add-goal [1183] [CONN] input.I[9].O => iadd[2].C (0)
     add-goal [1184] [CONN] input.I[10].O => iadd[2].A (0)
     add-goal [1185] [CONN] input.I[11].O => iadd[0].C (0)
     add-goal [1186] [CONN] input.I[12].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1183] [CONN] input.I[9].O => iadd[2].C (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1184] [CONN] input.I[10].O => iadd[2].A (0)
[1186] [CONN] input.I[12].O => iadd[0].B (0)
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1185] [CONN] input.I[11].O => iadd[0].C (0)

============
>> Current Goal: [1185] [CONN] input.I[11].O => iadd[0].C (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 16
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=237

->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.I[12]
->input.I[10]
->input.V[1]
->input.I[9]
->input.V[5]
->output.V[1]
->input.V[3]
->input.I[11]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (88) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=238

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=239

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: E~209ES~153P~27S~143 :: 16
[multi] Number of Solutions: 0
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: E~209ES~153P~27S~143 :: 16
[[Z3]] ---> Executing SMT Solver prob=240

[rslvr] z32cstr.wire: vgain[5].P
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: vtoi[7].X
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vtoi[7].K
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: vgain[5].X
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: vdadd[6].OUT_0
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: vdadd[6].D
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: vtoi[7].Y
[rslvr] z32cstr.wire: input.I[9].O
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: vgain[3].Z
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: input.I[12].O
[rslvr] z32cstr.wire: input.I[11].O
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: vdadd[4].B
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: vdadd[6].A
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: input.I[10].O
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: vdadd[6].OUT
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: vgain[5].Z
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vgain[3].X
[rslvr] z32cstr.wire: vgain[3].P
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: iadd[2].OUT
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_0_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_0_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_0_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_0_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=241

[rslvr] z32cstr.wire: vgain[5].P
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: vtoi[7].X
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vtoi[7].K
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: vgain[5].X
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: vdadd[6].OUT_0
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: vdadd[6].D
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: vtoi[7].Y
[rslvr] z32cstr.wire: input.I[9].O
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: vgain[3].Z
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: input.I[12].O
[rslvr] z32cstr.wire: input.I[11].O
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: vdadd[4].B
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: vdadd[6].A
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: input.I[10].O
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: vdadd[6].OUT
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: vgain[5].Z
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vgain[3].X
[rslvr] z32cstr.wire: vgain[3].P
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: iadd[2].OUT
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.I[12]
->input.I[10]
->input.V[1]
->input.I[9]
->input.V[5]
->output.V[1]
->input.V[3]
->input.I[11]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[5]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (88) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=242

[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_0_sdeCircMap.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_0_odeCircMap.m
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] # partial ids = 4
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   remove-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(2.315*ES)
   [comp] vgain[3] cfg-in X=ES
   [comp] vgain[3] cfg-in Z=2.315
   [comp] vdadd[4] cfg-in OUT_0=0.00256
   [comp] vdadd[4] cfg-in OUT=S
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=(3.154*E)
   [comp] vdadd[4] cfg-in A=(2.315*ES)
   [comp] vtoi[5] cfg-in Y=(3.154*E)
   [comp] vtoi[5] cfg-in K=0.317057704502
   [comp] vtoi[5] cfg-in X=E
   [comp] vgain[6] cfg-in P=(0.21*ES)
   [comp] vgain[6] cfg-in Z=ES
   [comp] vgain[6] cfg-in X=0.21
   [comp] vdadd[7] cfg-in OUT_0=0
   [comp] vdadd[7] cfg-in OUT=P
   [comp] vdadd[7] cfg-param BSW=1
   [comp] vdadd[7] cfg-param DSW=1
   [comp] vdadd[7] cfg-in B=0
   [comp] vdadd[7] cfg-in A=(0.21*ES)
   [comp] vdadd[7] cfg-in D=0
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (2.315*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (2.315*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = S
   [sln] add-comp vdadd[4]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] add-comp vtoi[5]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] conn vtoi[5].Y->vdadd[4].D
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] add-comp vgain[6]
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] conn vgain[6].P->vdadd[7].A
   [sln] generate vdadd[7].OUT = P
   [sln] add-comp vdadd[7]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].X = ES
   [sln] route vgain[3].Z = 2.315
   [sln] route vdadd[4].OUT_0 = 0.00256
   [sln] route vtoi[5].K = 0.317057704502
   [sln] route vtoi[5].X = E
   [sln] route vgain[6].Z = ES
   [sln] route vgain[6].X = 0.21
   [sln] route vdadd[7].OUT_0 = 0
   [sln] route vdadd[7].B = 0
   [sln] route vdadd[7].D = 0
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vtoi5
   [comp] make-comp vgain6
   [comp] make-comp vdadd7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[10].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[8].X = E
[multi]    - connecting generates to routes.
[multi] > vtoi[5].X = E
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[6].Z = ES
[multi]    - connecting generates to routes.
[multi] > vgain[3].X = ES
[multi]    - connecting generates to routes.
[multi] > vgain[8].Z = 3.154
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0.00256
[multi]    - making an input block.
[multi] > vtoi[5].K = 0.317057704502
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[7].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[7].B = 0
[multi]    - making an input block.
[multi] > vdadd[9].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[7].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vgain[6].X = 0.21
[multi]    - making an input block.
[multi] > vdadd[9].D = 2.525
[multi]    - making an input block.
[multi] > vgain[3].Z = 2.315
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]    - making an output block.
[multi] > vdadd[7].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[9].OUT = ES
[multi]    - making an output block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 24
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 159 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   remove-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(2.315*ES)
   [comp] vgain[3] cfg-in X=ES
   [comp] vgain[3] cfg-in Z=2.315
   [comp] vdadd[4] cfg-in OUT_0=0.00256
   [comp] vdadd[4] cfg-in OUT=S
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=(3.154*E)
   [comp] vdadd[4] cfg-in A=(2.315*ES)
   [comp] vtoi[5] cfg-in Y=(3.154*E)
   [comp] vtoi[5] cfg-in K=0.317057704502
   [comp] vtoi[5] cfg-in X=E
   [comp] vgain[6] cfg-in P=(0.21*ES)
   [comp] vgain[6] cfg-in Z=ES
   [comp] vgain[6] cfg-in X=0.21
   [comp] vdadd[7] cfg-in OUT_0=0
   [comp] vdadd[7] cfg-in OUT=P
   [comp] vdadd[7] cfg-param BSW=1
   [comp] vdadd[7] cfg-param DSW=1
   [comp] vdadd[7] cfg-in B=0
   [comp] vdadd[7] cfg-in A=(0.21*ES)
   [comp] vdadd[7] cfg-in D=0
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (2.315*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (2.315*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = S
   [sln] add-comp vdadd[4]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] add-comp vtoi[5]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] conn vtoi[5].Y->vdadd[4].D
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] add-comp vgain[6]
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] conn vgain[6].P->vdadd[7].A
   [sln] generate vdadd[7].OUT = P
   [sln] add-comp vdadd[7]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].X = ES
   [sln] route vgain[3].Z = 2.315
   [sln] route vdadd[4].OUT_0 = 0.00256
   [sln] route vtoi[5].K = 0.317057704502
   [sln] route vtoi[5].X = E
   [sln] route vgain[6].Z = ES
   [sln] route vgain[6].X = 0.21
   [sln] route vdadd[7].OUT_0 = 0
   [sln] route vdadd[7].B = 0
   [sln] route vdadd[7].D = 0
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vtoi5
   [comp] make-comp vgain6
   [comp] make-comp vdadd7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.00256
     [comp] input.V[0] cfg-out O=0.00256
     [comp] input.V[1] cfg-in X=0.317057704502
     [comp] input.V[1] cfg-out O=0.317057704502
     [comp] input.V[2] cfg-in X=0.317057704502
     [comp] input.V[2] cfg-out O=0.317057704502
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.V[4] cfg-in X=0
     [comp] input.V[4] cfg-out O=0
     [comp] input.V[5] cfg-in X=0
     [comp] input.V[5] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[6] cfg-in X=0.00124
     [comp] input.V[6] cfg-out O=0.00124
     [comp] input.V[7] cfg-in X=0.21
     [comp] input.V[7] cfg-out O=0.21
     [comp] input.I[2] cfg-in X=2.525
     [comp] input.I[2] cfg-out O=2.525
     [comp] input.I[3] cfg-in X=2.315
     [comp] input.I[3] cfg-out O=2.315
     [comp] input.I[4] cfg-in X=2.315
     [comp] input.I[4] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route itov[10].X = S
     [sln] rm-route vtoi[2].X = S
     [sln] rm-route vgain[8].X = E
     [sln] rm-route vtoi[5].X = E
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[6].Z = ES
     [sln] rm-route vgain[3].X = ES
     [sln] rm-route vgain[8].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vdadd[4].OUT_0 = 0.00256
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.00256
     [sln] rm-route vtoi[5].K = 0.317057704502
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0.317057704502
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.317057704502
     [sln] rm-route vdadd[7].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[7].B = 0
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0
     [sln] rm-route vdadd[9].OUT_0 = 0
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0
     [sln] rm-route vdadd[7].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 0.00124
     [sln] rm-route vgain[6].X = 0.21
     [sln] add-comp input.V[7]
     [sln] generate input.V[7].O = 0.21
     [sln] rm-route vdadd[9].D = 2.525
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.525
     [sln] rm-route vgain[3].Z = 2.315
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.315
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.00256
     [sln] route input.V[1].X = 0.317057704502
     [sln] route input.V[2].X = 0.317057704502
     [sln] route input.V[3].X = 0
     [sln] route input.V[4].X = 0
     [sln] route input.V[5].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[6].X = 0.00124
     [sln] route input.V[7].X = 0.21
     [sln] route input.I[2].X = 2.525
     [sln] route input.I[3].X = 2.315
     [sln] route input.I[4].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I1
     [comp] make-comp input.V6
     [comp] make-comp input.V7
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [1187] [CONN] vdadd[4].OUT => itov[10].X (S)
     add-goal [1188] [CONN] vdadd[4].OUT => vtoi[2].X (S)
     add-goal [1189] [CONN] vdadd[1].OUT => vgain[8].X (E)
     add-goal [1190] [CONN] vdadd[1].OUT => vtoi[5].X (E)
     add-goal [1191] [CONN] vdadd[9].OUT => itov[0].K (ES)
     add-goal [1192] [CONN] vdadd[9].OUT => vgain[6].Z (ES)
     add-goal [1193] [CONN] vdadd[9].OUT => vgain[3].X (ES)
     add-goal [1194] [CONN] input.I[0].O => vgain[8].Z (3.154)
     add-goal [1195] [CONN] input.V[0].O => vdadd[4].OUT_0 (0.00256)
     add-goal [1196] [CONN] input.V[1].O => vtoi[5].K (0.317057704502)
     add-goal [1197] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
     add-goal [1198] [CONN] input.V[3].O => vdadd[7].OUT_0 (0)
     add-goal [1199] [CONN] input.V[4].O => vdadd[7].B (0)
     add-goal [1200] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
     add-goal [1201] [CONN] input.I[1].O => vdadd[7].D (0)
     add-goal [1202] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
     add-goal [1203] [CONN] input.V[7].O => vgain[6].X (0.21)
     add-goal [1204] [CONN] input.I[2].O => vdadd[9].D (2.525)
     add-goal [1205] [CONN] input.I[3].O => vgain[3].Z (2.315)
     add-goal [1206] [CONN] input.I[4].O => itov[0].X (2.315)
     add-goal [1207] [CONN] vdadd[4].OUT => output.V[0].X (S)
     add-goal [1208] [CONN] vdadd[7].OUT => output.V[1].X (P)
     add-goal [1209] [CONN] vdadd[1].OUT => output.V[2].X (E)
     add-goal [1210] [CONN] vdadd[9].OUT => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1187] [CONN] vdadd[4].OUT => itov[10].X (S)
[1196] [CONN] input.V[1].O => vtoi[5].K (0.317057704502)
[1209] [CONN] vdadd[1].OUT => output.V[2].X (E)
[1198] [CONN] input.V[3].O => vdadd[7].OUT_0 (0)
[1204] [CONN] input.I[2].O => vdadd[9].D (2.525)
[1206] [CONN] input.I[4].O => itov[0].X (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1199] [CONN] input.V[4].O => vdadd[7].B (0)
[1202] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1194] [CONN] input.I[0].O => vgain[8].Z (3.154)
[1192] [CONN] vdadd[9].OUT => vgain[6].Z (ES)
[1201] [CONN] input.I[1].O => vdadd[7].D (0)
[1210] [CONN] vdadd[9].OUT => output.V[3].X (ES)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1197] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
[1200] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
[1193] [CONN] vdadd[9].OUT => vgain[3].X (ES)
[1208] [CONN] vdadd[7].OUT => output.V[1].X (P)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1190] [CONN] vdadd[1].OUT => vtoi[5].X (E)
[1203] [CONN] input.V[7].O => vgain[6].X (0.21)
[1188] [CONN] vdadd[4].OUT => vtoi[2].X (S)
[1189] [CONN] vdadd[1].OUT => vgain[8].X (E)
[1205] [CONN] input.I[3].O => vgain[3].Z (2.315)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1195] [CONN] input.V[0].O => vdadd[4].OUT_0 (0.00256)
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1191] [CONN] vdadd[9].OUT => itov[0].K (ES)
[1207] [CONN] vdadd[4].OUT => output.V[0].X (S)

============
>> Current Goal: [1207] [CONN] vdadd[4].OUT => output.V[0].X (S)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.Z
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (74) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=243

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1194] [CONN] input.I[0].O => vgain[8].Z (3.154)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1205] [CONN] input.I[3].O => vgain[3].Z (2.315)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1205] [CONN] input.I[3].O => vgain[3].Z (2.315)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 18
[[Z3]] ---> Executing SMT Solver prob=244

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1194] [CONN] input.I[0].O => vgain[8].Z (3.154)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1212] [CONN] input.I[3].O => iadd[0].B (2.315)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1212] [CONN] input.I[3].O => iadd[0].B (2.315)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=245

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1194] [CONN] input.I[0].O => vgain[8].Z (3.154)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1194] [CONN] input.I[0].O => vgain[8].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 8
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=246

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1214] [CONN] input.I[0].O => iadd[1].B (3.154)
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1214] [CONN] input.I[0].O => iadd[1].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 9
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=247

->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=248

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->iadd[1]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=249

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[1].C = 0
[multi]    - making an input block.
[multi] > iadd[1].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[7].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > iadd[0].OUT = 2.315
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[1].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [sln] rm-route iadd[1].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[1].A = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [sln] route input.I[7].X = 0
     [sln] route input.I[8].X = 0
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     [comp] make-comp input.I8
     add-goal [1215] [CONN] input.I[5].O => iadd[1].C (0)
     add-goal [1216] [CONN] input.I[6].O => iadd[1].A (0)
     add-goal [1217] [CONN] input.I[7].O => iadd[0].C (0)
     add-goal [1218] [CONN] input.I[8].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1194] [CONN] input.I[0].O => vgain[8].Z (3.154)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1211] [CONN] input.I[3].O => iadd[0].A (2.315)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1211] [CONN] input.I[3].O => iadd[0].A (2.315)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 11
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=250

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1194] [CONN] input.I[0].O => vgain[8].Z (3.154)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1194] [CONN] input.I[0].O => vgain[8].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 13
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=251

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1220] [CONN] input.I[0].O => iadd[2].B (3.154)
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1220] [CONN] input.I[0].O => iadd[2].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 14
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=252

->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=253

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=254

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[2].C = 0
[multi]    - making an input block.
[multi] > iadd[2].A = 0
[multi]    - making an input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[7].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > iadd[0].OUT = 2.315
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[2].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 4
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[9] cfg-in X=0
     [comp] input.I[9] cfg-out O=0
     [comp] input.I[10] cfg-in X=0
     [comp] input.I[10] cfg-out O=0
     [comp] input.I[11] cfg-in X=0
     [comp] input.I[11] cfg-out O=0
     [comp] input.I[12] cfg-in X=0
     [comp] input.I[12] cfg-out O=0
     [sln] rm-route iadd[2].C = 0
     [sln] add-comp input.I[9]
     [sln] generate input.I[9].O = 0
     [sln] rm-route iadd[2].A = 0
     [sln] add-comp input.I[10]
     [sln] generate input.I[10].O = 0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[11]
     [sln] generate input.I[11].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[12]
     [sln] generate input.I[12].O = 0
     [sln] route input.I[9].X = 0
     [sln] route input.I[10].X = 0
     [sln] route input.I[11].X = 0
     [sln] route input.I[12].X = 0
     [comp] make-comp input.I9
     [comp] make-comp input.I10
     [comp] make-comp input.I11
     [comp] make-comp input.I12
     add-goal [1221] [CONN] input.I[9].O => iadd[2].C (0)
     add-goal [1222] [CONN] input.I[10].O => iadd[2].A (0)
     add-goal [1223] [CONN] input.I[11].O => iadd[0].C (0)
     add-goal [1224] [CONN] input.I[12].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1223] [CONN] input.I[11].O => iadd[0].C (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1221] [CONN] input.I[9].O => iadd[2].C (0)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1224] [CONN] input.I[12].O => iadd[0].B (0)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1222] [CONN] input.I[10].O => iadd[2].A (0)

============
>> Current Goal: [1222] [CONN] input.I[10].O => iadd[2].A (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 16
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=255

->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.I[12]
->input.I[10]
->input.V[1]
->input.I[9]
->input.V[5]
->output.V[1]
->input.V[3]
->input.I[11]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (88) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=256

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 12
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (80) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 17
[[Z3]] ---> Executing SMT Solver prob=257

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: E~209ES~153P~27S~145 :: 16
[multi] Number of Solutions: 1
[multi] => Global Solution: E~209ES~153P~27S~143 :: 16
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: E~209ES~153P~27S~145 :: 16
[[Z3]] ---> Executing SMT Solver prob=258

[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vtoi[5].K
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: input.I[9].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: vdadd[7].A
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: vdadd[7].OUT_0
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: vdadd[7].OUT
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: vdadd[7].D
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: input.I[10].O
[rslvr] z32cstr.wire: input.I[11].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: vgain[3].Z
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: vgain[3].X
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: input.I[12].O
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: vdadd[7].B
[rslvr] z32cstr.wire: vtoi[5].X
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: vgain[3].P
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: vtoi[5].Y
[rslvr] z32cstr.wire: iadd[2].OUT
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_1_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_1_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_1_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_1_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=259

[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vtoi[5].K
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: input.I[9].O
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: vdadd[7].A
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: vdadd[7].OUT_0
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: vdadd[7].OUT
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: vdadd[7].D
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: iadd[2].B
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: input.I[10].O
[rslvr] z32cstr.wire: input.I[11].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: vgain[3].Z
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: vgain[3].X
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: input.I[12].O
[rslvr] z32cstr.wire: iadd[2].C
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: vdadd[7].B
[rslvr] z32cstr.wire: vtoi[5].X
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: vgain[3].P
[rslvr] z32cstr.wire: iadd[2].A
[rslvr] z32cstr.wire: vtoi[5].Y
[rslvr] z32cstr.wire: iadd[2].OUT
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.I[12]
->input.I[10]
->input.V[1]
->input.I[9]
->input.V[5]
->output.V[1]
->input.V[3]
->input.I[11]
->input.V[7]
->iadd[2]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (88) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=260

[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_1_sdeCircMap.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_1_odeCircMap.m
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] # partial ids = 4
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   remove-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] itov[3] cfg-in Y=(2.315*ES)
   [comp] itov[3] cfg-in X=ES
   [comp] itov[3] cfg-in K=2.315
   [comp] vdadd[4] cfg-in OUT_0=0.00256
   [comp] vdadd[4] cfg-in OUT=S
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=(3.154*E)
   [comp] vdadd[4] cfg-in A=(2.315*ES)
   [comp] vtoi[5] cfg-in Y=(3.154*E)
   [comp] vtoi[5] cfg-in K=0.317057704502
   [comp] vtoi[5] cfg-in X=E
   [comp] vgain[6] cfg-in P=(0.21*ES)
   [comp] vgain[6] cfg-in Z=ES
   [comp] vgain[6] cfg-in X=0.21
   [comp] vdadd[7] cfg-in OUT_0=0
   [comp] vdadd[7] cfg-in OUT=P
   [comp] vdadd[7] cfg-param BSW=1
   [comp] vdadd[7] cfg-param DSW=1
   [comp] vdadd[7] cfg-in B=0
   [comp] vdadd[7] cfg-in A=(0.21*ES)
   [comp] vdadd[7] cfg-in D=0
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = S
   [sln] add-comp vdadd[4]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] add-comp vtoi[5]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] conn vtoi[5].Y->vdadd[4].D
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] add-comp vgain[6]
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] conn vgain[6].P->vdadd[7].A
   [sln] generate vdadd[7].OUT = P
   [sln] add-comp vdadd[7]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route itov[3].X = ES
   [sln] route itov[3].K = 2.315
   [sln] route vdadd[4].OUT_0 = 0.00256
   [sln] route vtoi[5].K = 0.317057704502
   [sln] route vtoi[5].X = E
   [sln] route vgain[6].Z = ES
   [sln] route vgain[6].X = 0.21
   [sln] route vdadd[7].OUT_0 = 0
   [sln] route vdadd[7].B = 0
   [sln] route vdadd[7].D = 0
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vtoi5
   [comp] make-comp vgain6
   [comp] make-comp vdadd7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[10].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[8].X = E
[multi]    - connecting generates to routes.
[multi] > vtoi[5].X = E
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[6].Z = ES
[multi]    - connecting generates to routes.
[multi] > itov[3].X = ES
[multi]    - connecting generates to routes.
[multi] > vgain[8].Z = 3.154
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0.00256
[multi]    - making an input block.
[multi] > vtoi[5].K = 0.317057704502
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[7].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[7].B = 0
[multi]    - making an input block.
[multi] > vdadd[9].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[7].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vgain[6].X = 0.21
[multi]    - making an input block.
[multi] > vdadd[9].D = 2.525
[multi]    - making an input block.
[multi] > itov[3].K = 2.315
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]    - making an output block.
[multi] > vdadd[7].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[9].OUT = ES
[multi]    - making an output block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 24
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 159 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   remove-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] itov[3] cfg-in Y=(2.315*ES)
   [comp] itov[3] cfg-in X=ES
   [comp] itov[3] cfg-in K=2.315
   [comp] vdadd[4] cfg-in OUT_0=0.00256
   [comp] vdadd[4] cfg-in OUT=S
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=(3.154*E)
   [comp] vdadd[4] cfg-in A=(2.315*ES)
   [comp] vtoi[5] cfg-in Y=(3.154*E)
   [comp] vtoi[5] cfg-in K=0.317057704502
   [comp] vtoi[5] cfg-in X=E
   [comp] vgain[6] cfg-in P=(0.21*ES)
   [comp] vgain[6] cfg-in Z=ES
   [comp] vgain[6] cfg-in X=0.21
   [comp] vdadd[7] cfg-in OUT_0=0
   [comp] vdadd[7] cfg-in OUT=P
   [comp] vdadd[7] cfg-param BSW=1
   [comp] vdadd[7] cfg-param DSW=1
   [comp] vdadd[7] cfg-in B=0
   [comp] vdadd[7] cfg-in A=(0.21*ES)
   [comp] vdadd[7] cfg-in D=0
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = S
   [sln] add-comp vdadd[4]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] add-comp vtoi[5]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] conn vtoi[5].Y->vdadd[4].D
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] add-comp vgain[6]
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] conn vgain[6].P->vdadd[7].A
   [sln] generate vdadd[7].OUT = P
   [sln] add-comp vdadd[7]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route itov[3].X = ES
   [sln] route itov[3].K = 2.315
   [sln] route vdadd[4].OUT_0 = 0.00256
   [sln] route vtoi[5].K = 0.317057704502
   [sln] route vtoi[5].X = E
   [sln] route vgain[6].Z = ES
   [sln] route vgain[6].X = 0.21
   [sln] route vdadd[7].OUT_0 = 0
   [sln] route vdadd[7].B = 0
   [sln] route vdadd[7].D = 0
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vtoi5
   [comp] make-comp vgain6
   [comp] make-comp vdadd7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.00256
     [comp] input.V[0] cfg-out O=0.00256
     [comp] input.V[1] cfg-in X=0.317057704502
     [comp] input.V[1] cfg-out O=0.317057704502
     [comp] input.V[2] cfg-in X=0.317057704502
     [comp] input.V[2] cfg-out O=0.317057704502
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.V[4] cfg-in X=0
     [comp] input.V[4] cfg-out O=0
     [comp] input.V[5] cfg-in X=0
     [comp] input.V[5] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[6] cfg-in X=0.00124
     [comp] input.V[6] cfg-out O=0.00124
     [comp] input.V[7] cfg-in X=0.21
     [comp] input.V[7] cfg-out O=0.21
     [comp] input.I[2] cfg-in X=2.525
     [comp] input.I[2] cfg-out O=2.525
     [comp] input.V[8] cfg-in X=2.315
     [comp] input.V[8] cfg-out O=2.315
     [comp] input.I[3] cfg-in X=2.315
     [comp] input.I[3] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route itov[10].X = S
     [sln] rm-route vtoi[2].X = S
     [sln] rm-route vgain[8].X = E
     [sln] rm-route vtoi[5].X = E
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[6].Z = ES
     [sln] rm-route itov[3].X = ES
     [sln] rm-route vgain[8].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vdadd[4].OUT_0 = 0.00256
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.00256
     [sln] rm-route vtoi[5].K = 0.317057704502
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0.317057704502
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.317057704502
     [sln] rm-route vdadd[7].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[7].B = 0
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0
     [sln] rm-route vdadd[9].OUT_0 = 0
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0
     [sln] rm-route vdadd[7].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 0.00124
     [sln] rm-route vgain[6].X = 0.21
     [sln] add-comp input.V[7]
     [sln] generate input.V[7].O = 0.21
     [sln] rm-route vdadd[9].D = 2.525
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.525
     [sln] rm-route itov[3].K = 2.315
     [sln] add-comp input.V[8]
     [sln] generate input.V[8].O = 2.315
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.00256
     [sln] route input.V[1].X = 0.317057704502
     [sln] route input.V[2].X = 0.317057704502
     [sln] route input.V[3].X = 0
     [sln] route input.V[4].X = 0
     [sln] route input.V[5].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[6].X = 0.00124
     [sln] route input.V[7].X = 0.21
     [sln] route input.I[2].X = 2.525
     [sln] route input.V[8].X = 2.315
     [sln] route input.I[3].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I1
     [comp] make-comp input.V6
     [comp] make-comp input.V7
     [comp] make-comp input.I2
     [comp] make-comp input.V8
     [comp] make-comp input.I3
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [1225] [CONN] vdadd[4].OUT => itov[10].X (S)
     add-goal [1226] [CONN] vdadd[4].OUT => vtoi[2].X (S)
     add-goal [1227] [CONN] vdadd[1].OUT => vgain[8].X (E)
     add-goal [1228] [CONN] vdadd[1].OUT => vtoi[5].X (E)
     add-goal [1229] [CONN] vdadd[9].OUT => itov[0].K (ES)
     add-goal [1230] [CONN] vdadd[9].OUT => vgain[6].Z (ES)
     add-goal [1231] [CONN] vdadd[9].OUT => itov[3].X (ES)
     add-goal [1232] [CONN] input.I[0].O => vgain[8].Z (3.154)
     add-goal [1233] [CONN] input.V[0].O => vdadd[4].OUT_0 (0.00256)
     add-goal [1234] [CONN] input.V[1].O => vtoi[5].K (0.317057704502)
     add-goal [1235] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
     add-goal [1236] [CONN] input.V[3].O => vdadd[7].OUT_0 (0)
     add-goal [1237] [CONN] input.V[4].O => vdadd[7].B (0)
     add-goal [1238] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
     add-goal [1239] [CONN] input.I[1].O => vdadd[7].D (0)
     add-goal [1240] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
     add-goal [1241] [CONN] input.V[7].O => vgain[6].X (0.21)
     add-goal [1242] [CONN] input.I[2].O => vdadd[9].D (2.525)
     add-goal [1243] [CONN] input.V[8].O => itov[3].K (2.315)
     add-goal [1244] [CONN] input.I[3].O => itov[0].X (2.315)
     add-goal [1245] [CONN] vdadd[4].OUT => output.V[0].X (S)
     add-goal [1246] [CONN] vdadd[7].OUT => output.V[1].X (P)
     add-goal [1247] [CONN] vdadd[1].OUT => output.V[2].X (E)
     add-goal [1248] [CONN] vdadd[9].OUT => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1235] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
[1238] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
[1244] [CONN] input.I[3].O => itov[0].X (2.315)
[1246] [CONN] vdadd[7].OUT => output.V[1].X (P)
[1232] [CONN] input.I[0].O => vgain[8].Z (3.154)
[1243] [CONN] input.V[8].O => itov[3].K (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1247] [CONN] vdadd[1].OUT => output.V[2].X (E)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1227] [CONN] vdadd[1].OUT => vgain[8].X (E)
[1233] [CONN] input.V[0].O => vdadd[4].OUT_0 (0.00256)
[1234] [CONN] input.V[1].O => vtoi[5].K (0.317057704502)
[1228] [CONN] vdadd[1].OUT => vtoi[5].X (E)
[1240] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1242] [CONN] input.I[2].O => vdadd[9].D (2.525)
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1241] [CONN] input.V[7].O => vgain[6].X (0.21)
[1231] [CONN] vdadd[9].OUT => itov[3].X (ES)
[1236] [CONN] input.V[3].O => vdadd[7].OUT_0 (0)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1226] [CONN] vdadd[4].OUT => vtoi[2].X (S)
[1248] [CONN] vdadd[9].OUT => output.V[3].X (ES)
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1225] [CONN] vdadd[4].OUT => itov[10].X (S)
[1230] [CONN] vdadd[9].OUT => vgain[6].Z (ES)
[1229] [CONN] vdadd[9].OUT => itov[0].K (ES)
[1237] [CONN] input.V[4].O => vdadd[7].B (0)
[1245] [CONN] vdadd[4].OUT => output.V[0].X (S)
[1239] [CONN] input.I[1].O => vdadd[7].D (0)

============
>> Current Goal: [1239] [CONN] input.I[1].O => vdadd[7].D (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.Z
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (74) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=261

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1232] [CONN] input.I[0].O => vgain[8].Z (3.154)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1232] [CONN] input.I[0].O => vgain[8].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=262

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1250] [CONN] input.I[0].O => iadd[0].B (3.154)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1250] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=263

->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=264

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=265

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.V[8].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[7].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.V[8].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     add-goal [1251] [CONN] input.I[4].O => iadd[0].C (0)
     add-goal [1252] [CONN] input.I[5].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1249] [CONN] input.I[0].O => iadd[0].A (3.154)
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1249] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=266

->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=267

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[4]
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.I[5]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 18
[[Z3]] ---> Executing SMT Solver prob=268

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.V[8].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[7].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.V[8].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] route input.I[6].X = 0
     [sln] route input.I[7].X = 0
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     add-goal [1253] [CONN] input.I[6].O => iadd[0].C (0)
     add-goal [1254] [CONN] input.I[7].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1253] [CONN] input.I[6].O => iadd[0].C (0)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1254] [CONN] input.I[7].O => iadd[0].B (0)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1254] [CONN] input.I[7].O => iadd[0].B (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=269

->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[7]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.I[6]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=270

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[4]
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.I[5]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 18
[[Z3]] ---> Executing SMT Solver prob=271

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: E~209ES~153P~27S~213 :: 10
[multi] Number of Solutions: 2
[multi] => Global Solution: E~209ES~153P~27S~143 :: 16
[multi] => Global Solution: E~209ES~153P~27S~145 :: 16
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: E~209ES~153P~27S~213 :: 10
[[Z3]] ---> Executing SMT Solver prob=272

[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: vtoi[5].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: vdadd[7].B
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: itov[3].K
[rslvr] z32cstr.wire: vdadd[7].D
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: vtoi[5].Y
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vtoi[5].K
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: vdadd[7].OUT_0
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: vdadd[7].A
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: itov[3].Y
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: itov[3].X
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: vdadd[7].OUT
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: input.V[4].O
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_2_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_2_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_2_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_2_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=273

[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: vtoi[5].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: vdadd[7].B
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: itov[3].K
[rslvr] z32cstr.wire: vdadd[7].D
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: vtoi[5].Y
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vtoi[5].K
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: vdadd[7].OUT_0
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: vdadd[7].A
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: itov[3].Y
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: itov[3].X
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: vdadd[7].OUT
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: input.V[4].O
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[7]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.I[6]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=274

[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_2_sdeCircMap.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_2_odeCircMap.m
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] found # steps: 42
[multi] # partial ids = 4
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [946] [EXPR]vdadd[6].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[6].D<I>=(3.154*E)
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(0.21*ES)
   [comp] vgain[3] cfg-in Z=ES
   [comp] vgain[3] cfg-in X=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] itov[5] cfg-in Y=(2.315*ES)
   [comp] itov[5] cfg-in K=ES
   [comp] itov[5] cfg-in X=2.315
   [comp] vdadd[6] cfg-in OUT_0=0.00256
   [comp] vdadd[6] cfg-in OUT=S
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=(3.154*E)
   [comp] vdadd[6] cfg-in A=(2.315*ES)
   [comp] vtoi[7] cfg-in Y=(3.154*E)
   [comp] vtoi[7] cfg-in K=0.317057704502
   [comp] vtoi[7] cfg-in X=E
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (2.315*ES)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (2.315*ES)
   [sln] conn itov[5].Y->vdadd[6].A
   [sln] generate vdadd[6].OUT = S
   [sln] add-comp vdadd[6]
   [sln] generate vtoi[7].Y = (3.154*E)
   [sln] add-comp vtoi[7]
   [sln] generate vtoi[7].Y = (3.154*E)
   [sln] conn vtoi[7].Y->vdadd[6].D
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = ES
   [sln] route vgain[3].X = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route itov[5].K = ES
   [sln] route itov[5].X = 2.315
   [sln] route vdadd[6].OUT_0 = 0.00256
   [sln] route vtoi[7].K = 0.317057704502
   [sln] route vtoi[7].X = E
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   [comp] make-comp vdadd6
   [comp] make-comp vtoi7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[6].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[6].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[10].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[8].X = E
[multi]    - connecting generates to routes.
[multi] > vtoi[7].X = E
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > itov[5].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[3].Z = ES
[multi]    - connecting generates to routes.
[multi] > vgain[8].Z = 3.154
[multi]    - making an input block.
[multi] > vdadd[6].OUT_0 = 0.00256
[multi]    - making an input block.
[multi] > vtoi[7].K = 0.317057704502
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].B = 0
[multi]    - making an input block.
[multi] > vdadd[9].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[4].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vgain[3].X = 0.21
[multi]    - making an input block.
[multi] > vdadd[9].D = 2.525
[multi]    - making an input block.
[multi] > itov[5].X = 2.315
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[6].OUT = S
[multi]    - making an output block.
[multi] > vdadd[4].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[9].OUT = ES
[multi]    - making an output block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[5].Y = (2.315*ES)
[multi] > itov[5].Y = (2.315*ES)
[multi] > vtoi[7].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 24
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 159 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [946] [EXPR]vdadd[6].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[6].D<I>=(3.154*E)
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(0.21*ES)
   [comp] vgain[3] cfg-in Z=ES
   [comp] vgain[3] cfg-in X=0.21
   [comp] vdadd[4] cfg-in OUT_0=0
   [comp] vdadd[4] cfg-in OUT=P
   [comp] vdadd[4] cfg-param BSW=1
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in B=0
   [comp] vdadd[4] cfg-in A=(0.21*ES)
   [comp] vdadd[4] cfg-in D=0
   [comp] itov[5] cfg-in Y=(2.315*ES)
   [comp] itov[5] cfg-in K=ES
   [comp] itov[5] cfg-in X=2.315
   [comp] vdadd[6] cfg-in OUT_0=0.00256
   [comp] vdadd[6] cfg-in OUT=S
   [comp] vdadd[6] cfg-param BSW=0
   [comp] vdadd[6] cfg-param DSW=1
   [comp] vdadd[6] cfg-in D=(3.154*E)
   [comp] vdadd[6] cfg-in A=(2.315*ES)
   [comp] vtoi[7] cfg-in Y=(3.154*E)
   [comp] vtoi[7] cfg-in K=0.317057704502
   [comp] vtoi[7] cfg-in X=E
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (0.21*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = P
   [sln] add-comp vdadd[4]
   [sln] generate itov[5].Y = (2.315*ES)
   [sln] add-comp itov[5]
   [sln] generate itov[5].Y = (2.315*ES)
   [sln] conn itov[5].Y->vdadd[6].A
   [sln] generate vdadd[6].OUT = S
   [sln] add-comp vdadd[6]
   [sln] generate vtoi[7].Y = (3.154*E)
   [sln] add-comp vtoi[7]
   [sln] generate vtoi[7].Y = (3.154*E)
   [sln] conn vtoi[7].Y->vdadd[6].D
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = ES
   [sln] route vgain[3].X = 0.21
   [sln] route vdadd[4].OUT_0 = 0
   [sln] route vdadd[4].B = 0
   [sln] route vdadd[4].D = 0
   [sln] route itov[5].K = ES
   [sln] route itov[5].X = 2.315
   [sln] route vdadd[6].OUT_0 = 0.00256
   [sln] route vtoi[7].K = 0.317057704502
   [sln] route vtoi[7].X = E
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp itov5
   [comp] make-comp vdadd6
   [comp] make-comp vtoi7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[4].A<V>=(0.21*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[6].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[6].A<V>=(2.315*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.00256
     [comp] input.V[0] cfg-out O=0.00256
     [comp] input.V[1] cfg-in X=0.317057704502
     [comp] input.V[1] cfg-out O=0.317057704502
     [comp] input.V[2] cfg-in X=0.317057704502
     [comp] input.V[2] cfg-out O=0.317057704502
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.V[4] cfg-in X=0
     [comp] input.V[4] cfg-out O=0
     [comp] input.V[5] cfg-in X=0
     [comp] input.V[5] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[6] cfg-in X=0.00124
     [comp] input.V[6] cfg-out O=0.00124
     [comp] input.V[7] cfg-in X=0.21
     [comp] input.V[7] cfg-out O=0.21
     [comp] input.I[2] cfg-in X=2.525
     [comp] input.I[2] cfg-out O=2.525
     [comp] input.I[3] cfg-in X=2.315
     [comp] input.I[3] cfg-out O=2.315
     [comp] input.I[4] cfg-in X=2.315
     [comp] input.I[4] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route itov[10].X = S
     [sln] rm-route vtoi[2].X = S
     [sln] rm-route vgain[8].X = E
     [sln] rm-route vtoi[7].X = E
     [sln] rm-route itov[0].K = ES
     [sln] rm-route itov[5].K = ES
     [sln] rm-route vgain[3].Z = ES
     [sln] rm-route vgain[8].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vdadd[6].OUT_0 = 0.00256
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.00256
     [sln] rm-route vtoi[7].K = 0.317057704502
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0.317057704502
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.317057704502
     [sln] rm-route vdadd[4].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[4].B = 0
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0
     [sln] rm-route vdadd[9].OUT_0 = 0
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0
     [sln] rm-route vdadd[4].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 0.00124
     [sln] rm-route vgain[3].X = 0.21
     [sln] add-comp input.V[7]
     [sln] generate input.V[7].O = 0.21
     [sln] rm-route vdadd[9].D = 2.525
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.525
     [sln] rm-route itov[5].X = 2.315
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.315
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.00256
     [sln] route input.V[1].X = 0.317057704502
     [sln] route input.V[2].X = 0.317057704502
     [sln] route input.V[3].X = 0
     [sln] route input.V[4].X = 0
     [sln] route input.V[5].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[6].X = 0.00124
     [sln] route input.V[7].X = 0.21
     [sln] route input.I[2].X = 2.525
     [sln] route input.I[3].X = 2.315
     [sln] route input.I[4].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I1
     [comp] make-comp input.V6
     [comp] make-comp input.V7
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [1255] [CONN] vdadd[6].OUT => itov[10].X (S)
     add-goal [1256] [CONN] vdadd[6].OUT => vtoi[2].X (S)
     add-goal [1257] [CONN] vdadd[1].OUT => vgain[8].X (E)
     add-goal [1258] [CONN] vdadd[1].OUT => vtoi[7].X (E)
     add-goal [1259] [CONN] vdadd[9].OUT => itov[0].K (ES)
     add-goal [1260] [CONN] vdadd[9].OUT => itov[5].K (ES)
     add-goal [1261] [CONN] vdadd[9].OUT => vgain[3].Z (ES)
     add-goal [1262] [CONN] input.I[0].O => vgain[8].Z (3.154)
     add-goal [1263] [CONN] input.V[0].O => vdadd[6].OUT_0 (0.00256)
     add-goal [1264] [CONN] input.V[1].O => vtoi[7].K (0.317057704502)
     add-goal [1265] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
     add-goal [1266] [CONN] input.V[3].O => vdadd[4].OUT_0 (0)
     add-goal [1267] [CONN] input.V[4].O => vdadd[4].B (0)
     add-goal [1268] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
     add-goal [1269] [CONN] input.I[1].O => vdadd[4].D (0)
     add-goal [1270] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
     add-goal [1271] [CONN] input.V[7].O => vgain[3].X (0.21)
     add-goal [1272] [CONN] input.I[2].O => vdadd[9].D (2.525)
     add-goal [1273] [CONN] input.I[3].O => itov[5].X (2.315)
     add-goal [1274] [CONN] input.I[4].O => itov[0].X (2.315)
     add-goal [1275] [CONN] vdadd[6].OUT => output.V[0].X (S)
     add-goal [1276] [CONN] vdadd[4].OUT => output.V[1].X (P)
     add-goal [1277] [CONN] vdadd[1].OUT => output.V[2].X (E)
     add-goal [1278] [CONN] vdadd[9].OUT => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1268] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
[1273] [CONN] input.I[3].O => itov[5].X (2.315)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1276] [CONN] vdadd[4].OUT => output.V[1].X (P)
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1260] [CONN] vdadd[9].OUT => itov[5].K (ES)
[1265] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
[1274] [CONN] input.I[4].O => itov[0].X (2.315)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1262] [CONN] input.I[0].O => vgain[8].Z (3.154)
[1278] [CONN] vdadd[9].OUT => output.V[3].X (ES)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1259] [CONN] vdadd[9].OUT => itov[0].K (ES)
[1270] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1272] [CONN] input.I[2].O => vdadd[9].D (2.525)
[1255] [CONN] vdadd[6].OUT => itov[10].X (S)
[1271] [CONN] input.V[7].O => vgain[3].X (0.21)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1275] [CONN] vdadd[6].OUT => output.V[0].X (S)
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1258] [CONN] vdadd[1].OUT => vtoi[7].X (E)
[1263] [CONN] input.V[0].O => vdadd[6].OUT_0 (0.00256)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1256] [CONN] vdadd[6].OUT => vtoi[2].X (S)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1257] [CONN] vdadd[1].OUT => vgain[8].X (E)
[1266] [CONN] input.V[3].O => vdadd[4].OUT_0 (0)
[1261] [CONN] vdadd[9].OUT => vgain[3].Z (ES)
[1264] [CONN] input.V[1].O => vtoi[7].K (0.317057704502)
[1267] [CONN] input.V[4].O => vdadd[4].B (0)
[1269] [CONN] input.I[1].O => vdadd[4].D (0)
[1277] [CONN] vdadd[1].OUT => output.V[2].X (E)

============
>> Current Goal: [1277] [CONN] vdadd[1].OUT => output.V[2].X (E)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.Z
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (74) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=275

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1262] [CONN] input.I[0].O => vgain[8].Z (3.154)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1262] [CONN] input.I[0].O => vgain[8].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=276

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1280] [CONN] input.I[0].O => iadd[0].B (3.154)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1280] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=277

->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=278

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=279

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[6].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[5].Y = (2.315*ES)
[multi] > itov[5].Y = (2.315*ES)
[multi] > vtoi[7].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     add-goal [1281] [CONN] input.I[5].O => iadd[0].C (0)
     add-goal [1282] [CONN] input.I[6].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1279] [CONN] input.I[0].O => iadd[0].A (3.154)
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1279] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=280

->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=281

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.I[5]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.I[6]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 18
[[Z3]] ---> Executing SMT Solver prob=282

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[6].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[4].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[3].P = (0.21*ES)
[multi] > vgain[3].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[5].Y = (2.315*ES)
[multi] > itov[5].Y = (2.315*ES)
[multi] > vtoi[7].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] route input.I[7].X = 0
     [sln] route input.I[8].X = 0
     [comp] make-comp input.I7
     [comp] make-comp input.I8
     add-goal [1283] [CONN] input.I[7].O => iadd[0].C (0)
     add-goal [1284] [CONN] input.I[8].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1284] [CONN] input.I[8].O => iadd[0].B (0)
[1283] [CONN] input.I[7].O => iadd[0].C (0)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1283] [CONN] input.I[7].O => iadd[0].C (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=283

->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->input.I[8]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->itov[10]
->input.I[7]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=284

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.I[5]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->itov[10]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.I[6]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 18
[[Z3]] ---> Executing SMT Solver prob=285

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: E~209ES~153P~27S~209 :: 10
[multi] Number of Solutions: 3
[multi] => Global Solution: E~209ES~153P~27S~213 :: 10
[multi] => Global Solution: E~209ES~153P~27S~143 :: 16
[multi] => Global Solution: E~209ES~153P~27S~145 :: 16
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: E~209ES~153P~27S~209 :: 10
[[Z3]] ---> Executing SMT Solver prob=286

[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vtoi[7].Y
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: vdadd[6].OUT_0
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vgain[3].X
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: vtoi[7].K
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: itov[5].K
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vdadd[4].B
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: vgain[3].Z
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: itov[5].X
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: vdadd[6].A
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: vdadd[6].D
[rslvr] z32cstr.wire: itov[5].Y
[rslvr] z32cstr.wire: vdadd[6].OUT
[rslvr] z32cstr.wire: vtoi[7].X
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vgain[3].P
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: input.I[8].O
[rslvr] z32cstr.wire: input.V[4].O
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_3_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_3_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_3_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_3_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=287

[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vtoi[7].Y
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: vdadd[6].OUT_0
[rslvr] z32cstr.wire: input.V[5].O
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vgain[3].X
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: vtoi[7].K
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: itov[5].K
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vdadd[4].B
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: vgain[3].Z
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: itov[5].X
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: vdadd[6].A
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: vdadd[6].D
[rslvr] z32cstr.wire: itov[5].Y
[rslvr] z32cstr.wire: vdadd[6].OUT
[rslvr] z32cstr.wire: vtoi[7].X
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vgain[3].P
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: input.I[8].O
[rslvr] z32cstr.wire: input.V[4].O
->input.I[3]
->input.I[4]
->vgain[8]
->vdadd[9]
->input.I[8]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[5]
->itov[10]
->input.I[7]
->input.I[2]
->input.V[2]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->vdadd[6]
->output.V[2]
->vgain[3]
->vtoi[7]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=288

[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_3_sdeCircMap.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_3_odeCircMap.m
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] # partial ids = 4
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   remove-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] itov[3] cfg-in Y=(2.315*ES)
   [comp] itov[3] cfg-in K=ES
   [comp] itov[3] cfg-in X=2.315
   [comp] vdadd[4] cfg-in OUT_0=0.00256
   [comp] vdadd[4] cfg-in OUT=S
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=(3.154*E)
   [comp] vdadd[4] cfg-in A=(2.315*ES)
   [comp] vtoi[5] cfg-in Y=(3.154*E)
   [comp] vtoi[5] cfg-in K=0.317057704502
   [comp] vtoi[5] cfg-in X=E
   [comp] vgain[6] cfg-in P=(0.21*ES)
   [comp] vgain[6] cfg-in Z=ES
   [comp] vgain[6] cfg-in X=0.21
   [comp] vdadd[7] cfg-in OUT_0=0
   [comp] vdadd[7] cfg-in OUT=P
   [comp] vdadd[7] cfg-param BSW=1
   [comp] vdadd[7] cfg-param DSW=1
   [comp] vdadd[7] cfg-in B=0
   [comp] vdadd[7] cfg-in A=(0.21*ES)
   [comp] vdadd[7] cfg-in D=0
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = S
   [sln] add-comp vdadd[4]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] add-comp vtoi[5]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] conn vtoi[5].Y->vdadd[4].D
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] add-comp vgain[6]
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] conn vgain[6].P->vdadd[7].A
   [sln] generate vdadd[7].OUT = P
   [sln] add-comp vdadd[7]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route itov[3].K = ES
   [sln] route itov[3].X = 2.315
   [sln] route vdadd[4].OUT_0 = 0.00256
   [sln] route vtoi[5].K = 0.317057704502
   [sln] route vtoi[5].X = E
   [sln] route vgain[6].Z = ES
   [sln] route vgain[6].X = 0.21
   [sln] route vdadd[7].OUT_0 = 0
   [sln] route vdadd[7].B = 0
   [sln] route vdadd[7].D = 0
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vtoi5
   [comp] make-comp vgain6
   [comp] make-comp vdadd7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[10].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[8].X = E
[multi]    - connecting generates to routes.
[multi] > vtoi[5].X = E
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[6].Z = ES
[multi]    - connecting generates to routes.
[multi] > itov[3].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[8].Z = 3.154
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0.00256
[multi]    - making an input block.
[multi] > vtoi[5].K = 0.317057704502
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[7].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[7].B = 0
[multi]    - making an input block.
[multi] > vdadd[9].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[7].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vgain[6].X = 0.21
[multi]    - making an input block.
[multi] > vdadd[9].D = 2.525
[multi]    - making an input block.
[multi] > itov[3].X = 2.315
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]    - making an output block.
[multi] > vdadd[7].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[9].OUT = ES
[multi]    - making an output block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 24
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 159 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   remove-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] itov[3] cfg-in Y=(2.315*ES)
   [comp] itov[3] cfg-in K=ES
   [comp] itov[3] cfg-in X=2.315
   [comp] vdadd[4] cfg-in OUT_0=0.00256
   [comp] vdadd[4] cfg-in OUT=S
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=(3.154*E)
   [comp] vdadd[4] cfg-in A=(2.315*ES)
   [comp] vtoi[5] cfg-in Y=(3.154*E)
   [comp] vtoi[5] cfg-in K=0.317057704502
   [comp] vtoi[5] cfg-in X=E
   [comp] vgain[6] cfg-in P=(0.21*ES)
   [comp] vgain[6] cfg-in Z=ES
   [comp] vgain[6] cfg-in X=0.21
   [comp] vdadd[7] cfg-in OUT_0=0
   [comp] vdadd[7] cfg-in OUT=P
   [comp] vdadd[7] cfg-param BSW=1
   [comp] vdadd[7] cfg-param DSW=1
   [comp] vdadd[7] cfg-in B=0
   [comp] vdadd[7] cfg-in A=(0.21*ES)
   [comp] vdadd[7] cfg-in D=0
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] add-comp itov[3]
   [sln] generate itov[3].Y = (2.315*ES)
   [sln] conn itov[3].Y->vdadd[4].A
   [sln] generate vdadd[4].OUT = S
   [sln] add-comp vdadd[4]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] add-comp vtoi[5]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] conn vtoi[5].Y->vdadd[4].D
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] add-comp vgain[6]
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] conn vgain[6].P->vdadd[7].A
   [sln] generate vdadd[7].OUT = P
   [sln] add-comp vdadd[7]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route itov[3].K = ES
   [sln] route itov[3].X = 2.315
   [sln] route vdadd[4].OUT_0 = 0.00256
   [sln] route vtoi[5].K = 0.317057704502
   [sln] route vtoi[5].X = E
   [sln] route vgain[6].Z = ES
   [sln] route vgain[6].X = 0.21
   [sln] route vdadd[7].OUT_0 = 0
   [sln] route vdadd[7].B = 0
   [sln] route vdadd[7].D = 0
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp itov3
   [comp] make-comp vdadd4
   [comp] make-comp vtoi5
   [comp] make-comp vgain6
   [comp] make-comp vdadd7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.00256
     [comp] input.V[0] cfg-out O=0.00256
     [comp] input.V[1] cfg-in X=0.317057704502
     [comp] input.V[1] cfg-out O=0.317057704502
     [comp] input.V[2] cfg-in X=0.317057704502
     [comp] input.V[2] cfg-out O=0.317057704502
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.V[4] cfg-in X=0
     [comp] input.V[4] cfg-out O=0
     [comp] input.V[5] cfg-in X=0
     [comp] input.V[5] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[6] cfg-in X=0.00124
     [comp] input.V[6] cfg-out O=0.00124
     [comp] input.V[7] cfg-in X=0.21
     [comp] input.V[7] cfg-out O=0.21
     [comp] input.I[2] cfg-in X=2.525
     [comp] input.I[2] cfg-out O=2.525
     [comp] input.I[3] cfg-in X=2.315
     [comp] input.I[3] cfg-out O=2.315
     [comp] input.I[4] cfg-in X=2.315
     [comp] input.I[4] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route itov[10].X = S
     [sln] rm-route vtoi[2].X = S
     [sln] rm-route vgain[8].X = E
     [sln] rm-route vtoi[5].X = E
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[6].Z = ES
     [sln] rm-route itov[3].K = ES
     [sln] rm-route vgain[8].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vdadd[4].OUT_0 = 0.00256
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.00256
     [sln] rm-route vtoi[5].K = 0.317057704502
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0.317057704502
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.317057704502
     [sln] rm-route vdadd[7].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[7].B = 0
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0
     [sln] rm-route vdadd[9].OUT_0 = 0
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0
     [sln] rm-route vdadd[7].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 0.00124
     [sln] rm-route vgain[6].X = 0.21
     [sln] add-comp input.V[7]
     [sln] generate input.V[7].O = 0.21
     [sln] rm-route vdadd[9].D = 2.525
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.525
     [sln] rm-route itov[3].X = 2.315
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.315
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.00256
     [sln] route input.V[1].X = 0.317057704502
     [sln] route input.V[2].X = 0.317057704502
     [sln] route input.V[3].X = 0
     [sln] route input.V[4].X = 0
     [sln] route input.V[5].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[6].X = 0.00124
     [sln] route input.V[7].X = 0.21
     [sln] route input.I[2].X = 2.525
     [sln] route input.I[3].X = 2.315
     [sln] route input.I[4].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I1
     [comp] make-comp input.V6
     [comp] make-comp input.V7
     [comp] make-comp input.I2
     [comp] make-comp input.I3
     [comp] make-comp input.I4
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [1285] [CONN] vdadd[4].OUT => itov[10].X (S)
     add-goal [1286] [CONN] vdadd[4].OUT => vtoi[2].X (S)
     add-goal [1287] [CONN] vdadd[1].OUT => vgain[8].X (E)
     add-goal [1288] [CONN] vdadd[1].OUT => vtoi[5].X (E)
     add-goal [1289] [CONN] vdadd[9].OUT => itov[0].K (ES)
     add-goal [1290] [CONN] vdadd[9].OUT => vgain[6].Z (ES)
     add-goal [1291] [CONN] vdadd[9].OUT => itov[3].K (ES)
     add-goal [1292] [CONN] input.I[0].O => vgain[8].Z (3.154)
     add-goal [1293] [CONN] input.V[0].O => vdadd[4].OUT_0 (0.00256)
     add-goal [1294] [CONN] input.V[1].O => vtoi[5].K (0.317057704502)
     add-goal [1295] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
     add-goal [1296] [CONN] input.V[3].O => vdadd[7].OUT_0 (0)
     add-goal [1297] [CONN] input.V[4].O => vdadd[7].B (0)
     add-goal [1298] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
     add-goal [1299] [CONN] input.I[1].O => vdadd[7].D (0)
     add-goal [1300] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
     add-goal [1301] [CONN] input.V[7].O => vgain[6].X (0.21)
     add-goal [1302] [CONN] input.I[2].O => vdadd[9].D (2.525)
     add-goal [1303] [CONN] input.I[3].O => itov[3].X (2.315)
     add-goal [1304] [CONN] input.I[4].O => itov[0].X (2.315)
     add-goal [1305] [CONN] vdadd[4].OUT => output.V[0].X (S)
     add-goal [1306] [CONN] vdadd[7].OUT => output.V[1].X (P)
     add-goal [1307] [CONN] vdadd[1].OUT => output.V[2].X (E)
     add-goal [1308] [CONN] vdadd[9].OUT => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[1286] [CONN] vdadd[4].OUT => vtoi[2].X (S)
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1296] [CONN] input.V[3].O => vdadd[7].OUT_0 (0)
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1306] [CONN] vdadd[7].OUT => output.V[1].X (P)
[1302] [CONN] input.I[2].O => vdadd[9].D (2.525)
[1289] [CONN] vdadd[9].OUT => itov[0].K (ES)
[1285] [CONN] vdadd[4].OUT => itov[10].X (S)
[1290] [CONN] vdadd[9].OUT => vgain[6].Z (ES)
[1300] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1297] [CONN] input.V[4].O => vdadd[7].B (0)
[1299] [CONN] input.I[1].O => vdadd[7].D (0)
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1293] [CONN] input.V[0].O => vdadd[4].OUT_0 (0.00256)
[1298] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1295] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1287] [CONN] vdadd[1].OUT => vgain[8].X (E)
[1288] [CONN] vdadd[1].OUT => vtoi[5].X (E)
[1307] [CONN] vdadd[1].OUT => output.V[2].X (E)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1292] [CONN] input.I[0].O => vgain[8].Z (3.154)
[1303] [CONN] input.I[3].O => itov[3].X (2.315)
[1304] [CONN] input.I[4].O => itov[0].X (2.315)
[1305] [CONN] vdadd[4].OUT => output.V[0].X (S)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1294] [CONN] input.V[1].O => vtoi[5].K (0.317057704502)
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1291] [CONN] vdadd[9].OUT => itov[3].K (ES)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1308] [CONN] vdadd[9].OUT => output.V[3].X (ES)
[1301] [CONN] input.V[7].O => vgain[6].X (0.21)

============
>> Current Goal: [1301] [CONN] input.V[7].O => vgain[6].X (0.21)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.Z
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[7]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (74) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=289

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1292] [CONN] input.I[0].O => vgain[8].Z (3.154)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1292] [CONN] input.I[0].O => vgain[8].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=290

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1310] [CONN] input.I[0].O => iadd[0].B (3.154)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1310] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=291

->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=292

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=293

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[7].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] route input.I[5].X = 0
     [sln] route input.I[6].X = 0
     [comp] make-comp input.I5
     [comp] make-comp input.I6
     add-goal [1311] [CONN] input.I[5].O => iadd[0].C (0)
     add-goal [1312] [CONN] input.I[6].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1309] [CONN] input.I[0].O => iadd[0].A (3.154)
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1309] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=294

->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=295

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.I[5]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.I[6]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 18
[[Z3]] ---> Executing SMT Solver prob=296

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[4].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[7].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[4].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > itov[3].Y = (2.315*ES)
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [comp] input.I[8] cfg-in X=0
     [comp] input.I[8] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[8]
     [sln] generate input.I[8].O = 0
     [sln] route input.I[7].X = 0
     [sln] route input.I[8].X = 0
     [comp] make-comp input.I7
     [comp] make-comp input.I8
     add-goal [1313] [CONN] input.I[7].O => iadd[0].C (0)
     add-goal [1314] [CONN] input.I[8].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1313] [CONN] input.I[7].O => iadd[0].C (0)
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1314] [CONN] input.I[8].O => iadd[0].B (0)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1314] [CONN] input.I[8].O => iadd[0].B (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=297

->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->input.I[8]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[7]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=298

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.I[5]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.I[6]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 18
[[Z3]] ---> Executing SMT Solver prob=299

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: E~209ES~153P~27S~211 :: 10
[multi] Number of Solutions: 4
[multi] => Global Solution: E~209ES~153P~27S~213 :: 10
[multi] => Global Solution: E~209ES~153P~27S~209 :: 10
[multi] => Global Solution: E~209ES~153P~27S~143 :: 16
[multi] => Global Solution: E~209ES~153P~27S~145 :: 16
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: E~209ES~153P~27S~211 :: 10
[[Z3]] ---> Executing SMT Solver prob=300

[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vtoi[5].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vdadd[7].D
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: vdadd[7].B
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: input.I[8].O
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: vtoi[5].K
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: itov[3].K
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: itov[3].X
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: vdadd[7].OUT_0
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: vdadd[7].A
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vdadd[7].OUT
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: itov[3].Y
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: vtoi[5].Y
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: input.V[5].O
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_4_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_4_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_4_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_4_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=301

[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vtoi[5].X
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: vdadd[7].D
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: vdadd[7].B
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: input.I[8].O
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: vtoi[5].K
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: itov[3].K
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.I[4].O
[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: itov[3].X
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: vdadd[7].OUT_0
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: vdadd[7].A
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vdadd[7].OUT
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: itov[3].Y
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: vtoi[5].Y
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: input.V[5].O
->input.I[3]
->input.I[4]
->vgain[6]
->vgain[8]
->vdadd[9]
->input.I[8]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[7]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->itov[3]
->output.V[1]
->input.V[3]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=302

[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_4_sdeCircMap.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_4_odeCircMap.m
===== Mapping Step Finished ======
[multi]  > Added Local Solution
[multi]  > Finding Global Solution
[multi] found # steps: 42
[multi] found # steps: 42
[multi] found # steps: 33
[multi] found # steps: 42
[multi] # partial ids = 4
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   remove-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(2.315*ES)
   [comp] vgain[3] cfg-in Z=ES
   [comp] vgain[3] cfg-in X=2.315
   [comp] vdadd[4] cfg-in OUT_0=0.00256
   [comp] vdadd[4] cfg-in OUT=S
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=(3.154*E)
   [comp] vdadd[4] cfg-in A=(2.315*ES)
   [comp] vtoi[5] cfg-in Y=(3.154*E)
   [comp] vtoi[5] cfg-in K=0.317057704502
   [comp] vtoi[5] cfg-in X=E
   [comp] vgain[6] cfg-in P=(0.21*ES)
   [comp] vgain[6] cfg-in Z=ES
   [comp] vgain[6] cfg-in X=0.21
   [comp] vdadd[7] cfg-in OUT_0=0
   [comp] vdadd[7] cfg-in OUT=P
   [comp] vdadd[7] cfg-param BSW=1
   [comp] vdadd[7] cfg-param DSW=1
   [comp] vdadd[7] cfg-in B=0
   [comp] vdadd[7] cfg-in A=(0.21*ES)
   [comp] vdadd[7] cfg-in D=0
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (2.315*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (2.315*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = S
   [sln] add-comp vdadd[4]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] add-comp vtoi[5]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] conn vtoi[5].Y->vdadd[4].D
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] add-comp vgain[6]
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] conn vgain[6].P->vdadd[7].A
   [sln] generate vdadd[7].OUT = P
   [sln] add-comp vdadd[7]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = ES
   [sln] route vgain[3].X = 2.315
   [sln] route vdadd[4].OUT_0 = 0.00256
   [sln] route vtoi[5].K = 0.317057704502
   [sln] route vtoi[5].X = E
   [sln] route vgain[6].Z = ES
   [sln] route vgain[6].X = 0.21
   [sln] route vdadd[7].OUT_0 = 0
   [sln] route vdadd[7].B = 0
   [sln] route vdadd[7].D = 0
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vtoi5
   [comp] make-comp vgain6
   [comp] make-comp vdadd7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ==== ROUTES =====
[multi] > itov[10].X = S
[multi]    - connecting generates to routes.
[multi] > vtoi[2].X = S
[multi]    - connecting generates to routes.
[multi] > vgain[8].X = E
[multi]    - connecting generates to routes.
[multi] > vtoi[5].X = E
[multi]    - connecting generates to routes.
[multi] > itov[0].K = ES
[multi]    - connecting generates to routes.
[multi] > vgain[6].Z = ES
[multi]    - connecting generates to routes.
[multi] > vgain[3].Z = ES
[multi]    - connecting generates to routes.
[multi] > vgain[8].Z = 3.154
[multi]    - making an input block.
[multi] > vdadd[4].OUT_0 = 0.00256
[multi]    - making an input block.
[multi] > vtoi[5].K = 0.317057704502
[multi]    - making an input block.
[multi] > vtoi[2].K = 0.317057704502
[multi]    - making an input block.
[multi] > vdadd[7].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[7].B = 0
[multi]    - making an input block.
[multi] > vdadd[9].OUT_0 = 0
[multi]    - making an input block.
[multi] > vdadd[7].D = 0
[multi]    - making an input block.
[multi] > vdadd[1].OUT_0 = 0.00124
[multi]    - making an input block.
[multi] > vgain[6].X = 0.21
[multi]    - making an input block.
[multi] > vdadd[9].D = 2.525
[multi]    - making an input block.
[multi] > vgain[3].X = 2.315
[multi]    - making an input block.
[multi] > itov[0].X = 2.315
[multi]    - making an input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]    - making an output block.
[multi] > vdadd[7].OUT = P
[multi]    - making an output block.
[multi] > vdadd[1].OUT = E
[multi]    - making an output block.
[multi] > vdadd[9].OUT = ES
[multi]    - making an output block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 24
[multi] --> Number of nodes 1
[multi] ======= Partial (Root) Steps 159 =======
[multi]    remove-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   remove-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   remove-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   remove-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   remove-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   remove-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   remove-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [220] [EXPR]itov[10].K<V>=(3.154*E)
   remove-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   remove-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   [comp] itov[0] cfg-in Y=(2.315*ES)
   [comp] itov[0] cfg-in K=ES
   [comp] itov[0] cfg-in X=2.315
   [comp] vdadd[1] cfg-in OUT_0=0.00124
   [comp] vdadd[1] cfg-in OUT=E
   [comp] vdadd[1] cfg-param BSW=0
   [comp] vdadd[1] cfg-param DSW=1
   [comp] vdadd[1] cfg-in D=(3.154*S)
   [comp] vdadd[1] cfg-in A=(2.315*ES)
   [comp] vtoi[2] cfg-in Y=(3.154*S)
   [comp] vtoi[2] cfg-in X=S
   [comp] vtoi[2] cfg-in K=0.317057704502
   [comp] vgain[3] cfg-in P=(2.315*ES)
   [comp] vgain[3] cfg-in Z=ES
   [comp] vgain[3] cfg-in X=2.315
   [comp] vdadd[4] cfg-in OUT_0=0.00256
   [comp] vdadd[4] cfg-in OUT=S
   [comp] vdadd[4] cfg-param BSW=0
   [comp] vdadd[4] cfg-param DSW=1
   [comp] vdadd[4] cfg-in D=(3.154*E)
   [comp] vdadd[4] cfg-in A=(2.315*ES)
   [comp] vtoi[5] cfg-in Y=(3.154*E)
   [comp] vtoi[5] cfg-in K=0.317057704502
   [comp] vtoi[5] cfg-in X=E
   [comp] vgain[6] cfg-in P=(0.21*ES)
   [comp] vgain[6] cfg-in Z=ES
   [comp] vgain[6] cfg-in X=0.21
   [comp] vdadd[7] cfg-in OUT_0=0
   [comp] vdadd[7] cfg-in OUT=P
   [comp] vdadd[7] cfg-param BSW=1
   [comp] vdadd[7] cfg-param DSW=1
   [comp] vdadd[7] cfg-in B=0
   [comp] vdadd[7] cfg-in A=(0.21*ES)
   [comp] vdadd[7] cfg-in D=0
   [comp] vgain[8] cfg-in P=(3.154*E)
   [comp] vgain[8] cfg-in Z=3.154
   [comp] vgain[8] cfg-in X=E
   [comp] vdadd[9] cfg-in OUT_0=0
   [comp] vdadd[9] cfg-in OUT=ES
   [comp] vdadd[9] cfg-param BSW=0
   [comp] vdadd[9] cfg-param DSW=1
   [comp] vdadd[9] cfg-in D=2.525
   [comp] vdadd[9] cfg-in A=(3.154*E*S)
   [comp] itov[10] cfg-in Y=(3.154*E*S)
   [comp] itov[10] cfg-in X=S
   [comp] itov[10] cfg-in K=(3.154*E)
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] add-comp itov[0]
   [sln] generate itov[0].Y = (2.315*ES)
   [sln] conn itov[0].Y->vdadd[1].A
   [sln] generate vdadd[1].OUT = E
   [sln] add-comp vdadd[1]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] add-comp vtoi[2]
   [sln] generate vtoi[2].Y = (3.154*S)
   [sln] conn vtoi[2].Y->vdadd[1].D
   [sln] generate vgain[3].P = (2.315*ES)
   [sln] add-comp vgain[3]
   [sln] generate vgain[3].P = (2.315*ES)
   [sln] conn vgain[3].P->vdadd[4].A
   [sln] generate vdadd[4].OUT = S
   [sln] add-comp vdadd[4]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] add-comp vtoi[5]
   [sln] generate vtoi[5].Y = (3.154*E)
   [sln] conn vtoi[5].Y->vdadd[4].D
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] add-comp vgain[6]
   [sln] generate vgain[6].P = (0.21*ES)
   [sln] conn vgain[6].P->vdadd[7].A
   [sln] generate vdadd[7].OUT = P
   [sln] add-comp vdadd[7]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] add-comp vgain[8]
   [sln] generate vgain[8].P = (3.154*E)
   [sln] conn vgain[8].P->itov[10].K
   [sln] generate vdadd[9].OUT = ES
   [sln] add-comp vdadd[9]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] add-comp itov[10]
   [sln] generate itov[10].Y = (3.154*E*S)
   [sln] conn itov[10].Y->vdadd[9].A
   [sln] route itov[0].K = ES
   [sln] route itov[0].X = 2.315
   [sln] route vdadd[1].OUT_0 = 0.00124
   [sln] route vtoi[2].X = S
   [sln] route vtoi[2].K = 0.317057704502
   [sln] route vgain[3].Z = ES
   [sln] route vgain[3].X = 2.315
   [sln] route vdadd[4].OUT_0 = 0.00256
   [sln] route vtoi[5].K = 0.317057704502
   [sln] route vtoi[5].X = E
   [sln] route vgain[6].Z = ES
   [sln] route vgain[6].X = 0.21
   [sln] route vdadd[7].OUT_0 = 0
   [sln] route vdadd[7].B = 0
   [sln] route vdadd[7].D = 0
   [sln] route vgain[8].Z = 3.154
   [sln] route vgain[8].X = E
   [sln] route vdadd[9].OUT_0 = 0
   [sln] route vdadd[9].D = 2.525
   [sln] route itov[10].X = S
   [comp] make-comp itov0
   [comp] make-comp vdadd1
   [comp] make-comp vtoi2
   [comp] make-comp vgain3
   [comp] make-comp vdadd4
   [comp] make-comp vtoi5
   [comp] make-comp vgain6
   [comp] make-comp vdadd7
   [comp] make-comp vgain8
   [comp] make-comp vdadd9
   [comp] make-comp itov10
   change-goal-status 253 to disabled
   change-goal-status 254 to disabled
   change-goal-status 256 to disabled
   change-goal-status 862 to disabled
   change-goal-status 863 to disabled
   change-goal-status 864 to disabled
   change-goal-status 653 to disabled
   change-goal-status 655 to disabled
   change-goal-status 656 to disabled
   change-goal-status 0 to disabled
   change-goal-status 1 to disabled
   change-goal-status 2 to disabled
   add-goal [253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [255] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [339] [EXPR]vdadd[1].D<I>=(3.154*S)
   add-goal [338] [EXPR]vdadd[1].A<V>=(2.315*ES)
   add-goal [861] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [947] [EXPR]vdadd[4].D<I>=(3.154*E)
   add-goal [946] [EXPR]vdadd[4].A<V>=(2.315*ES)
   add-goal [653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [654] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [672] [EXPR]vdadd[7].A<V>=(0.21*ES)
   add-goal [0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
   add-goal [1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [3] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
   add-goal [69] [EXPR]vdadd[9].A<V>=(3.154*E*S)
   add-goal [220] [EXPR]itov[10].K<V>=(3.154*E)

[multi] ============================
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[0] cfg-in X=3.154
     [comp] input.I[0] cfg-out O=3.154
     [comp] input.V[0] cfg-in X=0.00256
     [comp] input.V[0] cfg-out O=0.00256
     [comp] input.V[1] cfg-in X=0.317057704502
     [comp] input.V[1] cfg-out O=0.317057704502
     [comp] input.V[2] cfg-in X=0.317057704502
     [comp] input.V[2] cfg-out O=0.317057704502
     [comp] input.V[3] cfg-in X=0
     [comp] input.V[3] cfg-out O=0
     [comp] input.V[4] cfg-in X=0
     [comp] input.V[4] cfg-out O=0
     [comp] input.V[5] cfg-in X=0
     [comp] input.V[5] cfg-out O=0
     [comp] input.I[1] cfg-in X=0
     [comp] input.I[1] cfg-out O=0
     [comp] input.V[6] cfg-in X=0.00124
     [comp] input.V[6] cfg-out O=0.00124
     [comp] input.V[7] cfg-in X=0.21
     [comp] input.V[7] cfg-out O=0.21
     [comp] input.I[2] cfg-in X=2.525
     [comp] input.I[2] cfg-out O=2.525
     [comp] input.V[8] cfg-in X=2.315
     [comp] input.V[8] cfg-out O=2.315
     [comp] input.I[3] cfg-in X=2.315
     [comp] input.I[3] cfg-out O=2.315
     [comp] output.V[0] cfg-in X=S
     [comp] output.V[0] cfg-out O=S
     [comp] output.V[1] cfg-in X=P
     [comp] output.V[1] cfg-out O=P
     [comp] output.V[2] cfg-in X=E
     [comp] output.V[2] cfg-out O=E
     [comp] output.V[3] cfg-in X=ES
     [comp] output.V[3] cfg-out O=ES
     [sln] rm-route itov[10].X = S
     [sln] rm-route vtoi[2].X = S
     [sln] rm-route vgain[8].X = E
     [sln] rm-route vtoi[5].X = E
     [sln] rm-route itov[0].K = ES
     [sln] rm-route vgain[6].Z = ES
     [sln] rm-route vgain[3].Z = ES
     [sln] rm-route vgain[8].Z = 3.154
     [sln] add-comp input.I[0]
     [sln] generate input.I[0].O = 3.154
     [sln] rm-route vdadd[4].OUT_0 = 0.00256
     [sln] add-comp input.V[0]
     [sln] generate input.V[0].O = 0.00256
     [sln] rm-route vtoi[5].K = 0.317057704502
     [sln] add-comp input.V[1]
     [sln] generate input.V[1].O = 0.317057704502
     [sln] rm-route vtoi[2].K = 0.317057704502
     [sln] add-comp input.V[2]
     [sln] generate input.V[2].O = 0.317057704502
     [sln] rm-route vdadd[7].OUT_0 = 0
     [sln] add-comp input.V[3]
     [sln] generate input.V[3].O = 0
     [sln] rm-route vdadd[7].B = 0
     [sln] add-comp input.V[4]
     [sln] generate input.V[4].O = 0
     [sln] rm-route vdadd[9].OUT_0 = 0
     [sln] add-comp input.V[5]
     [sln] generate input.V[5].O = 0
     [sln] rm-route vdadd[7].D = 0
     [sln] add-comp input.I[1]
     [sln] generate input.I[1].O = 0
     [sln] rm-route vdadd[1].OUT_0 = 0.00124
     [sln] add-comp input.V[6]
     [sln] generate input.V[6].O = 0.00124
     [sln] rm-route vgain[6].X = 0.21
     [sln] add-comp input.V[7]
     [sln] generate input.V[7].O = 0.21
     [sln] rm-route vdadd[9].D = 2.525
     [sln] add-comp input.I[2]
     [sln] generate input.I[2].O = 2.525
     [sln] rm-route vgain[3].X = 2.315
     [sln] add-comp input.V[8]
     [sln] generate input.V[8].O = 2.315
     [sln] rm-route itov[0].X = 2.315
     [sln] add-comp input.I[3]
     [sln] generate input.I[3].O = 2.315
     [sln] add-comp output.V[0]
     [sln] generate output.V[0].O = S
     [sln] add-comp output.V[1]
     [sln] generate output.V[1].O = P
     [sln] add-comp output.V[2]
     [sln] generate output.V[2].O = E
     [sln] add-comp output.V[3]
     [sln] generate output.V[3].O = ES
     [sln] route input.I[0].X = 3.154
     [sln] route input.V[0].X = 0.00256
     [sln] route input.V[1].X = 0.317057704502
     [sln] route input.V[2].X = 0.317057704502
     [sln] route input.V[3].X = 0
     [sln] route input.V[4].X = 0
     [sln] route input.V[5].X = 0
     [sln] route input.I[1].X = 0
     [sln] route input.V[6].X = 0.00124
     [sln] route input.V[7].X = 0.21
     [sln] route input.I[2].X = 2.525
     [sln] route input.V[8].X = 2.315
     [sln] route input.I[3].X = 2.315
     [comp] make-comp input.I0
     [comp] make-comp input.V0
     [comp] make-comp input.V1
     [comp] make-comp input.V2
     [comp] make-comp input.V3
     [comp] make-comp input.V4
     [comp] make-comp input.V5
     [comp] make-comp input.I1
     [comp] make-comp input.V6
     [comp] make-comp input.V7
     [comp] make-comp input.I2
     [comp] make-comp input.V8
     [comp] make-comp input.I3
     [comp] make-comp output.V0
     [comp] make-comp output.V1
     [comp] make-comp output.V2
     [comp] make-comp output.V3
     add-goal [1315] [CONN] vdadd[4].OUT => itov[10].X (S)
     add-goal [1316] [CONN] vdadd[4].OUT => vtoi[2].X (S)
     add-goal [1317] [CONN] vdadd[1].OUT => vgain[8].X (E)
     add-goal [1318] [CONN] vdadd[1].OUT => vtoi[5].X (E)
     add-goal [1319] [CONN] vdadd[9].OUT => itov[0].K (ES)
     add-goal [1320] [CONN] vdadd[9].OUT => vgain[6].Z (ES)
     add-goal [1321] [CONN] vdadd[9].OUT => vgain[3].Z (ES)
     add-goal [1322] [CONN] input.I[0].O => vgain[8].Z (3.154)
     add-goal [1323] [CONN] input.V[0].O => vdadd[4].OUT_0 (0.00256)
     add-goal [1324] [CONN] input.V[1].O => vtoi[5].K (0.317057704502)
     add-goal [1325] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
     add-goal [1326] [CONN] input.V[3].O => vdadd[7].OUT_0 (0)
     add-goal [1327] [CONN] input.V[4].O => vdadd[7].B (0)
     add-goal [1328] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
     add-goal [1329] [CONN] input.I[1].O => vdadd[7].D (0)
     add-goal [1330] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
     add-goal [1331] [CONN] input.V[7].O => vgain[6].X (0.21)
     add-goal [1332] [CONN] input.I[2].O => vdadd[9].D (2.525)
     add-goal [1333] [CONN] input.V[8].O => vgain[3].X (2.315)
     add-goal [1334] [CONN] input.I[3].O => itov[0].X (2.315)
     add-goal [1335] [CONN] vdadd[4].OUT => output.V[0].X (S)
     add-goal [1336] [CONN] vdadd[7].OUT => output.V[1].X (P)
     add-goal [1337] [CONN] vdadd[1].OUT => output.V[2].X (E)
     add-goal [1338] [CONN] vdadd[9].OUT => output.V[3].X (ES)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1320] [CONN] vdadd[9].OUT => vgain[6].Z (ES)
[1335] [CONN] vdadd[4].OUT => output.V[0].X (S)
[1329] [CONN] input.I[1].O => vdadd[7].D (0)
[1316] [CONN] vdadd[4].OUT => vtoi[2].X (S)
[1322] [CONN] input.I[0].O => vgain[8].Z (3.154)
[1334] [CONN] input.I[3].O => itov[0].X (2.315)
[1336] [CONN] vdadd[7].OUT => output.V[1].X (P)
[1319] [CONN] vdadd[9].OUT => itov[0].K (ES)
[1323] [CONN] input.V[0].O => vdadd[4].OUT_0 (0.00256)
[1331] [CONN] input.V[7].O => vgain[6].X (0.21)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1326] [CONN] input.V[3].O => vdadd[7].OUT_0 (0)
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1318] [CONN] vdadd[1].OUT => vtoi[5].X (E)
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1324] [CONN] input.V[1].O => vtoi[5].K (0.317057704502)
[1315] [CONN] vdadd[4].OUT => itov[10].X (S)
[1321] [CONN] vdadd[9].OUT => vgain[3].Z (ES)
[1338] [CONN] vdadd[9].OUT => output.V[3].X (ES)
[1327] [CONN] input.V[4].O => vdadd[7].B (0)
[1330] [CONN] input.V[6].O => vdadd[1].OUT_0 (0.00124)
[1332] [CONN] input.I[2].O => vdadd[9].D (2.525)
[1325] [CONN] input.V[2].O => vtoi[2].K (0.317057704502)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1337] [CONN] vdadd[1].OUT => output.V[2].X (E)
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1317] [CONN] vdadd[1].OUT => vgain[8].X (E)
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1333] [CONN] input.V[8].O => vgain[3].X (2.315)
[1328] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)

============
>> Current Goal: [1328] [CONN] input.V[5].O => vdadd[9].OUT_0 (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.Z
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vtoi.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vgain.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.V.O->vdadd.OUT_0
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->itov.K
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->itov.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vtoi.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vdadd.D
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->output.V.X
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>vdadd.OUT->vgain.Z
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 3
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (74) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 15
[[Z3]] ---> Executing SMT Solver prob=303

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1322] [CONN] input.I[0].O => vgain[8].Z (3.154)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1322] [CONN] input.I[0].O => vgain[8].Z (3.154)
iadd.OUT || # ins: 3 / connected / I ?= I/distance=0
iadd.OUT -> true
[eqn] >>> NUMBER OF COMPATIBLE COMPONENTS  1 <<<
[eqn] new: [0] <iadd> output OUT.I
<analog>:((iadd.I{A}:+iadd.I{B}:)-iadd.I{C}:) / std=gauss ((1e-05*iadd.V{OUT}:)+0.001)
<analog> [v]=[-5.,10.] {v}->[v]=@


[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is too complicated: C=(-1*__tmp__)
[eqn]     -> failed to convert unify steps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: A=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] ==== iadd====

[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: OUT=__tmp__
[WARN][add_passthru_step.RAddInAssign] this assignment is perfect!: B=__tmp__
[eqn]     -> converted to 12 ssteps
[eqn] [FOUND-SOLS] ===> Found <2> solutions
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->vgain.Z
[eqn] -> [valid?] testing node 5
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=304

SAT
[eqn] <<< SAT => VALID >>
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1340] [CONN] input.I[0].O => iadd[0].B (3.154)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1340] [CONN] input.I[0].O => iadd[0].B (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 6
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=305

->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=306

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 4
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 16
[[Z3]] ---> Executing SMT Solver prob=307

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].A = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.V[8].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[7].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.V[8].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[4] cfg-in X=0
     [comp] input.I[4] cfg-out O=0
     [comp] input.I[5] cfg-in X=0
     [comp] input.I[5] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[4]
     [sln] generate input.I[4].O = 0
     [sln] rm-route iadd[0].A = 0
     [sln] add-comp input.I[5]
     [sln] generate input.I[5].O = 0
     [sln] route input.I[4].X = 0
     [sln] route input.I[5].X = 0
     [comp] make-comp input.I4
     [comp] make-comp input.I5
     add-goal [1341] [CONN] input.I[4].O => iadd[0].C (0)
     add-goal [1342] [CONN] input.I[5].O => iadd[0].A (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1339] [CONN] input.I[0].O => iadd[0].A (3.154)
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1339] [CONN] input.I[0].O => iadd[0].A (3.154)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.A
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 8
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=308

->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (77) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=309

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[4]
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.I[5]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 18
[[Z3]] ---> Executing SMT Solver prob=310

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi] ==== ROUTES =====
[multi] > input.I[0].X = 3.154
[multi]     - ignoring route to input block.
[multi] > input.V[0].X = 0.00256
[multi]     - ignoring route to input block.
[multi] > input.V[1].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > input.V[2].X = 0.317057704502
[multi]     - ignoring route to input block.
[multi] > iadd[0].C = 0
[multi]    - making an input block.
[multi] > iadd[0].B = 0
[multi]    - making an input block.
[multi] > input.V[3].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[4].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[5].X = 0
[multi]     - ignoring route to input block.
[multi] > input.I[1].X = 0
[multi]     - ignoring route to input block.
[multi] > input.V[6].X = 0.00124
[multi]     - ignoring route to input block.
[multi] > input.V[7].X = 0.21
[multi]     - ignoring route to input block.
[multi] > input.I[2].X = 2.525
[multi]     - ignoring route to input block.
[multi] > input.V[8].X = 2.315
[multi]     - ignoring route to input block.
[multi] > input.I[3].X = 2.315
[multi]     - ignoring route to input block.
[multi] ==== GENERATES =====
[multi] > vdadd[4].OUT = S
[multi]     - ignoring connected output block
[multi] > output.V[0].O = S
[multi]     - ignoring generate to output block.
[multi] > vdadd[7].OUT = P
[multi]     - ignoring connected output block
[multi] > output.V[1].O = P
[multi]     - ignoring generate to output block.
[multi] > vdadd[1].OUT = E
[multi]     - ignoring connected output block
[multi] > output.V[2].O = E
[multi]     - ignoring generate to output block.
[multi] > vdadd[9].OUT = ES
[multi]     - ignoring connected output block
[multi] > output.V[3].O = ES
[multi]     - ignoring generate to output block.
[multi] > input.I[0].O = 3.154
[multi]     - ignoring generate to input block.
[multi] > input.V[0].O = 0.00256
[multi]     - ignoring generate to input block.
[multi] > input.V[2].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[1].O = 0.317057704502
[multi]     - ignoring generate to input block.
[multi] > input.V[3].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[4].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.I[1].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[5].O = 0
[multi]     - ignoring generate to input block.
[multi] > input.V[6].O = 0.00124
[multi]     - ignoring generate to input block.
[multi] > input.V[7].O = 0.21
[multi]     - ignoring generate to input block.
[multi] > input.I[2].O = 2.525
[multi]     - ignoring generate to input block.
[multi] > input.I[3].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > input.V[8].O = 2.315
[multi]     - ignoring generate to input block.
[multi] > vgain[6].P = (0.21*ES)
[multi] > vgain[6].P = (0.21*ES)
[multi] > itov[0].Y = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > vgain[3].P = (2.315*ES)
[multi] > vtoi[5].Y = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vgain[8].P = (3.154*E)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > vtoi[2].Y = (3.154*S)
[multi] > iadd[0].OUT = 3.154
[multi] > itov[10].Y = (3.154*E*S)
[multi] > itov[10].Y = (3.154*E*S)
[multi] --> Number of options 2
[multi] --> Number of nodes 1
[multi] ======= New Path =======
[multi] ======= Glbl (Node) Steps =======
[multi]      [comp] input.I[6] cfg-in X=0
     [comp] input.I[6] cfg-out O=0
     [comp] input.I[7] cfg-in X=0
     [comp] input.I[7] cfg-out O=0
     [sln] rm-route iadd[0].C = 0
     [sln] add-comp input.I[6]
     [sln] generate input.I[6].O = 0
     [sln] rm-route iadd[0].B = 0
     [sln] add-comp input.I[7]
     [sln] generate input.I[7].O = 0
     [sln] route input.I[6].X = 0
     [sln] route input.I[7].X = 0
     [comp] make-comp input.I6
     [comp] make-comp input.I7
     add-goal [1343] [CONN] input.I[6].O => iadd[0].C (0)
     add-goal [1344] [CONN] input.I[7].O => iadd[0].B (0)

[multi] ============================
[eqn] find # solutions: 1
[eqn] [search-tree] starting
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> CurrentGoal: (none)
[eqn] found 0 / 1
==== Goals ===
[2] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[655] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[1343] [CONN] input.I[6].O => iadd[0].C (0)
[254] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[256] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[0] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1344] [CONN] input.I[7].O => iadd[0].B (0)
[253] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[864] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[862] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[863] [MATH]output E :> ddt E=((kr*ES)-(kf*E*S)) ic=0.00124 / std(ddt E) = gauss (0.04*E) {[ddt E]=[-1.32468e-05,0.003241] / [E]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[656] [MATH]output ES :> ddt ES=((kf*E*S)-(krcat*ES)) ic=0 / std(ddt ES) = gauss (0.04*ES) {[ddt ES]=[-0.003535,1.32468e-05] / [ES]=[0.,0.0014] / max-sample = <none>min-speed = <none>}
[653] [MATH]output S :> ddt S=((kr*ES)-(kf*E*S)) ic=0.00256 / std(ddt S) = gauss (0.04*S) {[ddt S]=[-1.32468e-05,0.003241] / [S]=[0.,0.003] / max-sample = <none>min-speed = <none>}
[1] [MATH]output P :> ddt P=((kcat*ES)-(krp*P)) ic=0 / std(ddt P) = gauss (0.04*P) {[ddt P]=[0.,0.000294] / [P]=[0.,0.0014] / max-sample = <none>min-speed = <none>}

============
>> Current Goal: [1344] [CONN] input.I[7].O => iadd[0].B (0)
[eqn] >> NEVERMIND! I found some trivial connections.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.B
[eqn] connection is trivial.
[slvrsearch] > weight--: <conn-ports-goal>input.I.O->iadd.C
[eqn] connection is trivial.
[eqn] -> [valid?] testing node 10
[eqn] [test-node-validity] found a valid solution
[eqn] [mark-if-solution] testing if solution.
[rslvr] == Generated Constraints

[rslvr] == Created Z3 Instance

[[Z3]] ---> Executing SMT Solver prob=311

->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[7]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.I[6]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=312

SAT
[eqn] <<< SAT => VALID >>
[eqn] [mark-if-solution] found concrete hardware. marking as solution.
[eqn] [mark-if-solution] -> marked as solution.
[eqn] -> [valid?] testing node 7
->input.I[4]
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.I[5]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 18
[[Z3]] ---> Executing SMT Solver prob=313

SAT
[eqn] <<< SAT => VALID >>
[eqn] [search_tree] Found enough solutions
[multi]   >> Found # Global Solutions: 1/1
[multi] => Global Solution: E~209ES~153P~27S~147 :: 10
[multi] Number of Solutions: 5
[multi] => Global Solution: E~209ES~153P~27S~213 :: 10
[multi] => Global Solution: E~209ES~153P~27S~209 :: 10
[multi] => Global Solution: E~209ES~153P~27S~143 :: 16
[multi] => Global Solution: E~209ES~153P~27S~211 :: 10
[multi] => Global Solution: E~209ES~153P~27S~145 :: 16
[multi] >>>NEW SOLUTION!<<<
[multi] => Global Solution: E~209ES~153P~27S~147 :: 10
[[Z3]] ---> Executing SMT Solver prob=314

[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: vdadd[7].B
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: vtoi[5].K
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: vgain[3].Z
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: vtoi[5].Y
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: vgain[3].X
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: vdadd[7].OUT_0
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: vtoi[5].X
[rslvr] z32cstr.wire: vdadd[7].A
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vgain[3].P
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: vdadd[7].D
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: vdadd[7].OUT
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: input.V[5].O
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_5_sdeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_5_odeIdeal.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_5_sdeCirc.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_5_odeCirc.m
===== Solution Found ======
[[Z3]] ---> Executing SMT Solver prob=315

[rslvr] z32cstr.wire: input.I[1].O
[rslvr] z32cstr.wire: vgain[6].P
[rslvr] z32cstr.wire: iadd[0].A
[rslvr] z32cstr.wire: vtoi[2].X
[rslvr] z32cstr.wire: input.V[4].O
[rslvr] z32cstr.wire: input.I[7].O
[rslvr] z32cstr.wire: output.V[0].X
[rslvr] z32cstr.wire: vgain[6].X
[rslvr] z32cstr.wire: input.V[7].O
[rslvr] z32cstr.wire: vgain[8].Z
[rslvr] z32cstr.wire: iadd[0].C
[rslvr] z32cstr.wire: vdadd[7].B
[rslvr] z32cstr.wire: vdadd[1].OUT_0
[rslvr] z32cstr.wire: vtoi[5].K
[rslvr] z32cstr.wire: input.V[1].O
[rslvr] z32cstr.wire: input.I[6].O
[rslvr] z32cstr.wire: itov[0].K
[rslvr] z32cstr.wire: vdadd[4].OUT
[rslvr] z32cstr.wire: output.V[3].X
[rslvr] z32cstr.wire: vdadd[9].OUT_0
[rslvr] z32cstr.wire: itov[10].X
[rslvr] z32cstr.wire: vdadd[9].A
[rslvr] z32cstr.wire: itov[10].Y
[rslvr] z32cstr.wire: vgain[3].Z
[rslvr] z32cstr.wire: vgain[8].P
[rslvr] z32cstr.wire: vdadd[9].D
[rslvr] z32cstr.wire: vdadd[1].A
[rslvr] z32cstr.wire: input.V[3].O
[rslvr] z32cstr.wire: input.V[2].O
[rslvr] z32cstr.wire: vtoi[5].Y
[rslvr] z32cstr.wire: itov[0].Y
[rslvr] z32cstr.wire: iadd[0].B
[rslvr] z32cstr.wire: itov[0].X
[rslvr] z32cstr.wire: input.I[2].O
[rslvr] z32cstr.wire: vdadd[9].OUT
[rslvr] z32cstr.wire: vgain[3].X
[rslvr] z32cstr.wire: input.V[6].O
[rslvr] z32cstr.wire: vtoi[2].K
[rslvr] z32cstr.wire: vdadd[4].D
[rslvr] z32cstr.wire: vdadd[4].A
[rslvr] z32cstr.wire: iadd[0].OUT
[rslvr] z32cstr.wire: vdadd[7].OUT_0
[rslvr] z32cstr.wire: input.I[3].O
[rslvr] z32cstr.wire: output.V[1].X
[rslvr] z32cstr.wire: vdadd[1].D
[rslvr] z32cstr.wire: vtoi[5].X
[rslvr] z32cstr.wire: vdadd[7].A
[rslvr] z32cstr.wire: input.V[8].O
[rslvr] z32cstr.wire: input.I[0].O
[rslvr] z32cstr.wire: vdadd[4].OUT_0
[rslvr] z32cstr.wire: vgain[8].X
[rslvr] z32cstr.wire: output.V[2].X
[rslvr] z32cstr.wire: vgain[3].P
[rslvr] z32cstr.wire: vgain[6].Z
[rslvr] z32cstr.wire: vdadd[7].D
[rslvr] z32cstr.wire: vtoi[2].Y
[rslvr] z32cstr.wire: vdadd[7].OUT
[rslvr] z32cstr.wire: itov[10].K
[rslvr] z32cstr.wire: input.V[0].O
[rslvr] z32cstr.wire: vdadd[1].OUT
[rslvr] z32cstr.wire: input.V[5].O
->input.I[3]
->vgain[6]
->vgain[8]
->vdadd[9]
->output.V[3]
->input.V[4]
->input.V[6]
->input.I[1]
->itov[0]
->vtoi[2]
->vdadd[1]
->itov[10]
->input.I[7]
->input.I[2]
->vtoi[5]
->input.V[2]
->vdadd[7]
->output.V[0]
->input.V[1]
->input.V[5]
->output.V[1]
->input.V[3]
->input.I[6]
->input.V[8]
->input.V[7]
->iadd[0]
->input.I[0]
->vdadd[4]
->output.V[2]
->vgain[3]
->input.V[0]
=== Proc Insts ===
=== Construct Initial Mappings from Partition ===
-> setting deriv
-> setting deriv
===Constructing Abs Var Contraints (81) ===
=== Constructing Global Constraints ===
== Adding Global Variables ==[!] << SOLVER # VARS = 14
[[Z3]] ---> Executing SMT Solver prob=316

[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_5_sdeCircMap.m
[dbg] === Emitting Library ===
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
[WARN][iter_used_comps] adding assignment for BSW
[WARN][iter_used_comps] adding assignment for DSW
===> Emitting Simulation to ckt_mmrxn_5_odeCircMap.m
===== Mapping Step Finished ======
[multi] # Found 6, Required: 1
[multi] [DONE] found enough solutions
[multi] ===== Getting Solutions =====
[multi] Number of Solutions: 6
[multi] => Global Solution: E~209ES~153P~27S~213 :: 10
[multi] => Global Solution: E~209ES~153P~27S~209 :: 10
[multi] => Global Solution: E~209ES~153P~27S~143 :: 16
[multi] => Global Solution: E~209ES~153P~27S~211 :: 10
[multi] => Global Solution: E~209ES~153P~27S~145 :: 16
[multi] => Global Solution: E~209ES~153P~27S~147 :: 10
